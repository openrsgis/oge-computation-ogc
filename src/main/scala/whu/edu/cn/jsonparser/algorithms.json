{
  "FeatureCollection.filter": {
    "description": "Applies a filter to a given collection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "collection",
        "type": "FeatureCollection",
        "description": "The collection to filter"
      },
      {
        "name": "filter",
        "type": "Object",
        "description": "The filter to apply to the collection. "
      }
    ]
  },
  "CoverageCollection.filter": {
    "description": "Applies a filter to a given collection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "collection",
        "type": "CoverageCollection",
        "description": "The collection to filter"
      },
      {
        "name": "filter",
        "type": "Filter",
        "description": "The filter to apply to the collection. "
      }
    ]
  },
  "Filter.gte": {
    "description": "Creates a unary or binary filter that passes unless the left operand is less than the right operand.",
    "returns": "Filter",
    "args": [
      {
        "name": "leftField",
        "type": "String",
        "description": "A selector for the left operand. Should not be specified if leftValue is specified.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "rightValue",
        "type": "Object",
        "description": "The value of the right operand. Should not be specified if rightField is specified.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "rightField",
        "type": "String",
        "description": "A selector for the right operand. Should not be specified if rightValue is specified.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "leftValue",
        "type": "Object",
        "description": "The value of the left operand. Should not be specified if leftField is specified.",
        "optional": "True",
        "default": "None"
      }
    ]
  },
  "Collection.draw": {
    "description": "Paints a vector collection for visualization. Not intended for use as input to other algorithms.",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "collection",
        "type": "FeatureCollection",
        "description": "The collection to draw"
      },
      {
        "name": "color",
        "type": "String",
        "description": "A hex string in the format RRGGBB specifying the color to use for drawing the features."
      },
      {
        "name": "pointRadius",
        "type": "Integer",
        "description": "The radius in pixels of the point markers.",
        "optional": "True",
        "default": "3"
      },
      {
        "name": "strokeWidth",
        "type": "Integer",
        "description": "The width in pixels of lines and polygon borders.",
        "optional": "True",
        "default": "2"
      }
    ]
  },
  "FeatureCollection.map": {
    "description": "Maps an algorithm over a collection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "collection",
        "type": "FeatureCollection",
        "description": "The collection of the elements to which the algorithm is applied."
      },
      {
        "name": "baseAlgorithm",
        "type": "Algorithm",
        "description": "The algorithm being applied to each element"
      },
      {
        "name": "dropNulls",
        "type": "Boolean",
        "description": "If true, the mapped algorithm is allowed to return nulls, and the elements for which it returns nulls will be dropped.",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Collection.map": {
    "description": "Maps an algorithm over a collection.",
    "returns": "Collection",
    "args": [
      {
        "name": "collection",
        "type": "Collection",
        "description": "The collection of the elements to which the algorithm is applied."
      },
      {
        "name": "baseAlgorithm",
        "type": "Algorithm",
        "description": "The algorithm being applied to each element"
      },
      {
        "name": "dropNulls",
        "type": "Boolean",
        "description": "If true, the mapped algorithm is allowed to return nulls, and the elements for which it returns nulls will be dropped.",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Service.getCollections": {
    "description": "Getting resource Collections",
    "returns": "Collections",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productIDs",
        "type": "List<String>",
        "description": "The id list of products.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Service.getCollection": {
    "description": "Getting resource Collection of certain id",
    "returns": "Collection",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "collectionId",
        "type": "String",
        "description": "The id of target collection."
      }
    ]
  },
  "Service.getFeatureCollection": {
    "description": "Getting feature collection from resource center",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "filter",
        "type": "Filter",
        "description": "Filter the properties of feature collection",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Service.getFeature": {
    "description": "Getting resource feature of certain id",
    "returns": "Feature",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "featureId",
        "type": "String",
        "description": "The id of target feature."
      },
      {
        "name": "dataTime",
        "type": "String",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Service.getCoverageCollection": {
    "description": "Getting resource coverage collection of certain id",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "WGS84",
        "optional": "True"
      }
    ]
  },
  "Service.getCoverage": {
    "description": "Getting resource coverage of certain id",
    "returns": "Coverage",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "coverageID",
        "type": "String",
        "description": "The id of target coverage."
      },
      {
        "name": "subset",
        "type": "List<Float>",
        "description": "The subset of target coverage.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "properties",
        "type": "List<String>",
        "description": "Get the bands.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Service.getProcesses": {
    "description": "Getting processes provided by service center",
    "returns": "Processes",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      }
    ]
  },
  "Service.getProcess": {
    "description": "Getting process provided by service center",
    "returns": "Process",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "processId",
        "type": "String",
        "description": "The id of target process."
      }
    ]
  },
  "ProcessResult.visualize": {
    "description": "Visualize the result of process",
    "returns": "ProcessResult",
    "args": [
      {
        "name": "input",
        "type": "ProcessResult",
        "description": "The result of process to be visualized."
      }
    ]
  },
  "Processes.getProcess": {
    "description": "Get the process form the processes.",
    "returns": "Process",
    "args": [
      {
        "name": "processes",
        "type": "Processes",
        "description": "The processes to be selected."
      },
      {
        "name": "processId",
        "type": "String",
        "description": "The id of the certain process."
      }
    ]
  },
  "Collections.getCollection": {
    "description": "Get the collection from collections.",
    "returns": "Collection",
    "args": [
      {
        "name": "input",
        "type": "Collections",
        "description": "The collections as the input data "
      },
      {
        "name": "collectionId",
        "type": "String",
        "description": "The id of the certain collection."
      }
    ]
  },
  "Collections.toCube": {
    "description": "Transform the collections to cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Collections",
        "description": "The collections as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "Cube的空间范围",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "String",
        "description": "Cube的时间范围",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "Cube采用的投影",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bands",
        "type": "List<String>",
        "description": "波段维度",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Collection.getCollectionType": {
    "description": "Get the type of the collection.",
    "returns": "String",
    "args": [
      {
        "name": "collection",
        "type": "Collection",
        "description": "The collection to get type."
      }
    ]
  },
  "Collection.getItem": {
    "description": "Get the item of a collection.",
    "returns": "Item",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      },
      {
        "name": "itemId",
        "type": "String",
        "description": "The id of the target item."
      }
    ]
  },
  "Collection.getNumItems": {
    "description": "Get the number of items in a collection.",
    "returns": "Integer",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      }
    ]
  },
  "Collection.toFeatureCollection": {
    "description": "Transform the collection to featureCollection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      }
    ]
  },
  "Collection.toCoverageCollection": {
    "description": "Transform the collection to featureCollection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      }
    ]
  },
  "Collection.subCollection": {
    "description": "Get part of collection.",
    "returns": "Collection",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "CoverageCollection.getCollectionType": {
    "description": "Get the type of the coverage collection.",
    "returns": "String",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage collection to get type."
      }
    ]
  },
  "CoverageCollection.getItem": {
    "description": "Get the item of a coverage collection.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "The coverage collection as the input data "
      },
      {
        "name": "itemId",
        "type": "String",
        "description": "The coverage id."
      }
    ]
  },
  "CoverageCollection.getNumItems": {
    "description": "Get the number of items in a coverage collection.",
    "returns": "Integer",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "The coverage collection as the input data "
      }
    ]
  },
  "CoverageCollection.subCollection": {
    "description": "Get part of coverage collection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "The coverage collection as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "filter",
        "type": "Filter",
        "description": "Filter used",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "FeatureCollection.getCollectionType": {
    "description": "Get the type of the feature collection.",
    "returns": "String",
    "args": [
      {
        "name": "featureCollection",
        "type": "FeatureCollection",
        "description": "The feature collection to get type."
      }
    ]
  },
  "FeatureCollection.getItem": {
    "description": "Get the item of a feature collection.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection as the input data "
      },
      {
        "name": "itemId",
        "type": "String",
        "description": "The feature id."
      }
    ]
  },
  "FeatureCollection.getNumItems": {
    "description": "Get the number of items in a feature collection.",
    "returns": "Integer",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection as the input data "
      }
    ]
  },
  "FeatureCollection.subCollection": {
    "description": "Get part of feature collection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "filter",
        "type": "Filter",
        "description": "The filter to filter the featureCollection.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Coverage.domainSet": {
    "description": "Get the domain set of a coverage.",
    "returns": "Dictionary",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The Coverage as the input data "
      }
    ]
  },
  "Coverage.rangeSet": {
    "description": "Get the range set of a coverage.",
    "returns": "Dictionary",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The Coverage as the input data "
      },
      {
        "name": "subset",
        "type": "Dictionary",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "properties",
        "type": "List<String>",
        "description": "Select specific data record fields (measured/observed properties) to be returned.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleFactor",
        "type": "Float",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleAxes",
        "type": "Dictionary",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleSize",
        "type": "Dictionary",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleCrs",
        "type": "String",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Coverage.rangeType": {
    "description": "Get the range type of a coverage.",
    "returns": "Dictionary",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The Coverage as the input data "
      }
    ]
  },
  "Coverage.date": {
    "description": "Return the acquisition date of the given coverage.",
    "returns": "String",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The Coverage as the input data."
      }
    ]
  },
  "Coverage.add": {
    "description": "Adds the first value to the second for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.multiply": {
    "description": "Multiplies the first value by the second. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.addNum": {
    "description": "Add the value to the coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value to add."
      }
    ]
  },
  "Coverage.subtractNum": {
    "description": "Subtract the corresponding value from the coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for subtract."
      }
    ]
  },
  "Coverage.divideNum": {
    "description": "Divide the corresponding value from the coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for divide."
      }
    ]
  },
  "Coverage.multiplyNum": {
    "description": "Multiply the corresponding value to the coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for multiply."
      }
    ]
  },
  "Coverage.powNum": {
    "description": "Raises the first coverage to the power of the value.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for pow."
      }
    ]
  },
  "Coverage.cat": {
    "description": "Combines the given coverages into a single coverage which contains all bands from all of the images.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for cat."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for cat."
      }
    ]
  },
  "Coverage.mod": {
    "description": "Mods the first value to the second for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.modNum": {
    "description": "Mods the coverage to the value.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for pow."
      }
    ]
  },
  "Coverage.subtract": {
    "description": "Subtracts the second value from the first for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.divide": {
    "description": "Divides the first value by the second, returning 0 for division by 0 for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.and": {
    "description": "Returns 1 iff both values are non-zero for each matched pair of bands in coverage1 and coverage2. If both have only 1 band, the 2 band will match.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      }
    ]
  },
  "Coverage.bitwiseAnd": {
    "description": "Calculates the bitwise AND of the input values for each matched pair of bands in image1 and image2. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "Second coverage rdd to operate."
      }
    ]
  },
  "Coverage.or": {
    "description": "Returns 1 iff either values are non-zero for each matched pair of bands in coverage1 and coverage2. If both have only 1 band, the 2 band will match",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      }
    ]
  },
  "Coverage.bitwiseOr": {
    "description": "Calculates the bitwise Or of the input values for each matched pair of bands in image1 and image2. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "Second coverage rdd to operate."
      }
    ]
  },
  "Coverage.bitwiseXor": {
    "description": "Calculates the bitwise XOR of the input values for each matched pair of bands in coverage1 and coverage2. If both have only 1 band, the 2 band will match",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "First coverage to operate."
      }
    ]
  },
  "Coverage.not": {
    "description": "Returns 0 if the input is non-zero, and 1 otherwise.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "First coverage to operate."
      }
    ]
  },
  "Coverage.bitwiseNot": {
    "description": "Calculates the bitwise Not of the input values for a coverage. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "Coverage to operate."
      }
    ]
  },
  "Coverage.binarization": {
    "description": "Returns 0 iff the first value is smaller than threshold,else return 255",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage from which the left operand bands are taken"
      },
      {
        "name": "threshold",
        "type": "Int",
        "description": "threshold"
      }
    ]
  },
  "Coverage.normalizedDifference": {
    "description": "Computes the normalized difference between two bands.The normalized difference is computed as (first − second) / (first + second). ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Covergae",
        "description": "The input covergae"
      },
      {
        "name": "bandNames",
        "type": "List<String>",
        "description": "A list of names specifying the bands to use. If not specified, the first and second bands are used",
        "optional": "True",
        "default": "None"
      }
    ]
  },
  "Coverage.selectBands": {
    "description": "",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "bands",
        "type": "List<String>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.aspectByQGIS": {
    "description": "Calculates the aspect of the Digital Terrain Model in input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Digital Terrain Model raster layer."
      },
      {
        "name": "zFactor",
        "type": "Double",
        "description": "Vertical exaggeration.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Coverage.slopeByQGIS": {
    "description": "Calculates the slope from an input raster layer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Digital Terrain Model raster layer."
      },
      {
        "name": "zFactor",
        "type": "Double",
        "description": "Vertical exaggeration.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Coverage.rescaleRasterByQGIS": {
    "description": "Rescales raster layer to a new value range.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Digital Terrain Model raster layer."
      },
      {
        "name": "minimum",
        "type": "Double",
        "description": "Minimum pixel value to use in the rescaled layer.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "maximum",
        "type": "Double",
        "description": "Maximum pixel value to use in the rescaled layer.",
        "optional": "True",
        "default": 255.0
      },
      {
        "name": "band",
        "type": "Int",
        "description": "If the raster is multiband, choose a band.",
        "optional": "True",
        "default": 1
      }
    ]
  },
  "Coverage.ruggednessIndexByQGIS": {
    "description": "Calculates the quantitative measurement of terrain heterogeneity .",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster layer."
      },
      {
        "name": "zFactor",
        "type": "Double",
        "description": "Vertical exaggeration.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Feature.projectPointsByQGIS": {
    "description": "Projects point geometries by a specified distance and bearing.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Distance to offset geometries, in layer units ",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "bearing",
        "type": "Double",
        "description": "Clockwise angle starting from North, in degree (°) unit ",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.addFieldByQGIS": {
    "description": "Adds a new field to a vector layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "fieldType",
        "type": "String",
        "description": "Type of the new field. You can choose between",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "fieldPrecision",
        "type": "Double",
        "description": "Precision of the field. Useful with Float field type.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "fieldName",
        "type": "String",
        "description": "Name of the new field",
        "optional": "True",
        "default": ""
      },
      {
        "name": "fieldLength",
        "type": "Double",
        "description": "Length of the field",
        "optional": "True",
        "default": 10
      }
    ]
  },
  "Feature.addXYFieldByQGIS": {
    "description": "Adds X and Y (or latitude/longitude) fields to a point layer",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "Coordinate reference system to use for the generated x and y fields.",
        "optional": "True",
        "default": "EPSG:4326"
      },
      {
        "name": "prefix",
        "type": "String",
        "description": "Prefix to add to the new field names to avoid name collisions with fields in the input layer.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.affineTransformByQGIS": {
    "description": "Applies an affine transformation to the layer geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "scaleX",
        "type": "Double",
        "description": "Scaling value (expansion or contraction) to apply on the X axis.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "scaleZ",
        "type": "Double",
        "description": "Scaling value (expansion or contraction) to apply on the Z axis.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "rotationZ",
        "type": "Double",
        "description": "Angle of the rotation in degrees.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "scaleY",
        "type": "Double",
        "description": "Scaling value (expansion or contraction) to apply on the Y axis.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "scaleM",
        "type": "Double",
        "description": "Scaling value (expansion or contraction) to apply on the M axis.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "deltaM",
        "type": "Double",
        "description": "Displacement to apply on the M axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaX",
        "type": "Double",
        "description": "Displacement to apply on the X axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaY",
        "type": "Double",
        "description": "Displacement to apply on the Y axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaZ",
        "type": "Double",
        "description": "Displacement to apply on the Z axis.",
        "optional": "True",
        "default": 0
      }
    ]
  },
  "Feature.antimeridianSplitByQGIS": {
    "description": "Splits a line into multiple geodesic segments",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      }
    ]
  },
  "Feature.arrayOffsetLinesByQGIS": {
    "description": "Creates copies of line features in a layer",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "segments",
        "type": "Double",
        "description": "Number of line segments to use to approximate a quarter circle when creating rounded offsets",
        "optional": "True",
        "default": 8
      },
      {
        "name": "joinStyle",
        "type": "String",
        "description": "Specify whether round, miter or beveled joins should be used when offsetting corners in a line",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "offset",
        "type": "Double",
        "description": "Specify the output line layer with offset features",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "count",
        "type": "Double",
        "description": "Number of offset copies to generate for each feature",
        "optional": "True",
        "default": 10
      },
      {
        "name": "miterLimit",
        "type": "Double",
        "description": "Only applicable for mitered join styles",
        "optional": "True",
        "default": 2.0
      }
    ]
  },
  "Feature.translatedFeaturesByQGIS": {
    "description": "Applies an affine transformation to the layer geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "count",
        "type": "Double",
        "description": "Number of copies to generate for each feature",
        "optional": "True",
        "default": 10
      },
      {
        "name": "deltaM",
        "type": "Double",
        "description": "Displacement to apply on the M axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaX",
        "type": "Double",
        "description": "Displacement to apply on the X axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaY",
        "type": "Double",
        "description": "Displacement to apply on the Y axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaZ",
        "type": "Double",
        "description": "Displacement to apply on the Z axis.",
        "optional": "True",
        "default": 0
      }
    ]
  },
  "Feature.assignProjectionByQGIS": {
    "description": "Assigns a new projection to a vector layer",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "crs",
        "type": "String",
        "description": "Select the new CRS to assign to the vector layer",
        "optional": "True",
        "default": "EPSG:4326 - WGS84"
      }
    ]
  },
  "Feature.offsetLineByQGIS": {
    "description": "Offsets lines by a specified distance",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "segments",
        "type": "Int",
        "description": "Controls the number of line segments to use to approximate a quarter circle",
        "optional": "True",
        "default": 8
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Offset distance",
        "optional": "True",
        "default": 10
      },
      {
        "name": "joinStyle",
        "type": "String",
        "description": "Specifies whether round, miter or beveled joins should be used when offsetting corners in a line",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "miterLimit",
        "type": "Double",
        "description": "Controls the maximum distance from the offset curve",
        "optional": "True",
        "default": 2.0
      }
    ]
  },
  "Feature.pointsAlongLinesByQGIS": {
    "description": "Creates points at regular intervals along line or polygon geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "startOffset",
        "type": "Double",
        "description": "Distance from the beginning of the input line",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Distance between two consecutive points along the line",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "endOffset",
        "type": "Double",
        "description": "Distance from the end of the input line",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.polygonizeByQGIS": {
    "description": "Creates a polygon layer whose features boundaries are generated from a line layer of closed features.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "keepFields",
        "type": "String",
        "description": "Check to keep the field",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Feature.polygonsToLinesByQGIS": {
    "description": "Takes a polygon layer and creates a line layer",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      }
    ]
  },
  "Feature.randomPointsInPolygonsByQGIS": {
    "description": "Creates a point layer with points placed inside the polygons of another layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "minDistance",
        "type": "Double",
        "description": "The minimum distance between points within one polygon feature",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "includePolygonAttributes",
        "type": "String",
        "description": "a point will get the attributes from the line",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "maxTriesPerPoint",
        "type": "Int",
        "description": "The maximum number of tries per point",
        "optional": "True",
        "default": 10
      },
      {
        "name": "pointsNumber",
        "type": "Int",
        "description": "Number of points to create",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minDistanceGlobal",
        "type": "Double",
        "description": "The global minimum distance between points",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.randomPointsOnLinesByQGIS": {
    "description": "Creates a point layer with points placed on the lines of another layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "minDistance",
        "type": "Double",
        "description": "The minimum distance between points within one polygon feature",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "includeLineAttributes",
        "type": "String",
        "description": "a point will get the attributes from the line",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "maxTriesPerPoint",
        "type": "Int",
        "description": "The maximum number of tries per point",
        "optional": "True",
        "default": 10
      },
      {
        "name": "pointsNumber",
        "type": "Int",
        "description": "Number of points to create",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minDistanceGlobal",
        "type": "Double",
        "description": "The global minimum distance between points",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.rotateFeaturesByQGIS": {
    "description": "Rotates feature geometries by the specified angle clockwise.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "anchor",
        "type": "String",
        "description": "X,Y coordinates of the point to rotate the features around",
        "optional": "True",
        "default": ""
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Angle of the rotation in degrees",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.simplifyByQGIS": {
    "description": "Simplifies the geometries in a line or polygon layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "method",
        "type": "String",
        "description": "Simplification method",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "tolerance",
        "type": "Double",
        "description": "Threshold tolerance",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Feature.smoothByQGIS": {
    "description": "Smooths the geometries in a line or polygon layer by adding more vertices and corners to the feature geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "maxAngle",
        "type": "Double",
        "description": "Every node below this value will be smoothed",
        "optional": "True",
        "default": 180.0
      },
      {
        "name": "iterations",
        "type": "Int",
        "description": "Increasing the number of iterations will give smoother geometries",
        "optional": "True",
        "default": 1
      },
      {
        "name": "offset",
        "type": "Double",
        "description": "Increasing values will move the smoothed lines",
        "optional": "True",
        "default": 0.25
      }
    ]
  },
  "Feature.swapXYByQGIS": {
    "description": "Switches the X and Y coordinate values in input geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      }
    ]
  },
  "Feature.transectQGIS": {
    "description": "Switches the X and Y coordinate values in input geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "side",
        "type": "String",
        "description": "Choose the side of the transect. Available options are",
        "optional": "True",
        "default": ""
      },
      {
        "name": "length",
        "type": "Double",
        "description": "Length in map unit of the transect",
        "optional": "True",
        "default": 5.0
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Change the angle of the transect",
        "optional": "True",
        "default": 90.0
      }
    ]
  },
  "Feature.translateGeometryByQGIS": {
    "description": "Moves the geometries within a layer, by offsetting with a predefined X and Y displacement.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "delta_x",
        "type": "Double",
        "description": "Displacement to apply on the X axis",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "delta_y",
        "type": "Double",
        "description": "Displacement to apply on the Y axis",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "delta_z",
        "type": "Double",
        "description": "Displacement to apply on the Z axis",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "delta_m",
        "type": "Double",
        "description": "Displacement to apply on the Z axis",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.convertGeometryTypeByQGIS": {
    "description": "Generates a new layer based on an existing one, with a different type of geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "geometryType",
        "type": "String",
        "description": "Geometry type to apply to the output features. One of:0 — Centroids;1 — Nodes;2 — Linestrings;3 — Multilinestrings;4 — Polygons",
        "optional": "True",
        "default": "0"
      }
    ]
  },
  "Feature.linesToPolygonsByQGIS": {
    "description": "Generates a polygon layer using as polygon rings the lines from an input line layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input line vector layer"
      }
    ]
  },
  "Feature.pointsDisplacementByQGIS": {
    "description": "Given a distance of proximity, identifies nearby point features and radially distributes them over a circle whose center represents their barycenter.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer"
      },
      {
        "name": "proximity",
        "type": "Double",
        "description": "Distance below which point features are considered close. Close features are distributed altogether.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Radius of the circle on which close features are placed",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "horizontal",
        "type": "String",
        "description": "When only two points are identified as close, aligns them horizontally on the circle instead of vertically.",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Feature.randomPointsAlongLineByQGIS": {
    "description": "Creates a new point layer, with points placed on the lines of another layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input line vector layer"
      },
      {
        "name": "pointsNumber",
        "type": "Int",
        "description": "Number of points to create",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minDistance",
        "type": "Double",
        "description": "The minimum distance between points",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.randomPointsInLayerBoundsByQGIS": {
    "description": "Creates a new point layer with a given number of random points, all of them within the extent of a given layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input polygon layer defining the area"
      },
      {
        "name": "pointsNumber",
        "type": "Int",
        "description": "Number of points to create",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minDistance",
        "type": "Double",
        "description": "The minimum distance between points",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.angleToNearestByQGIS": {
    "description": "Calculates the rotation required to align point features with their nearest feature from another reference layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Point features to calculate the rotation for"
      },
      {
        "name": "referenceLayer",
        "type": "String",
        "description": "Layer to find the closest feature from for rotation calculation",
        "optional": "True",
        "default": ""
      },
      {
        "name": "maxDistance",
        "type": "Double",
        "description": "If no reference feature is found within this distance, no rotation is assigned to the point feature.",
        "optional": "True",
        "default": "Not Set"
      },
      {
        "name": "fieldName",
        "type": "String",
        "description": "Field in which to store the rotation value.",
        "optional": "True",
        "default": "rotation"
      },
      {
        "name": "applySymbology",
        "type": "String",
        "description": "Rotates the symbol marker of the features using the angle field value",
        "optional": "True",
        "default": "True"
      }
    ]
  },
  "Feature.boundaryByQGIS": {
    "description": "Returns the closure of the combinatorial boundary of the input geometries",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input line or polygon vector layer"
      }
    ]
  },
  "Feature.miniEnclosingCircleByQGIS": {
    "description": "Calculates the minimum enclosing circles of the features in the input layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "segments",
        "type": "Int",
        "description": "The number of segment used to approximate a circle. Minimum 8, maximum 100000.",
        "optional": "True",
        "default": 72
      }
    ]
  },
  "Feature.multiRingConstantBufferByQGIS": {
    "description": "Computes multi-ring (donut) buffer for the features of the input layer, using a fixed or dynamic distance and number of rings.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "rings",
        "type": "Int",
        "description": "The number of rings. It can be a unique value (same number of rings for all the features) or it can be taken from features data (the number of rings depends on feature values).",
        "optional": "True",
        "default": 1
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Distance between the rings. It can be a unique value (same distance for all the features) or it can be taken from features data (the distance depends on feature values).",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Feature.orientedMinimumBoundingBoxByQGIS": {
    "description": "Calculates the minimum area rotated rectangle for each feature in the input layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      }
    ]
  },
  "Feature.pointOnSurfaceByQGIS": {
    "description": "For each feature of the input layer, returns a point that is guaranteed to lie on the surface of the feature geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "allParts",
        "type": "String",
        "description": "If checked, a point will be created for each part of the geometry.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.poleOfInaccessibilityByQGIS": {
    "description": "Calculates the pole of inaccessibility for a polygon layer, which is the most distant internal point from the boundary of the surface.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "tolerance",
        "type": "Double",
        "description": "Set the tolerance for the calculation",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Feature.rectanglesOvalsDiamondsByQGIS": {
    "description": "Creates a buffer area with a rectangle, oval or diamond shape for each feature of the input point layer",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "rotation",
        "type": "Double",
        "description": "Rotation of the buffer shape.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "shape",
        "type": "String",
        "description": "The shape to use.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "segments",
        "type": "Int",
        "description": "Number of segments for a full circle (Ovals shape).",
        "optional": "True",
        "default": 36
      },
      {
        "name": "width",
        "type": "Double",
        "description": "Width of the buffer shape.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "height",
        "type": "Double",
        "description": "Height of the buffer shape.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Feature.singleSidedBufferByQGIS": {
    "description": "Computes a buffer on lines by a specified distance on one side of the line only.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input line vector layer."
      },
      {
        "name": "side",
        "type": "String",
        "description": "Which side to create the buffer on.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Buffer distance.",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "segments",
        "type": "Int",
        "description": "Controls the number of line segments to use to approximate a quarter circle when creating rounded offsets.",
        "optional": "True",
        "default": 8
      },
      {
        "name": "joinStyle",
        "type": "String",
        "description": "Options are: 0 --- Round 1 --- Miter 2 --- Bevel.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "miterLimit",
        "type": "Double",
        "description": "Sets the maximum distance from the offset geometry to use when creating a mitered join as a factor of the offset distance.",
        "optional": "True",
        "default": 2.0
      }
    ]
  },
  "Feature.taperedBufferByQIS": {
    "description": "Creates tapered buffer along line geometries, using a specified start and end buffer diameter.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input line vector layer."
      },
      {
        "name": "segments",
        "type": "Int",
        "description": "Controls the number of line segments to use to approximate a quarter circle when creating rounded offsets.",
        "optional": "True",
        "default": 16
      },
      {
        "name": "startWidth",
        "type": "Double",
        "description": "Represents the radius of the buffer applied at the start point of the line feature.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "endWidth",
        "type": "Double",
        "description": "Represents the radius of the buffer applied at the end point of the line feature.",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.wedgeBuffersByQIS": {
    "description": "Creates wedge shaped buffers from input points.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "innerRadius",
        "type": "Double",
        "description": "Inner radius value. If 0 the wedge will begin from the source point.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "outerRadius",
        "type": "Double",
        "description": "The outer size (length) of the wedge: the size is meant from the source point to the edge of the wedge shape.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "width",
        "type": "Double",
        "description": "Width (in degrees) of the buffer.",
        "optional": "True",
        "default": 45.0
      },
      {
        "name": "azimuth",
        "type": "Double",
        "description": "Angle (in degrees) as the middle value of the wedge.",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.concaveHullByQIS": {
    "description": "Computes the concave hull of the features in an input point layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "noMultigeometry",
        "type": "String",
        "description": "Check if you want to have singlepart geometries instead of multipart ones.",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "holes",
        "type": "String",
        "description": "Choose whether to allow holes in the final concave hull.",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "alpha",
        "type": "Double",
        "description": "Number from 0 (maximum concave hull) to 1 (convex hull).",
        "optional": "True",
        "default": 0.3
      }
    ]
  },
  "Feature.delaunayTriangulationByQIS": {
    "description": "Creates a polygon layer with the Delaunay triangulation corresponding to the input point layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      }
    ]
  },
  "Feature.voronoiPolygonsByQIS": {
    "description": "Takes a point layer and generates a polygon layer containing the Voronoi polygons corresponding to those input points.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "buffer",
        "type": "Double",
        "description": "The extent of the output layer will be this much bigger than the extent of the input layer.",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Coverage.aspectByGDAL": {
    "description": "Generates an aspect map from any GDAL-supported elevation raster.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      },
      {
        "name": "band",
        "type": "Int",
        "description": "The number of the band to use as elevation.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "trigAngle",
        "type": "String",
        "description": "Activating the trigonometric angle results in different categories: 0° (East), 90° (North), 180° (West), 270° (South).",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "zeroFlat",
        "type": "String",
        "description": "Activating this option will insert a 0-value for the value -9999 on flat areas.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "zevenbergen",
        "type": "String",
        "description": "Activates Zevenbergen&Thorne formula for smooth landscapes.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }

    ]
  },
  "Coverage.contourByGDAL": {
    "description": "Extracts contour lines from any GDAL-supported elevation raster.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster."
      },
      {
        "name": "interval",
        "type": "Double",
        "description": "Defines the interval between the contour lines in the given units of the elevation raster (minimum value 0).",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "ignoreNodata",
        "type": "String",
        "description": "Ignores any nodata values in the dataset.",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options. Refer to the corresponding GDAL utility documentation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "create3D",
        "type": "String",
        "description": "Forces production of 3D vectors instead of 2D. Includes elevation at every vertex.",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "nodata",
        "type": "String",
        "description": "Defines a value that should be inserted for the nodata values in the output raster.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "offset",
        "type": "Double",
        "description": "",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Raster band to create the contours from.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "fieldName",
        "type": "String",
        "description": "Provides a name for the attribute in which to put the elevation.",
        "optional": "True",
        "default": "ELEV"
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL creation options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.contourPolygonByGDAL": {
    "description": "Extracts contour polygons from any GDAL-supported elevation raster.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster."
      },
      {
        "name": "interval",
        "type": "Double",
        "description": "Defines the interval between the contour lines in the given units of the elevation raster (minimum value 0).",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "ignoreNodata",
        "type": "String",
        "description": "Ignores any nodata values in the dataset.",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options. Refer to the corresponding GDAL utility documentation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "create3D",
        "type": "String",
        "description": "Forces production of 3D vectors instead of 2D. Includes elevation at every vertex.",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "nodata",
        "type": "String",
        "description": "Defines a value that should be inserted for the nodata values in the output raster.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "offset",
        "type": "Double",
        "description": "Defines an offset from the base contour elevation for the first contour.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Raster band to create the contours from.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "fieldNameMax",
        "type": "String",
        "description": "Provides a name for the attribute in which to put the maximum elevation of contour polygon. If not provided no maximum elevation attribute is attached.",
        "optional": "True",
        "default": "ELEV_MAX"
      },
      {
        "name": "fieldNameMin",
        "type": "String",
        "description": "Provides a name for the attribute in which to put the minimum elevation of contour polygon. If not provided no minimum elevation attribute is attached.",
        "optional": "True",
        "default": "ELEV_MIN"
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL creation options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.fillNodataByGDAL": {
    "description": "Fill raster regions with no data values by interpolation from edges.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster layer."
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "The number of pixels to search in all directions to find values to interpolate from.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "iterations",
        "type": "Double",
        "description": "The number of 3x3 filter passes to run (0 or more) to smoothen the results of the interpolation.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "maskLayer",
        "type": "String",
        "description": "A raster layer that defines the areas to fill.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "noMask",
        "type": "String",
        "description": "Activates the user-defined validity mask.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "The band to operate on. Nodata values must be represented by the value 0.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridAverageByGDAL": {
    "description": "The Moving Average is a simple data averaging algorithm.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "minPoints",
        "type": "Double",
        "description": "Minimum number of data points to average. If less amount of points found the grid node considered empty and will be filled with NODATA marker.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Angle of ellipse rotation in degrees. Ellipse rotated counter clockwise.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "AField for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "radius2",
        "type": "Double",
        "description": "The second radius (Y axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "radius1",
        "type": "Double",
        "description": "The first radius (X axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridDataMetricsByGDAL": {
    "description": "Computes some data metrics using the specified window and output grid geometry.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "minPoints",
        "type": "Double",
        "description": "Minimum number of data points to average.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "metric",
        "type": "String",
        "description": "Data metric to use.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Angle of ellipse rotation in degrees. Ellipse rotated counter clockwise.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "Field for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Output data type.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "radius2",
        "type": "Double",
        "description": "The second radius (Y axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "radius1",
        "type": "Double",
        "description": "The first radius (X axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created (colors, block size, file compression...).",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridInverseDistanceByGDAL": {
    "description": "The Inverse Distance to a Power gridding method is a weighted average interpolator.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "power",
        "type": "Double",
        "description": "Weighting power.",
        "optional": "True",
        "default": 2.0
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Angle of ellipse rotation in degrees. Ellipse rotated counter clockwise.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "radius2",
        "type": "Double",
        "description": "The second radius (Y axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "radius1",
        "type": "Double",
        "description": "The first radius (X axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "smoothing",
        "type": "Double",
        "description": "Smoothing parameter.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "maxPoints",
        "type": "Double",
        "description": "Do not search for more points than this number.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "minPoints",
        "type": "Double",
        "description": "Minimum number of data points to average. If less amount of points found the grid node considered empty and will be filled with NODATA marker.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "Field for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridInverseDistanceNNRByGDAL": {
    "description": "Computes the Inverse Distance to a Power gridding combined to the nearest neighbor method.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "power",
        "type": "Double",
        "description": "Weighting power.",
        "optional": "True",
        "default": 2.0
      },
      {
        "name": "radius",
        "type": "Double",
        "description": "The radius of the search circle.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "smoothing",
        "type": "Double",
        "description": "Smoothing parameter.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "maxPoints",
        "type": "Double",
        "description": "Do not search for more points than this number.",
        "optional": "True",
        "default": 12
      },
      {
        "name": "minPoints",
        "type": "Double",
        "description": "Minimum number of data points to average. If less amount of points found the grid node considered empty and will be filled with NODATA marker.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "Field for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridLinearByGDAL": {
    "description": "The Linear method perform linear interpolation by computing a Delaunay triangulation of the point cloud, finding in which triangle of the triangulation the point is, and by doing linear interpolation from its barycentric coordinates within the triangle.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "radius",
        "type": "Double",
        "description": "In case the point to be interpolated does not fit into a triangle of the Delaunay triangulation, use that maximum distance to search a nearest neighbour, or use nodata otherwise. If set to -1, the search distance is infinite. If set to 0, no data value will be used.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "Field for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridNearestNeighborByGDAL": {
    "description": "The Nearest Neighbor method doesn’t perform any interpolation or smoothing, it just takes the value of nearest point found in grid node search ellipse and returns it as a result.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Angle of ellipse rotation in degrees. Ellipse rotated counter clockwise.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "radius1",
        "type": "Double",
        "description": "The first radius (X axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "radius2",
        "type": "Double",
        "description": "The second radius (Y axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "Field for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.hillShadeByGDAL": {
    "description": "Outputs a raster with a nice shaded relief effect. It’s very useful for visualizing the terrain.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "combined",
        "type": "String",
        "description": "",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Band containing the elevation information.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "altitude",
        "type": "Double",
        "description": "Defines the altitude of the light, in degrees. 90 if the light comes from above the elevation raster, 0 if it is raking light.",
        "optional": "True",
        "default": 45.0
      },
      {
        "name": "zevenbergenThorne",
        "type": "String",
        "description": "Activates Zevenbergen&Thorne formula for smooth landscapes.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "zFactor",
        "type": "Double",
        "description": "The factor exaggerates the height of the output elevation raster.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "multidirectional",
        "type": "String",
        "description": "",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "scale",
        "type": "Double",
        "description": "The ratio of vertical units to horizontal units.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "azimuth",
        "type": "Double",
        "description": "Defines the azimuth of the light shining on the elevation raster in degrees. If it comes from the top of the raster the value is 0, if it comes from the east it is 90 a.s.o.",
        "optional": "True",
        "default": 315.0
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.nearBlackByGDAL": {
    "description": "Converts nearly black/white borders to black.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "white",
        "type": "String",
        "description": "Search for nearly white (255) pixels instead of nearly black pixels.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "near",
        "type": "Int",
        "description": "Select how far from black, white or custom colors the pixel values can be and still considered near black, white or custom color.",
        "optional": "True",
        "default": 15
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.proximityByGDAL": {
    "description": "Generates a raster proximity map indicating the distance from the center of each pixel to the center of the nearest pixel identified as a target pixel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "Specify the nodata value to use for the output raster.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "values",
        "type": "String",
        "description": "A list of target pixel values in the source image to be considered target pixels.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Band containing the elevation information.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "maxDistance",
        "type": "Double",
        "description": "The maximum distance to be generated.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "replace",
        "type": "Double",
        "description": "Specify a value to be applied to all pixels that are closer than the maximum distance from target pixels (including the target pixels) instead of a distance value.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "units",
        "type": "String",
        "description": "Indicate whether distances generated should be in pixel or georeferenced coordinates.",
        "optional": "True",
        "default": "1"
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.roughnessByGDAL": {
    "description": "Outputs a single-band raster with values computed from the elevation.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Band containing the elevation information.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.slopeByGDAL": {
    "description": "Generates a slope map from any GDAL-supported elevation raster.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Band containing the elevation information.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "asPercent",
        "type": "String",
        "description": "Express slope as percent instead of degrees.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Additional GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "scale",
        "type": "Double",
        "description": "The ratio of vertical units to horizontal units.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "zevenbergen",
        "type": "String",
        "description": "Activates Zevenbergen&Thorne formula for smooth landscapes",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL command line options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.tpiTopographicPositionIndexByGDAL": {
    "description": "Outputs a single-band raster with values computed from the elevation. TPI stands for Topographic Position Index, which is defined as the difference between a central pixel and the mean of its surrounding cells.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "The number of the band to use for elevation values",
        "optional": "True",
        "default": 1
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL command line options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.triTerrainRuggednessIndexByGDAL": {
    "description": "Outputs a single-band raster with values computed from the elevation. TRI stands for Terrain Ruggedness Index, which is defined as the mean difference between a central pixel and its surrounding cells.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "The number of the band to use for elevation values",
        "optional": "True",
        "default": 1
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created (colors, block size, file compression...).",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.clipRasterByExtentByGDAL": {
    "description": "Clips any GDAL-supported raster file to a given extent.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster."
      },
      {
        "name": "projwin",
        "type": "String",
        "description": "",
        "optional": "True",
        "default": ""
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "Defines a value that should be inserted for the nodata values in the output raster.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the format of the output raster file.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.clipRasterByMaskLayerByGDAL": {
    "description": "Clips any GDAL-supported raster by a vector mask layer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "cropToCutLine",
        "type": "String",
        "description": "Applies the vector layer extent to the output raster if checked.",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "targetExtent",
        "type": "String",
        "description": "Extent of the output file to be created.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "setResolution",
        "type": "String",
        "description": "Shall the output resolution (cell size) be specified.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "targetCrs",
        "type": "String",
        "description": "Set the coordinate reference to use for the mask layer.",
        "optional": "True",
        "default": ""

      },
      {
        "name": "xResolution",
        "type": "Double",
        "description": "The width of the cells in the output raster."
      },
      {
        "name": "keepResolution",
        "type": "String",
        "description": "The resolution of the output raster will not be changed.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "alphaBand",
        "type": "String",
        "description": "Creates an alpha band for the result. The alpha band then includes the transparency values of the pixels.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "mask",
        "type": "String",
        "description": "Vector mask for clipping the raster.",
        "optional": "True",
        "default":""
      },
      {
        "name": "multithreading",
        "type": "String",
        "description": "Two threads will be used to process chunks of image and perform input/output operation simultaneously. Note that computation is not multithreaded itself.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "Defines a value that should be inserted for the nodata values in the output raster."
      },
      {
        "name": "yResolution",
        "type": "Double",
        "description": "The height of the cells in the output raster."
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the format of the output raster file.",
        "optional": "True",
        "default": "0"

      },
      {
        "name": "sourceCrs",
        "type": "String",
        "description": "Set the coordinate reference to use for the input raster.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.polygonizeByGDAL": {
    "description": "Creates vector polygons for all connected regions of pixels in the raster sharing a common pixel value. Each polygon is created with an attribute indicating the pixel value of that polygon.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster layer"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options",
        "optional": "True",
        "default": ""
      },
      {
        "name": "field",
        "type": "String",
        "description": "Specify the field name for the attributes of the connected regions.",
        "optional": "True",
        "default": "DN"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "If the raster is multiband, choose the band you want to use",
        "optional": "True",
        "default": 1
      },
      {
        "name": "eightConnectedness",
        "type": "String",
        "description": "If not set, raster cells must have a common border to be considered connected (4-connected). If set, touching raster cells are also considered connected (8-connected).",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Feature.rasterizeOverByGDAL": {
    "description": "Overwrites a raster layer with values from a vector layer. New values are assigned based on the attribute value of the overlapping vector feature.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "inputRaster",
        "type": "Coverage",
        "description": "Input raster layer"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options",
        "optional": "True",
        "default": ""
      },
      {
        "name": "field",
        "type": "String",
        "description": "Defines the attribute field to use to set the pixels values",
        "optional": "True",
        "default": ""
      },
      {
        "name": "add",
        "type": "String",
        "description": "If False, pixels are assigned the selected field’s value. If True, the selected field’s value is added to the value of the input raster layer.",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Feature.rasterizeOverFixedValueByGDAL": {
    "description": "Overwrites parts of a raster layer with a fixed value. The pixels to overwrite are chosen based on the supplied (overlapping) vector layer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "inputRaster",
        "type": "Coverage",
        "description": "Input raster layer"
      },
      {
        "name": "burn",
        "type": "Double",
        "description": "The value to burn",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options",
        "optional": "True",
        "default": ""
      },
      {
        "name": "add",
        "type": "String",
        "description": "If False, pixels are assigned the selected field’s value. If True, the selected field’s value is added to the value of the input raster layer.",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Coverage.rgbToPctByGDAL": {
    "description": "Converts a 24 bit RGB image into a 8 bit paletted.Computes an optimal pseudo-color table for the given RGB-image using a median cut algorithm on a downsampled RGB histogram.Then it converts the image into a pseudo-colored image using the color table.This conversion utilizes Floyd-Steinberg dithering (error diffusion) to maximize output image visual quality.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input (RGB) raster layer"
      },
      {
        "name": "ncolors",
        "type": "Double",
        "description": "The number of colors the resulting image will contain. A value from 2-256 is possible.",
        "optional": "True",
        "default": 2
      }
    ]
  },
  "Coverage.translateByGDAL": {
    "description": "Converts raster data between different formats.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster layer"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Additional GDAL command line options",
        "optional": "True",
        "default": ""
      },
      {
        "name": "targetCrs",
        "type": "String",
        "description": "Specify a projection for the output file",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "Defines the value to use for nodata in the output raster",
        "optional": "True",
        "default": 0
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "copySubdatasets",
        "type": "String",
        "description": "Create individual files for subdatasets",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.warpByGDAL": {
    "description": "Reprojects a raster layer into another Coordinate Reference System (CRS). The output file resolution and the resampling method can be chosen.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster layer to reproject"
      },
      {
        "name": "sourceCrs",
        "type": "String",
        "description": "Defines the CRS of the input raster layer",
        "optional": "True",
        "default": ""
      },
      {
        "name": "targetCrs",
        "type": "String",
        "description": "The CRS of the output layer",
        "optional": "True",
        "default": "EPSG:4326"
      },
      {
        "name": "resampling",
        "type": "String",
        "description": "Pixel value resampling method to use. Options:0 — Nearest neighbour 1 — Bilinear 2 — Cubic 3 — Cubic spline 4 — Lanczos windowed sinc 5 — Average 6 — Mode 7 — Maximum 8 — Minimum 9 — Median 10 — First quartile 11 — Third quartile",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "noData",
        "type": "Double",
        "description": "Sets nodata value for output bands. If not provided, then nodata values will be copied from the source dataset.",
        "optional": "True",
        "default": "not set"
      },
      {
        "name": "targetResolution",
        "type": "Double",
        "description": "Defines the output file resolution of reprojection result",
        "optional": "True",
        "default": "not set"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the format of the output raster file.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "targetExtent",
        "type": "String",
        "description": "Sets the georeferenced extent of the output file to be created",
        "optional": "True",
        "default": ""
      },
      {
        "name": "targetExtentCrs",
        "type": "String",
        "description": "Specifies the CRS in which to interpret the coordinates given for the extent of the output file. This must not be confused with the target CRS of the output dataset. It is instead a convenience e.g. when knowing the output coordinates in a geodetic long/lat CRS, but wanting a result in a projected coordinate system.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "multiThreading",
        "type": "String",
        "description": "Two threads will be used to process chunks of the image and perform input/output operations simultaneously. Note that the computation itself is not multithreaded.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.assignProjectionByGDAL": {
    "description": "Clips any OGR-supported vector file to a given extent.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The input vector file"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "The projection (CRS) of the output layer.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.dissolveByGDAL": {
    "description": "Dissolve (combine) geometries that have the same value for a given attribute / field. The output geometries are multipart.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The input layer to dissolve"
      },
      {
        "name": "explodeCollections",
        "type": "String",
        "description": "Produce one feature for each geometry in any kind of geometry collection in the source file",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "field",
        "type": "String",
        "description": "The field of the input layer to use for dissolving",
        "optional": "True",
        "default": ""
      },
      {
        "name": "computeArea",
        "type": "String",
        "description": "Compute the area and perimeter of dissolved features and include them in the output layer",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "keepAttributes",
        "type": "String",
        "description": "Keep all attributes from the input layer",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "computeStatistics",
        "type": "String",
        "description": "Calculate statistics (min, max, sum and mean) for the numeric attribute specified and include them in the output layer",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "countFeatures",
        "type": "String",
        "description": "Count the dissolved features and include it in the output layer.",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "statisticsAttribute",
        "type": "String",
        "description": "The numeric attribute to calculate statistics on",
        "optional": "True",
        "default": ""
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL creation options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "geometry",
        "type": "String",
        "description": "The name of the input layer geometry column to use for dissolving.",
        "optional": "True",
        "default": "geometry"
      }
    ]
  },
  "Feature.clipVectorByExtentByGDAL": {
    "description": "Clips any OGR-supported vector file to a given extent.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The input vector file"
      },
      {
        "name": "extent",
        "type": "String",
        "description": "Defines the bounding box that should be used for the output vector file. It has to be defined in target CRS coordinates.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.clipVectorByPolygonByGDAL": {
    "description": "Clips any OGR-supported vector layer by a mask polygon layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The input vector file"
      },
      {
        "name": "mask",
        "type": "String",
        "description": "Layer to be used as clipping extent for the input vector layer.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL creation options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.offsetCurveByGDAL": {
    "description": "Offsets lines by a specified distance. Positive distances will offset lines to the left, and negative distances will offset them to the right.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "The offset distance",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "geometry",
        "type": "String",
        "description": "The name of the input layer geometry column to use",
        "optional": "True",
        "default": "geometry"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the vector layer to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.pointsAlongLinesByGDAL": {
    "description": "Offsets lines by a specified distance. Positive distances will offset lines to the left, and negative distances will offset them to the right.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "The distance from the start of the line",
        "optional": "True",
        "default": 0.5
      },
      {
        "name": "geometry",
        "type": "String",
        "description": "The name of the input layer geometry column to use",
        "optional": "True",
        "default": "geometry"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the vector layer to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.bufferVectorsByGDAL": {
    "description": "Offsets lines by a specified distance. Positive distances will offset lines to the left, and negative distances will offset them to the right.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "The distance",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "explodeCollections",
        "type": "String",
        "description": "",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "field",
        "type": "String",
        "description": "Field to use for dissolving",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dissolve",
        "type": "String",
        "description": "If set, the result is dissolved. If no field is set for dissolving",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "geometry",
        "type": "String",
        "description": "The name of the input layer geometry column to use",
        "optional": "True",
        "default": "geometry"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the vector layer to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.oneSideBufferByGDAL": {
    "description": "Offsets lines by a specified distance. Positive distances will offset lines to the left, and negative distances will offset them to the right.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "The distance",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "explodeCollections",
        "type": "String",
        "description": "",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "field",
        "type": "String",
        "description": "Field to use for dissolving",
        "optional": "True",
        "default": ""
      },
      {
        "name": "bufferSide",
        "type": "String",
        "description": "0: Right, 1: Left",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "dissolve",
        "type": "String",
        "description": "If set, the result is dissolved. If no field is set for dissolving",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "geometry",
        "type": "String",
        "description": "The name of the input layer geometry column to use",
        "optional": "True",
        "default": "geometry"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the vector layer to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.neighborsByGrass": {
    "description": "Makes each cell category value a function of the category values assigned to the cells around it,and stores new cell values in an output raster map layers.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "size",
        "type": "String",
        "description": "Neighborhood size",
        "optional": "True",
        "default": "3"
      },
      {
        "name": "method",
        "type": "String",
        "description": "Neighborhood operation    Options: average, median, mode, minimum , maximum, range, stddev, sum, count variance,diversity, nterspersion,quart1,quart3,perc90,quantile",
        "optional": "True",
        "default": "average"
      }
    ]
  },

  "Coverage.bufferByGrass": {
    "description": "Creates a raster map showing buffer zones surrounding cells that contain non-NULL category values.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map."
      },
      {
        "name": "distances",
        "type": "String",
        "description": "Distance zone(s)"
      },
      {
        "name": "unit",
        "type": "String",
        "description": "Units of distance    Options: meters, kilometers, feet,miles, nautmiles",
        "optional": "True",
        "default": "meters"
      }
    ]
  },
  "Coverage.crossByGrass": {
    "description": "Creates a cross product of the category values from multiple raster map layers.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "Names of 2-30 input raster maps"
      }
    ]
  },
  "Coverage.patchByGrass": {
    "description": "Creates a composite raster map layer by using known category values from one(or more) map layer(s) to fill in areas of 'no data' in another map layer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "Name of raster maps to be patched together"
      }
    ]
  },
  "Coverage.latlongByGrass": {
    "description": "Creates a latitude/longitude raster map.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description":"Name of input raster map"
      }
    ]
  },
  "Coverage.blendByGrass": {
    "description": "Blends color components of two raster maps by a given ratio.",
    "returns": "Coverage",
    "args": [
      {
        "name": "first",
        "type": "Coverage",
        "description":"Name of first raster map for blending"
      },
      {
        "name": "second",
        "type": "Coverage",
        "description":"Name of second raster map for blending"
      },
      {
        "name": "percent",
        "type": "String",
        "description": "Percentage weight of first map for color blending   Options: 0-100",
        "optional": "True",
        "default": "50"
      }
    ]
  },
  "Coverage.compositeByGrass": {
    "description": "Combines red, green and blue raster maps into a single composite raster map.",
    "returns": "Coverage",
    "args": [
      {
        "name": "red",
        "type": "Coverage",
        "description":"Name of raster map to be used for <red>"
      },
      {
        "name": "green",
        "type": "Coverage",
        "description":"Name of raster map to be used for <green>"
      },
      {
        "name": "blue",
        "type": "Coverage",
        "description":"Name of raster map to be used for <blue>"
      },
      {
        "name": "levels",
        "type": "String",
        "description": "Number of levels to be used for each component        Options: 1-256",
        "optional": "True",
        "default": "32"
      }
    ]
  },
  "Coverage.sunmaskByGrass": {
    "description": "Calculates cast shadow areas from sun position and elevation raster map.",
    "returns": "Coverage",
    "args": [
      {
        "name": "elevation",
        "type": "Coverage",
        "description": "Name of input elevation raster map"
      },
      {
        "name": "year",
        "type": "String",
        "description": "Year (B)    Options: 1950-2050"
      },
      {
        "name": "month",
        "type": "String",
        "description": "Month (B)    Options:0-12"
      },
      {
        "name": "day",
        "type": "String",
        "description": "Day (B)    Options:0-31"
      },
      {
        "name": "hour",
        "type": "String",
        "description": "Hour (B)    Options:0-24"
      },
      {
        "name": "minute",
        "type": "String",
        "description": "Minute (B)    Options:0-60"
      },
      {
        "name": "second",
        "type": "String",
        "description": "Second (B)    Options:0-60",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "timezone",
        "type": "String",
        "description": "East positive, offset from GMT, also use to adjust daylight savings"
      }
    ]
  },
  "Coverage.surfIdwByGrass": {
    "description": "Provides surface interpolation from raster point data by Inverse Distance Squared Weighting.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description":"Name of input raster map"
      },
      {
        "name": "npoints",
        "type": "String",
        "description": "Number of interpolation points",
        "optional": "True",
        "default": "12"
      }
    ]
  },
  "Coverage.rescaleByGrass": {
    "description": "Rescales the range of category values in a raster map layer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description":"The name of the raster map to be rescaled"
      },
      {
        "name": "to",
        "type": "String",
        "description": "The output data range"
      }
    ]
  },
  "Coverage.surfAreaByGrass": {
    "description": "Prints estimation of surface area for raster map.",
    "returns": "String",
    "args": [
      {
        "name": "map",
        "type": "Coverage",
        "description":"Name of input raster map"
      },
      {
        "name": "vscale",
        "type": "String",
        "description": "Vertical scale",
        "optional": "True",
        "default": "1.0"
      }
    ]
  },
  "Coverage.statsByGrass": {
    "description": "Generates area statistics for raster map.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description":"Name of raster map to report on"
      },
      {
        "name": "flags",
        "type": "String",
        "description": "select statistics data [-acpl1gxArnNCi]"
      },
      {
        "name": "separator",
        "type": "String",
        "description": "Field separator Special characters: pipe, comma, space, tab, newline",
        "optional": "True",
        "default": "space"
      },
      {
        "name": "null_value",
        "type": "String",
        "description": "String representing NULL value",
        "optional": "True",
        "default": "*"
      },
      {
        "name": "nsteps",
        "type": "String",
        "description": "Number of floating-point subranges to collect stats from ",
        "optional": "True",
        "default": "255"
      }
    ]
  },
  "Coverage.coinByGrass": {
    "description": "Tabulates the mutual occurrence (coincidence) of categories for two raster map layers.",
    "returns": "String",
    "args": [
      {
        "name": "first",
        "type": "Coverage",
        "description":"Name of first raster map"
      },
      {
        "name": "second",
        "type": "Coverage",
        "description":"Name of second raster map"
      },
      {
        "name": "units",
        "type": "String",
        "description": "Unit of measure c(ells), p(ercent), x(percent of category [column]), y(percent of category [row]), a(cres) h(ectares), k(square kilometers), m(square miles)Options: c,p,x,y,a,h,k,m"
      }
    ]
  },
  "Coverage.volumeByGrass": {
    "description": "Calculates the volume of data 'clumps'.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description":"Name of input raster map representing data that will be summed within clumps"
      },
      {
        "name": "clump",
        "type": "Coverage",
        "description":"Name of input clump raster map"
      }
    ]
  },
  "Coverage.outPNGByGrass": {
    "description": "Export a GRASS raster map as a non-georeferenced PNG image.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description":"Name of input raster map"
      },
      {
        "name": "compression",
        "type": "String",
        "description":"Compression level of PNG file(0= none,1 = fastest, 9 = best)Options: O-9",
        "optional": "True",
        "default": "6"
      }
    ]
  },
  "Kernel.fixed": {
    "description": "Creates a Kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "weights",
        "type": "List<List<Double>>",
        "description": "A 2-D list to use as the weights of the kernel."
      }
    ]
  },
  "Kernel.square": {
    "description": "Generates a square-shaped boolean kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "value",
        "type": "Double",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.prewitt": {
    "description": "Generates a 3x3 Prewitt edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "axis",
        "type": "String",
        "description": "Specify the direction of the convolution kernel,x/y."
      }
    ]
  },
  "Kernel.kirsch": {
    "description": "Generates a 3x3 kirsch edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.sobel": {
    "description": "Generates a 3x3 sobel edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "axis",
        "type": "String",
        "description": "Specify the direction of the convolution kernel,x/y."
      }
    ]
  },
  "Kernel.roberts": {
    "description": "Generates a 2x2 robert edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.rotate": {
    "description": "Rotate the kernel according to the rotations.",
    "returns": "Kernel",
    "args": [
      {
        "name": "kernel",
        "type": "Kernel",
        "description": "The kernel to be rotated."
      },
      {
        "name": "rotations",
        "type": "Int",
        "description": "Rotations to make (negative numbers rotate counterclockwise)."
      }
    ]

  },
  "Kernel.chebyshev": {
    "description": "Generates a distance kernel based on Chebyshev distance (greatest distance along any dimension).",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.circle": {
    "description": "Generates a circle-shaped boolean kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.compass": {
    "description": "Generates a 3x3 Prewitt's Compass edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.diamond": {
    "description": "Generates a diamond-shaped boolean kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.euclidean": {
    "description": "Generates a distance kernel based on Euclidean (straight-line) distance.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.gaussian": {
    "description": "Generates a Gaussian kernel from a sampled continuous Gaussian.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "sigma",
        "type": "Float",
        "description": "Standard deviation of the Gaussian function (same units as radius)."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.manhattan": {
    "description": "Generates a distance kernel based on rectilinear (city-block) distance.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.octagon": {
    "description": "Generates an octagon-shaped boolean kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.plus": {
    "description": "Generates a rectangular-shaped kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.rectangle": {
    "description": "Generates a plus-shaped boolean kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "xradius",
        "type": "Int",
        "description": "The horizontal radius of the kernel to generate."
      },
      {
        "name": "yradius",
        "type": "Int",
        "description": "The vertical radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.laplacian4": {
    "description": "Generates a 3x3 laplacian-4 edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      }
    ]
  },
  "Kernel.laplacian8": {
    "description": "Generates a 3x3 laplacian-8 edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      }
    ]
  },
  "Kernel.add": {
    "description": "Adds two kernels",
    "returns": "Kernel",
    "args": [
      {
        "name": "kernel1",
        "type": "Kernel",
        "description": "The first kernel."
      },
      {
        "name": "kernel2",
        "type": "Kernel",
        "description": "The second kernel."
      }
    ]
  },
  "Kernel.inverse": {
    "description": "Returns a kernel which has each of its weights multiplicatively inverted. Weights with a value of zero are not inverted and remain zero.",
    "returns": "Kernel",
    "args": [
      {
        "name": "kernel1",
        "type": "Kernel",
        "description": "The first kernel."
      }
    ]
  },
  "Coverage.bandTypes": {
    "description": " Returns a map of the coverage's band types.",
    "returns": "Map",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage from which the left operand bands are taken."
      }
    ]
  },
  "Coverage.rename": {
    "description": "Rename the bands of a coverage.Returns the renamed coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "name",
        "type": "List<String>",
        "description": "The new names for the bands. Must match the number of bands in the Image."
      }
    ]
  },
  "Coverage.abs": {
    "description": "Computes the absolute value of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image to which the operation is applied."
      }
    ]
  },
  "Coverage.acos": {
    "description": "Computes the arc cosine in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.cos": {
    "description": "Computes the cosine in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.cosh": {
    "description": "Computes the hyperbolic cosine of the input in radians.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.asin": {
    "description": "Computes the arc sine in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.sin": {
    "description": "Computes the sine in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.sinh": {
    "description": "Computes the hyperbolic sine of the input in radians.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.atan": {
    "description": "Computes the arc tangent in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.tan": {
    "description": "Computes the tangent in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.tanh": {
    "description": "Computes the hyperbolic tangent in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.atan2": {
    "description": "Calculates the angle formed by the 2D vector [x, y] for each matched pair of bands in image1 and image2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "Second coverage for operation."
      }
    ]
  },
  "Coverage.neq": {
    "description": "Returns 1 iff the first value is not equal to the second for each matched pair of bands in image1 and image2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.addBands": {
    "description": "Returns an coverage containing all bands copied from the first input and selected bands from the second input,optionally overwriting bands in the first coverage with the same name.",
    "returns": "Coverage",
    "args": [
      {
        "name": "dstCoverage",
        "type": "Coverage",
        "description": "first coverage."
      },
      {
        "name": "srcCoverage",
        "type": "Coverage",
        "description": "second coverage."
      },
      {
        "name": "names",
        "type": "List<String>",
        "description": "the name of selected bands in srcCoverage"
      },
      {
        "name": "overwrite",
        "type": "Boolean",
        "description": "if true, overwrite bands in the first coverage with the same name. Otherwise the bands in the first coverage will be kept."
      }
    ]
  },
  "Coverage.signum": {
    "description": "Computes the signum function (sign) of the input; zero if the input is zero, 1 if the input is greater than zero, -1 if the input is less than zero.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image to which the operation is applied."
      }
    ]
  },
  "Coverage.pow": {
    "description": "Raises the first value to the power of the second for each matched pair of bands in image1 and image2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.mini": {
    "description": "Selects the minimum of the first and second values for each matched pair of bands in image1 and image2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.maxi": {
    "description": "Selects the maximum of the first and second values for each matched pair of bands in image1 and image2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.polynomial": {
    "description": "Compute a polynomial at each pixel using the given coefficients.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The input coverage."
      },
      {
        "name": "l",
        "type": "List<Double>",
        "description": "The polynomial coefficients in increasing order of degree starting with the constant term."
      }
    ]
  },
  "Coverage.log": {
    "description": "Computes the natural logarithm of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      }
    ]
  },
  "Coverage.log10": {
    "description": "Computes the base-10 logarithm of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      }
    ]
  },
  "Coverage.mask": {
    "description": "Generate a coverage with the values from the first coverage, but only include cells in which the corresponding cell in the second coverage *are not* set to the \"readMask\" value. Otherwise, the value of the cell will be set to the \"writeMask\".\n Both coverages are required to have the same number of bands, or the coverage2 must have 1 bands. If the coverage2 has a band count of 1, the mask is applied to each band of coverage1.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The input image"
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The mask image."
      },
      {
        "name": "readMask",
        "type": "Int",
        "description": "The number to be masked in the Mask."
      },
      {
        "name": "writeMask",
        "type": "Int",
        "description": "The number will be set if the values from coverage2 is equal to readMask."
      }
    ]
  },
  "Coverage.convolve": {
    "description": "Convolve each band of a image with the given kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to convolve."
      },
      {
        "name": "kernel",
        "type": "Kernel",
        "description": "The kernel to convolve with."
      }
    ]
  },
  "Coverage.focalMean": {
    "description": "Applies a morphological mean filter to each band of an image using a named or custom kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "kernelType",
        "type": "String",
        "description": "The type of kernel to use."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to use."
      }
    ]
  },
  "Coverage.focalMedian": {
    "description": "Applies a morphological median filter to each band of an image using a named or custom kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "kernelType",
        "type": "String",
        "description": "The type of kernel to use."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to use."
      }
    ]
  },
  "Coverage.focalMode": {
    "description": "Applies a morphological mode filter to each band of an coverage using a named or custom kernel. Mode does not currently support Double raster data. If you use a raster with a Double CellType, the raster will be rounded to integers.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "kernelType",
        "type": "String",
        "description": "The type of kernel to use."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to use."
      }
    ]
  },
  "Coverage.focalMax": {
    "description": "Applies a morphological max filter to each band of an image using a named or custom kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "kernelType",
        "type": "String",
        "description": "The type of kernel to use."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to use."
      }
    ]
  },
  "Coverage.focalMin": {
    "description": "Applies a morphological min filter to each band of an image using a named or custom kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "kernelType",
        "type": "String",
        "description": "The type of kernel to use."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to use."
      }
    ]
  },
  "Coverage.slice": {
    "description": "Selects a contiguous group of bands from a coverage by position.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage from which to select bands."
      },
      {
        "name": "start",
        "type": "Int",
        "description": "Where to start the selection."
      },
      {
        "name": "end",
        "type": "Int",
        "description": "Where to end the selection."
      }
    ]
  },
  "Coverage.histogram": {
    "description": "Return the histogram of the image, a map of bin label value and its associated count.",
    "returns": "Map[Int,Long]",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to compute the histogram."
      }
    ]
  },
  "Coverage.projection": {
    "description": "Returns the projection of an Image.",
    "returns": "String",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to get the projection."
      }
    ]
  },
  "Coverage.reproject": {
    "description": "Force a coverage to be computed in a given projection",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to reproject."
      },
      {
        "name": "crsCode",
        "type": "Int",
        "description": "The code of new projection."
      },
      {
        "name": "resolution",
        "type": "Int",
        "description": "The resolution of reprojected image."
      }
    ]
  },
  "Coverage.resample": {
    "description": "Resample the image",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to resample."
      },
      {
        "name": "level",
        "type": "Int",
        "description": "The resampling level. eg:1 for up-sampling and -1 for down-sampling."
      },
      {
        "name": "mode",
        "type": "String",
        "description": "The interpolation mode to use"
      }
    ]
  },
  "Coverage.remap": {
    "description": "Maps from input values to output values, represented by two parallel lists. Any input values not included in the input list are either set to defaultValue if it is given, or masked if it isn't. Note that inputs containing floating point values might sometimes fail to match due to floating point precision errors.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to remap."
      },
      {
        "name": "from",
        "type": "List[Int]",
        "description": "The key list of the map."
      },
      {
        "name": "to",
        "type": "List[Double]",
        "description": "The value list of the map."
      },
      {
        "name": "defaultValue",
        "type": "Double",
        "default": "None",
        "optional": "True",
        "description": "Any input values not included in the input list are either set to defaultValue if it is given, or masked if it isn't."
      }
    ]
  },
  "Coverage.gradient": {
    "description": "Calculates the gradient.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the gradient."
      }
    ]
  },
  "Coverage.gt": {
    "description": "Returns 1 iff the first value is greater than the second for each matched pair of bands in coverage1 and coverage2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for operation."
      }
    ]
  },
  "Coverage.gte": {
    "description": "Returns 1 iff the first value is equal or greater to the second for each matched pair of bands in coverage1 and coverage2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for operation."
      }
    ]
  },
  "Coverage.lt": {
    "description": "Returns 1 iff the first value is less than the second for each matched pair of bands in coverage1 and coverage2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for operation."
      }
    ]
  },
  "Coverage.lte": {
    "description": "Returns 1 iff the first value is equal or less to the second for each matched pair of bands in coverage1 and coverage2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for operation."
      }
    ]
  },
  "Coverage.clip": {
    "description": "Clip the raster with the geometry.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to clip."
      },
      {
        "name": "geom",
        "type": "Geometry",
        "description": "The geometry used to clip."
      }
    ]
  },
  "Coverage.clamp": {
    "description": "Clamp the raster between low and high.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to clamp."
      },
      {
        "name": "low",
        "type": "Int",
        "description": "The low value."
      },
      {
        "name": "high",
        "type": "Int",
        "description": "The high value."
      }
    ]
  },
  "Coverage.rgbToHsv": {
    "description": "Transforms the coverage from the RGB color space to the HSV color space.Expects a 3 band coverage in the range [0, 255], and produces three bands: hue, saturation and value with values in the range [0, 1].",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "he coverage with three bands: R, G, B."
      }
    ]
  },
  "Coverage.hsvToRgb": {
    "description": "Transforms the coverage from the HSV color space to the RGB color space.Expects a 3 band coverage with hue, saturation and value in the ranges [0, 1], and produces three bands: R, G, B with values in the range [0, 255].",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage with three bands: H, S, V."
      }
    ]
  },
  "Coverage.entropy": {
    "description": "Computes the windowed entropy using the specified kernel centered on each input pixel. Entropy is computed as -sum(p * log2(p)), where p is the normalized probability of occurrence of the values encountered in each window.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the entropy."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the entropy, 1 for a 3×3 square."
      }
    ]
  },
  "Coverage.eq": {
    "description": "Returns 1 iff the first value is equal to the second for each matched pair of bands in coverage1 and coverage2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for operation."
      }
    ]
  },
  "Coverage.floor": {
    "description": "Computes the largest integer less than or equal to the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage1",
        "description": "Computes the largest integer less than or equal to the input."
      }
    ]
  },
  "Coverage.NDVI": {
    "description": "Calculation of image normalized vegetation index NDVI.",
    "returns": "Coverage",
    "args": [
      {
        "name": "NIR",
        "type": "Coverage",
        "description": "The Near-Infrared band."
      },
      {
        "name": "Red",
        "type": "Coverage",
        "description": "The Red band."
      }
    ]
  },
  "Coverage.cbrt": {
    "description": "Computes the cubic root of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image to which the operation is applied."
      }
    ]
  },
  "Coverage.sqrt": {
    "description": "Computes the square root of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image to which the operation is applied."
      }
    ]
  },
  "Coverage.ceil": {
    "description": "Computes the smallest integer greater than or equal to the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      }
    ]
  },
  "Coverage.round": {
    "description": "Computes the integer nearest to the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      }
    ]
  },
  "Coverage.metadata": {
    "description": "Return the metadata of the input coverage.",
    "returns": "String",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image to get the metadata"
      }
    ]
  },
  "Coverage.toInt8": {
    "description": "Casts the input value to a signed 8-bit integer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toUint8": {
    "description": "Casts the input value to a unsigned 8-bit integer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toInt16": {
    "description": "Casts the input value to a signed 16-bit integer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toUint16": {
    "description": "Casts the input value to a unsigned 16-bit integer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toInt32": {
    "description": "Casts the input value to a signed 32-bit integer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toFloat": {
    "description": "Casts the input value to a 32-bit float.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toDouble": {
    "description": "Casts the input value to a 64-bit float.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Terrain.slope": {
    "description": "Calculates slope in degrees from a terrain DEM.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the slope."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the slope, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct slope calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Terrain.aspect": {
    "description": "Calculates aspect in degrees from a terrain DEM.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the aspect."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the aspect, 1 for a 3×3 square."
      }
    ]
  },
  "CoverageCollection.mosaic": {
    "description": "mosaic the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.mean": {
    "description": "mean the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.min": {
    "description": "min the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.max": {
    "description": "max the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.sum": {
    "description": "sum the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.or": {
    "description": "or the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.and": {
    "description": "and the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.median": {
    "description": "median the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.mode": {
    "description": "mode the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "Coverage.addStyles": {
    "description": "Add the styles to the coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to be added styles"
      },
      {
        "name": "bands",
        "type": "List<String>",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "",
        "default": "png",
        "optional": "True"
      }
    ]
  },
  "Coverage.export": {
    "description": "Export a coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to be exported"
      },
      {
        "name": "description",
        "type": "String",
        "description": "The description of the Coverage",
        "optional": "True"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "The crs of the exported Coverage",
        "optional": "True"
      },
      {
        "name": "scale",
        "type": "Double",
        "description": "The scale of the exported Coverage",
        "optional": "True"
      },
      {
        "name": "folder",
        "type": "String",
        "description": "The folder path of the exported Coverage",
        "optional": "True"
      },
      {
        "name": "fileName",
        "type": "String",
        "description": "The file name of the exported Coverage",
        "optional": "True"
      },
      {
        "name": "fileFormat",
        "type": "String",
        "description": "The format of the exported Coverage",
        "optional": "True"
      }
    ]
  },
  "Cube.addStyles": {
    "description": "Add the styles to the coverage.",
    "returns": "Cube",
    "args": [
      {
        "name": "cube",
        "type": "Cube",
        "description": "The cube to visualize"
      },
      {
        "name": "products",
        "type": "Object",
        "description": "The products in cube to visualize"
      },
      {
        "name": "bands",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "png",
        "default": "False",
        "optional": "True"
      }
    ]
  },
  "CoverageCollection.addStyles": {
    "description": "Add the styles to the coverage collection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage collection to be added styles"
      },
      {
        "name": "bands",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "png",
        "default": "False",
        "optional": "True"
      },
      {
        "name": "method",
        "type": "String",
        "description": "",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Feature.point": {
    "description": "create a Point",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "List[Double]",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "键值对，通过:隔开"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.lineString": {
    "description": "create a LineString",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "List[List[Double]]",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "键值对，通过:隔开"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.linearRing": {
    "description": "create a LinearRing",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "List[List[Double]]",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.polygon": {
    "description": "create a Polygon",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "List[List[Double]]",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "键值对，通过:隔开"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.multiPoint": {
    "description": "create a multiPoint",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "List[List[Double]]",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.multiLineString": {
    "description": "create a MultiLineString",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "List[List[List[Double]]]",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.multiPolygon": {
    "description": "create a MultiPoint",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "List[List[List[List[Double]]]]",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.geometry": {
    "description": "create a geometry",
    "returns": "Feature",
    "args": [
      {
        "name": "gjson",
        "type": "String",
        "description": "geojson"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.load": {
    "description": "load data",
    "returns": "Feature",
    "args": [
      {
        "name": "productName",
        "type": "String",
        "description": "productName"
      },
      {
        "name": "dateTime",
        "type": "String",
        "description": "dataTime",
        "default": "null"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS",
        "default": "EPSG:4326"
      }
    ]
  },
  "Feature.featureCollection": {
    "description": "create a featureCollection",
    "returns": "Feature",
    "args": [
      {
        "name": "featureList",
        "type": "List[Feature]",
        "description": "featureList"
      }
    ]
  },
  "Feature.centroid": {
    "description": "compute bounds",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.buffer": {
    "description": "compute buffer",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "distance"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.convexHull": {
    "description": "compute convexHull",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.coordinates": {
    "description": "compute coordinates",
    "returns": "List[Array[Coordinate]]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.reproject": {
    "description": "reproject",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "tarCrsCode",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.isUnbounded": {
    "description": "judge a geometry is unbounded",
    "returns": "List[Boolean]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.getType": {
    "description": "Returns the GeoJSON type of the geometry",
    "returns": "List[String]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.projection": {
    "description": "Returns the projection of the geometry.",
    "returns": "List[Int]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.toGeoJSONString": {
    "description": "Returns a GeoJSON string representation of the geometry.",
    "returns": "List[String]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.length": {
    "description": "compute length",
    "returns": "List[Double]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.dissolve": {
    "description": "Computes the union of all the elements of this geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.contains": {
    "description": "Returns true iff one geometry contains the other.",
    "returns": "Boolean",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.containedIn": {
    "description": "Returns true iff one geometry is contained in the other.",
    "returns": "Boolean",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.disjoint": {
    "description": "Returns true iff the geometries are disjoint.",
    "returns": "Boolean",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.distance": {
    "description": "Returns the minimum distance between two geometries.",
    "returns": "Double",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.difference": {
    "description": "Returns the result of subtracting the 'right' geometry from the 'left' geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.intersection": {
    "description": "Returns the intersection of the two geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.intersects": {
    "description": "Returns true iff the geometries intersect.",
    "returns": "Boolean",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.symmetricDifference": {
    "description": "Returns the symmetric difference between two geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.union": {
    "description": "Returns the union of the two geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.withDistance": {
    "description": "Returns true iff the geometries are within a specified distance.",
    "returns": "Boolean",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.copyProperties": {
    "description": "Copies metadata properties from one element to another.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "properties",
        "type": "List[String]",
        "description": "The properties to copy. If omitted, all properties are copied."
      }
    ]
  },
  "Feature.get": {
    "description": "Extract a property from a feature.",
    "returns": "List[Any]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.getNumber": {
    "description": "Extract a property from a feature.",
    "returns": "List[Double]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.getString": {
    "description": "Extract a property from a feature.",
    "returns": "List[String]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.getArray": {
    "description": "Extract a property from a feature.",
    "returns": "List[Array[String]]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.propertyNames": {
    "description": "Returns the names of properties on this element.",
    "returns": "List[List[String]]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.set": {
    "description": "Overrides one or more metadata properties of an Element.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "the property to set. it is a json"
      }
    ]
  },
  "Feature.setGeometry": {
    "description": "Returns the feature, with the geometry replaced by the specified geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "geom",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.inverseDistanceWeighted": {
    "description": "InverseDistanceWeighted Interpolation",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "propertyName",
        "type": "String",
        "description": "the property to select"
      },
      {
        "name": "maskGeom",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.area": {
    "description": "compute area",
    "returns": "List[Double]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.bounds": {
    "description": "compute area",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "Coordinates"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.addStyles": {
    "description": "Add the styles to the feature.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The coverage collection to be added styles"
      },
      {
        "name": "color",
        "type": "String",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "FeatureCollection.addStyles": {
    "description": "Add the styles to the feature collection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection to be added styles"
      },
      {
        "name": "color",
        "type": "String",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "ProcessResult.addStyles": {
    "description": "Add the styles to the result of process.",
    "returns": "ProcessResult",
    "args": [
      {
        "name": "input",
        "type": "ProcessResult",
        "description": "The feature collection to be added styles"
      },
      {
        "name": "args",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "Item.addStyles": {
    "description": "Add the styles to item.",
    "returns": "Item",
    "args": [
      {
        "name": "input",
        "type": "Item",
        "description": "The item to be added styles"
      },
      {
        "name": "args",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "Item.getItemType": {
    "description": "Get type of item.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Item",
        "description": "The feature as the input data "
      }
    ]
  },
  "Filter.equals": {
    "description": "Check if filter equals others",
    "returns": "Filter",
    "args": [
      {
        "name": "leftField",
        "type": "String",
        "description": "Field name"
      },
      {
        "name": "rightValue",
        "type": "Object",
        "description": "value"
      }
    ]
  },
  "Filter.and": {
    "description": "Filter and",
    "returns": "Filter",
    "args": [
      {
        "name": "filters",
        "type": "List<String>",
        "description": "Filters"
      }
    ]
  },
  "Coverage.slope": {
    "description": "Compute the Slope of DEM",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "the input DEM"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "default": "1.0",
        "optional": "True"
      },
      {
        "name": "radius",
        "type": "Double",
        "description": "The radius."
      }
    ]
  },
  "CoverageCollection.slope": {
    "description": "Compute the Slope of DEM",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input DEM"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "default": "1.0",
        "optional": "True"
      }
    ]
  },
  "slope": {
    "description": "Compute the Slope of DEM",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input DEM"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "default": "1.0",
        "optional": "True"
      }
    ]
  },
  "Cube.fusion": {
    "description": "Fusion of two cube",
    "returns": "Cube",
    "args": [
      {
        "name": "leftCube",
        "type": "Cube",
        "description": "the left cube"
      },
      {
        "name": "rightCube",
        "type": "Cube",
        "description": "the other Cube"
      },
      {
        "name": "function",
        "type": "String",
        "description": "the String function to use"
      },
      {
        "name": "param",
        "type": "Object",
        "description": "the param to be added to function",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "newProduct",
        "type": "String",
        "description": "the new product from the process",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Coverage.aspect": {
    "description": "坡向计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius"
      }
    ]
  },
  "CoverageCollection.aspect": {
    "description": "坡向计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius"
      }
    ]
  },
  "Coverage.hillShade": {
    "description": "山体阴影计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      },
      {
        "name": "Azimuth",
        "type": "Float",
        "description": "Set the horizontal angle(in degrees) of the sun(clockwise direction)Range:0 to 360.0",
        "optional": "True",
        "default": "300.0"
      },
      {
        "name": "Vertical_angle",
        "type": "Float",
        "description": "Set the vertical angle(in degrees) of the sun, that is the height of the sun",
        "optional": "True",
        "default": "40.0"
      }
    ]
  },
  "CoverageCollection.hillShade": {
    "description": "山体阴影计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      },
      {
        "name": "Azimuth",
        "type": "Float",
        "description": "Set the horizontal angle(in degrees) of the sun(clockwise direction)Range:0 to 360.0",
        "optional": "True",
        "default": "300.0"
      },
      {
        "name": "Vertical_angle",
        "type": "Float",
        "description": "Set the vertical angle(in degrees) of the sun, that is the height of the sun",
        "optional": "True",
        "default": "40.0"
      }
    ]
  },
  "Coverage.relief": {
    "description": "等值线计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      }
    ]
  },
  "CoverageCollection.relief": {
    "description": "等值线计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      }
    ]
  },
  "Coverage.ruggednessIndex": {
    "description": "粗糙度计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      }
    ]
  },
  "CoverageCollection.ruggednessIndex": {
    "description": "粗糙度计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      }
    ]
  },
  "Coverage.cellBalance": {
    "description": "洼地去除",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "CoverageCollection.cellBalance": {
    "description": "洼地去除",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Coverage.flowAccumulationTD": {
    "description": "流量(Top-Down)计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "CoverageCollection.flowAccumulationTD": {
    "description": "流量(Top-Down)计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Coverage.flowPathLength": {
    "description": "流域长度计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "CoverageCollection.flowPathLength": {
    "description": "流域长度计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Coverage.slopeLength": {
    "description": "坡长计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "CoverageCollection.slopeLength": {
    "description": "坡长计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Coverage.sceneClassification": {
    "description": "场景分类",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Coverage.imageSegmentation": {
    "description": "语义分割",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Algorithm.hargreaves": {
    "description": "水文hargreaves模型",
    "returns": "Table",
    "args": [
      {
        "name": "inputTemperature",
        "type": "Table",
        "description": "温度表格数据"
      },
      {
        "name": "inputStation",
        "type": "FeatureCollection",
        "description": "站点数据"
      },
      {
        "name": "startTime",
        "type": "String",
        "description": "开始时间"
      },
      {
        "name": "endTime",
        "type": "String",
        "description": "结束时间"
      },
      {
        "name": "timeStep",
        "type": "Float",
        "description": "步长"
      }
    ]
  },
  "Algorithm.topmodel": {
    "description": "水文TOPMODEL模型",
    "returns": "Table",
    "args": [
      {
        "name": "rate",
        "type": "Float",
        "description": "rate"
      },
      {
        "name": "recession",
        "type": "Float",
        "description": "recession"
      },
      {
        "name": "tMax",
        "type": "Float",
        "description": "tMax"
      },
      {
        "name": "iterception",
        "type": "Float",
        "description": "iterception"
      },
      {
        "name": "waterShedArea",
        "type": "Float",
        "description": "waterShedArea"
      },
      {
        "name": "startTime",
        "type": "String",
        "description": "开始时间"
      },
      {
        "name": "endTime",
        "type": "String",
        "description": "结束时间"
      },
      {
        "name": "timeStep",
        "type": "Float",
        "description": "步长"
      },
      {
        "name": "inputTopoIndex",
        "type": "Table",
        "description": ""
      },
      {
        "name": "inputPrecipEvapFile",
        "type": "Table",
        "description": ""
      }
    ]
  },
  "Algorithm.swmm": {
    "description": "水文SWMM5模型",
    "returns": "Table",
    "args": [
      {
        "name": "input",
        "type": "Table",
        "description": ""
      }
    ]
  },
  "Algorithm.virtualConstellation": {
    "description": "高分/哨兵2一致性产品生产",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "原始数据"
      },
      {
        "name": "bands",
        "type": "String",
        "description": "所处理的波段"
      }
    ]
  },
  "CoverageCollection.calVegIndex": {
    "description": "计算植被/水体指数",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "输入数据(Modis)"
      },
      {
        "name": "year",
        "type": "String",
        "description": "年份"
      },
      {
        "name": "quarter",
        "type": "String",
        "description": "季度"
      }
    ]
  },
  "CoverageCollection.calCrop": {
    "description": "用矢量裁剪",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "输入数据"
      },
      {
        "name": "feature",
        "type": "Feature",
        "description": "裁剪所用的矢量"
      },
      {
        "name": "year",
        "type": "String",
        "description": "年份"
      },
      {
        "name": "quarter",
        "type": "String",
        "description": "季度"
      },
      {
        "name": "sort",
        "type": "String",
        "description": "类型"
      }
    ]
  },
  "CoverageCollection.calVegCoverage": {
    "description": "计算植被覆盖度",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "输入数据(Modis)"
      },
      {
        "name": "year",
        "type": "String",
        "description": "年份"
      },
      {
        "name": "quarter",
        "type": "String",
        "description": "季度"
      }
    ]
  },
  "CoverageCollection.calNPP": {
    "description": "计算植被生产力",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "输入数据，即植被/水体指数"
      },
      {
        "name": "year",
        "type": "String",
        "description": "年份"
      },
      {
        "name": "quarter",
        "type": "String",
        "description": "季度"
      }
    ]
  },
  "CoverageCollection.calVEI": {
    "description": "计算生态指数",
    "returns": "Coverage",
    "args": [
      {
        "name": "inputFVC",
        "type": "CoverageCollection",
        "description": "输入的FVC产品"
      },
      {
        "name": "inputNPP",
        "type": "CoverageCollection",
        "description": "输入的NPP产品"
      },
      {
        "name": "year",
        "type": "String",
        "description": "年份"
      }
    ]
  },
  "CoverageCollection.fromCoverages": {
    "description": "从coverages列表中构造CoverageCollection",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "coverages",
        "type": "List<Object>",
        "description": "输入的coverages列表"
      }
    ]
  },
  "Service.getTable": {
    "description": "从service中获取表格数据",
    "returns": "Table",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of table product."
      }
    ]
  },
  "Table.getTable": {
    "description": "从加载表格数据",
    "returns": "Table",
    "args": [
      {
        "name": "productID",
        "type": "String",
        "description": "The id of table product."
      }
    ]
  },
  "Table.getDownloadUrl": {
    "description": "获取下载的url",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Table",
        "description": "The table to download."
      },
      {
        "name": "format",
        "type": "String",
        "description": "format of the  table file"
      },
      {
        "name": "name",
        "type": "String",
        "description": "file name of the  table file"
      }
    ]
  },
  "Table.addStyles": {
    "description": "获取下载的url",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Table",
        "description": "The table to download."
      }
    ]
  },
  "Cube.load": {
    "description": "Create a cube by some params",
    "returns": "Cube",
    "args": [
      {
        "name": "productIds",
        "type": "List<String>",
        "description": "The product id list for cube creation."
      },
      {
        "name": "StartTime",
        "type": "String",
        "description": "The start time of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "EndTime",
        "type": "String",
        "description": "The end time of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "geom",
        "type": "List<Float>",
        "description": "The geom of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "bands",
        "type": "List<String>",
        "description": "The bands of the product.",
        "optional": "True",
        "default": "null"
      }
    ]
  },
  "Cube.band": {
    "description": "Select a new cube by band name",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to select bands from."
      },
      {
        "name": "bandName",
        "type": "String",
        "description": "The name of band to be selected"
      }
    ]
  },
  "Cube.visualize": {
    "description": "Produces an RGB or grayscale visualization of an Cube.  Each of the gain, bias, min, max and gamma arguments can take either a single value, which will be applied to all bands, or a list of values the same length as bands.",
    "returns": "Cube",
    "args": [
      {
        "name": "cube",
        "type": "Cube",
        "description": "The cube to visualize"
      },
      {
        "name": "products",
        "type": "Object",
        "description": "The products in cube to visualize"
      },
      {
        "name": "bands",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "png",
        "default": "False",
        "optional": "True"
      }
    ]
  },
  "Cube.NDWI": {
    "description": "Compute NDWI of the Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to compute NDWI."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product in cube to compute NDWI"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of NDWI"
      }
    ]
  },
  "Cube.binarization": {
    "description": "Compute binarization of the Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to compute NDWI."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product to compute binarization."
      },
      {
        "name": "threshold",
        "type": "Int",
        "description": "The threshold to binary"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of binary"
      }
    ]
  },
  "Cube.subtract": {
    "description": "Compute binarization of the Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to compute NDWI."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product to compute binarization."
      },
      {
        "name": "timeList",
        "type": "List<String>",
        "description": "The list of time."
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of binary"
      }
    ]
  },
  "Cube.ChangeDetection": {
    "description": "Get the change area of the target Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to find changed area."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product in cube to detect the change."
      },
      {
        "name": "certainTimes",
        "type": "List<String>",
        "description": "The time range of two images to get change"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of change detection."
      }
    ]
  },
  "Cube.overlayAnalysis": {
    "description": "Overlay analysis between two cube",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to overlay analysis."
      },
      {
        "name": "raster",
        "type": "String",
        "description": "The raster product in cube to overlay"
      },
      {
        "name": "vector",
        "type": "String",
        "description": "The target vector product in cube to overlay"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of overlay analysis."
      }
    ]
  },
  "Cube.conjointAnalysis": {
    "description": "Conjoin analysis between raster cube and tabular data",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to conjoint analysis."
      },
      {
        "name": "vector",
        "type": "String",
        "description": "The vector product in cube to conjoint."
      },
      {
        "name": "tabular",
        "type": "String",
        "description": "The tabular product in cube to conjoint."
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of conjoin analysis."
      }
    ]
  },
  "Coverage.terrSlope": {
    "description": "DEM坡度计算.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the slope."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the slope, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct slope calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrAspect": {
    "description": "DEM坡向计算.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the aspect."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the aspect, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct aspect calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrCurvature": {
    "description": "DEM曲率计算.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the curvature."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the curvature, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct curvature calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrRuggedness": {
    "description": "DEM粗糙度计算.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the ruggedness."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the ruggedness, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct ruggedness calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrSlopelength": {
    "description": "DEM坡长计算.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the slopelength."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "radius for DEM indexing, default is 16"
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct slopelength calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  }
}