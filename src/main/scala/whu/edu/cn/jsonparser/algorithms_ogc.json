{
  "Service.printNumber": {
    "description": "Print the Number or List or String to console.",
    "returns": "Unit",
    "args": [
      {
        "name": "object",
        "type": "Number",
        "description": "The value to print."
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of the value."
      }
    ]
  },
  "Coverage.geoDetector": {
    "description": "Calculate to what extent a certain factor X explains the spatial variation of attribute Y.",
    "returns": "String",
    "args": [
      {
        "name": "depVar_In",
        "type": "Coverage",
        "description": "dependent variable input raster"
      },
      {
        "name": "facVar_name_In",
        "type": "String",
        "description": "Impact factor variable input raster name"
      },
      {
        "name": "facVar_In",
        "type": "Coverage",
        "description": "Impact factor variable input raster"
      },
      {
        "name": "norExtent_sta",
        "type": "Double",
        "description": "Starting value of normal range of dependent variable"
      },
      {
        "name": "norExtent_end",
        "type": "Double",
        "description": "Ending value of normal range of dependent variable"
      },
      {
        "name": "NaN_value",
        "type": "Double",
        "description": "Nan value of dependent variable input raster"
      }
    ]
  },
  "Coverage.reclass": {
    "description": "Reclassify the raster based on specified rules.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "Input raster to reclass"
      },
      {
        "name": "rules",
        "type": "List<(Double,Double,Double)>",
        "description": "rules of reclass"
      },
      {
        "name": "NaN_value",
        "type": "Double",
        "description": "Nan value of input raster"
      }
    ]
  },
  "Coverage.rasterUnion": {
    "description": "use a raster to clip another raster",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "clip raster providing extent"
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "Input raster to clip"
      }
    ]
  },
  "Service.printString": {
    "description": "Print the Number or List or String to console.",
    "returns": "Unit",
    "args": [
      {
        "name": "object",
        "type": "String",
        "description": "The value to print."
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of the value."
      }
    ]
  },
  "Service.printList": {
    "description": "Print the Number or List or String to console.",
    "returns": "Unit",
    "args": [
      {
        "name": "object",
        "type": "List<String>",
        "description": "The value to print."
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of the value."
      }
    ]
  },
  "FeatureCollection.filter": {
    "description": "Applies a filter to a given collection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "collection",
        "type": "FeatureCollection",
        "description": "The collection to filter"
      },
      {
        "name": "filter",
        "type": "Object",
        "description": "The filter to apply to the collection. "
      }
    ]
  },
  "CoverageCollection.filter": {
    "description": "Applies a filter to a given collection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "collection",
        "type": "CoverageCollection",
        "description": "The collection to filter"
      },
      {
        "name": "filter",
        "type": "String",
        "description": "The filter to apply to the collection. "
      }
    ]
  },
  "Filter.gte": {
    "description": "Creates a unary or binary filter that passes unless the left operand is less than the right operand.",
    "returns": "Filter",
    "args": [
      {
        "name": "leftField",
        "type": "String",
        "description": "A selector for the left operand. Should not be specified if leftValue is specified.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "rightValue",
        "type": "Object",
        "description": "The value of the right operand. Should not be specified if rightField is specified.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "rightField",
        "type": "String",
        "description": "A selector for the right operand. Should not be specified if rightValue is specified.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "leftValue",
        "type": "Object",
        "description": "The value of the left operand. Should not be specified if leftField is specified.",
        "optional": "True",
        "default": "None"
      }
    ]
  },
  "Collection.draw": {
    "description": "Paints a vector collection for visualization. Not intended for use as input to other algorithms.",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "collection",
        "type": "FeatureCollection",
        "description": "The collection to draw"
      },
      {
        "name": "color",
        "type": "String",
        "description": "A hex string in the format RRGGBB specifying the color to use for drawing the features."
      },
      {
        "name": "pointRadius",
        "type": "Integer",
        "description": "The radius in pixels of the point markers.",
        "optional": "True",
        "default": "3"
      },
      {
        "name": "strokeWidth",
        "type": "Integer",
        "description": "The width in pixels of lines and polygon borders.",
        "optional": "True",
        "default": "2"
      }
    ]
  },
  "FeatureCollection.map": {
    "description": "Maps an algorithm over a collection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "collection",
        "type": "FeatureCollection",
        "description": "The collection of the elements to which the algorithm is applied."
      },
      {
        "name": "baseAlgorithm",
        "type": "Algorithm",
        "description": "The algorithm being applied to each element"
      },
      {
        "name": "dropNulls",
        "type": "Boolean",
        "description": "If true, the mapped algorithm is allowed to return nulls, and the elements for which it returns nulls will be dropped.",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "CoverageCollection.map": {
    "description": "Maps an algorithm over a collection.",
    "returns": "Collection",
    "args": [
      {
        "name": "collection",
        "type": "Collection",
        "description": "The collection of the elements to which the algorithm is applied."
      },
      {
        "name": "baseAlgorithm",
        "type": "Algorithm",
        "description": "The algorithm being applied to each element"
      }
    ]
  },
  "Service.getCube": {
    "description": "Getting resource Cube of certain Name",
    "returns": "Cube",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "CubeName",
        "type": "String",
        "description": "The Name of target collection."
      },
      {
        "name": "extent",
        "type": "String",
        "description": "The extent used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "dateTime",
        "type": "String",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Service.getCollections": {
    "description": "Getting resource Collections",
    "returns": "Collections",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productIDs",
        "type": "List<String>",
        "description": "The id list of products.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Service.getCollection": {
    "description": "Getting resource Collection of certain id",
    "returns": "Collection",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "collectionId",
        "type": "String",
        "description": "The id of target collection."
      }
    ]
  },
  "Service.getFeatureCollection": {
    "description": "Getting feature collection from resource center",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "filter",
        "type": "Filter",
        "description": "Filter the properties of feature collection",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Service.getFeature": {
    "description": "Getting resource feature of certain id",
    "returns": "Feature",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productId",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "featureId",
        "type": "String",
        "description": "The id of target feature."
      },
      {
        "name": "dataTime",
        "type": "String",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "The crs of feature.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Coverage.export": {
    "description": "",
    "returns": "",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": ""
      }
    ]
  },
  "Service.getCoverageCollection": {
    "description": "Getting resource coverage collection of certain id",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "WGS84",
        "optional": "True"
      },
      {
        "name": "cloudCoverMin",
        "type": "Float",
        "description": "The minimum value of cloud cover.",
        "default": "0",
        "optional": "True"
      },
      {
        "name": "cloudCoverMax",
        "type": "Float",
        "description": "The maximum value of cloud cover.",
        "default": "100",
        "optional": "True"
      }
    ]
  },
  "Service.getCoverageArray": {
    "description": "Getting resource coverageArray of certain id",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of target array."
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "WGS84",
        "optional": "True"
      },
      {
        "name": "cloudCoverMin",
        "type": "Float",
        "description": "The minimum value of cloud cover.",
        "default": "0",
        "optional": "True"
      },
      {
        "name": "cloudCoverMax",
        "type": "Float",
        "description": "The maximum value of cloud cover.",
        "default": "100",
        "optional": "True"
      }
    ]
  },
  "Service.getCoverage": {
    "description": "Getting resource coverage of certain id",
    "returns": "Coverage",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "coverageID",
        "type": "String",
        "description": "The id of target coverage."
      },
      {
        "name": "subset",
        "type": "List<Float>",
        "description": "The subset of target coverage.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "properties",
        "type": "List<String>",
        "description": "Get the bands.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Service.getProcesses": {
    "description": "Getting processes provided by service center",
    "returns": "Processes",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      }
    ]
  },
  "Service.getProcess": {
    "description": "Getting process provided by service center",
    "returns": "Process",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "processId",
        "type": "String",
        "description": "The id of target process."
      }
    ]
  },
  "ProcessResult.visualize": {
    "description": "Visualize the result of process",
    "returns": "ProcessResult",
    "args": [
      {
        "name": "input",
        "type": "ProcessResult",
        "description": "The result of process to be visualized."
      }
    ]
  },
  "Processes.getProcess": {
    "description": "Get the process form the processes.",
    "returns": "Process",
    "args": [
      {
        "name": "processes",
        "type": "Processes",
        "description": "The processes to be selected."
      },
      {
        "name": "processId",
        "type": "String",
        "description": "The id of the certain process."
      }
    ]
  },
  "Collections.getCollection": {
    "description": "Get the collection from collections.",
    "returns": "Collection",
    "args": [
      {
        "name": "input",
        "type": "Collections",
        "description": "The collections as the input data "
      },
      {
        "name": "collectionId",
        "type": "String",
        "description": "The id of the certain collection."
      }
    ]
  },
  "Collections.toCube": {
    "description": "Transform the collections to cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Collections",
        "description": "The collections as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "Cube的空间范围",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "String",
        "description": "Cube的时间范围",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "Cube采用的投影",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bands",
        "type": "List<String>",
        "description": "波段维度",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Collection.getCollectionType": {
    "description": "Get the type of the collection.",
    "returns": "String",
    "args": [
      {
        "name": "collection",
        "type": "Collection",
        "description": "The collection to get type."
      }
    ]
  },
  "Collection.getItem": {
    "description": "Get the item of a collection.",
    "returns": "Item",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      },
      {
        "name": "itemId",
        "type": "String",
        "description": "The id of the target item."
      }
    ]
  },
  "Collection.getNumItems": {
    "description": "Get the number of items in a collection.",
    "returns": "Integer",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      }
    ]
  },
  "Collection.toFeatureCollection": {
    "description": "Transform the collection to featureCollection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      }
    ]
  },
  "Collection.toCoverageCollection": {
    "description": "Transform the collection to featureCollection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      }
    ]
  },
  "Collection.subCollection": {
    "description": "Get part of collection.",
    "returns": "Collection",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "CoverageCollection.getCollectionType": {
    "description": "Get the type of the coverage collection.",
    "returns": "String",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage collection to get type."
      }
    ]
  },
  "CoverageCollection.getItem": {
    "description": "Get the item of a coverage collection.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "The coverage collection as the input data "
      },
      {
        "name": "itemId",
        "type": "String",
        "description": "The coverage id."
      }
    ]
  },
  "CoverageCollection.getNumItems": {
    "description": "Get the number of items in a coverage collection.",
    "returns": "Integer",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "The coverage collection as the input data "
      }
    ]
  },
  "CoverageCollection.subCollection": {
    "description": "Get part of coverage collection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "The coverage collection as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "filter",
        "type": "Filter",
        "description": "Filter used",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "FeatureCollection.getCollectionType": {
    "description": "Get the type of the feature collection.",
    "returns": "String",
    "args": [
      {
        "name": "featureCollection",
        "type": "FeatureCollection",
        "description": "The feature collection to get type."
      }
    ]
  },
  "FeatureCollection.getItem": {
    "description": "Get the item of a feature collection.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection as the input data "
      },
      {
        "name": "itemId",
        "type": "String",
        "description": "The feature id."
      }
    ]
  },
  "FeatureCollection.getNumItems": {
    "description": "Get the number of items in a feature collection.",
    "returns": "Integer",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection as the input data "
      }
    ]
  },
  "FeatureCollection.subCollection": {
    "description": "Get part of feature collection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "filter",
        "type": "Filter",
        "description": "The filter to filter the featureCollection.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Feature.getItemType": {
    "description": "Get type of item.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      }
    ]
  },
  "Coverage.getItemType": {
    "description": "Get type of item.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The feature as the input data "
      }
    ]
  },
  "Coverage.domainSet": {
    "description": "Get the domain set of a coverage.",
    "returns": "Dictionary",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The Coverage as the input data "
      }
    ]
  },
  "Coverage.area": {
    "description": "Get the area of a raster with given pixel value range.",
    "returns": "Double",
    "args": [
      {
        "name": "raster",
        "type": "Coverage",
        "description": "The Coverage as the input data "
      },
      {
        "name": "valueRange",
        "type": "List<String>",
        "description": "The range of raster value for statistically "
      },
      {
        "name": "resolution",
        "type": "Double",
        "description": "Defines the resolution of area statistic "
      }
    ]
  },
  "Coverage.rangeSet": {
    "description": "Get the range set of a coverage.",
    "returns": "Dictionary",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The Coverage as the input data "
      },
      {
        "name": "subset",
        "type": "Dictionary",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "properties",
        "type": "List<String>",
        "description": "Select specific data record fields (measured/observed properties) to be returned.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleFactor",
        "type": "Float",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleAxes",
        "type": "Dictionary",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleSize",
        "type": "Dictionary",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleCrs",
        "type": "String",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Coverage.rangeType": {
    "description": "Get the range type of a coverage.",
    "returns": "Dictionary",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The Coverage as the input data "
      }
    ]
  },
  "Coverage.date": {
    "description": "Return the acquisition date of the given coverage.",
    "returns": "String",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The Coverage as the input data."
      }
    ]
  },
  "Coverage.add": {
    "description": "Adds the first value to the second for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.addNum": {
    "description": "Add the value to the coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value to add."
      }
    ]
  },
  "Coverage.subtractNum": {
    "description": "Subtract the corresponding value from the coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for subtract."
      }
    ]
  },
  "Coverage.divideNum": {
    "description": "Divide the corresponding value from the coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for divide."
      }
    ]
  },
  "Coverage.multiplyNum": {
    "description": "Multiply the corresponding value to the coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for multiply."
      }
    ]
  },
  "Coverage.powNum": {
    "description": "Raises the first coverage to the power of the value.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for pow."
      }
    ]
  },
  "Coverage.cat": {
    "description": "Combines the given coverages into a single coverage which contains all bands from all of the images.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for cat."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for cat."
      }
    ]
  },
  "Coverage.mod": {
    "description": "Mods the first value to the second for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.modNum": {
    "description": "Mods the coverage to the value.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for pow."
      }
    ]
  },
  "Coverage.subtract": {
    "description": "Subtracts the second value from the first for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.divide": {
    "description": "Divides the first value by the second, returning 0 for division by 0 for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.multiply": {
    "description": "Multiplies the first value by the second. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.and": {
    "description": "Returns 1 iff both values are non-zero for each matched pair of bands in coverage1 and coverage2. If both have only 1 band, the 2 band will match.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      }
    ]
  },
  "Coverage.bitwiseAnd": {
    "description": "Calculates the bitwise AND of the input values for each matched pair of bands in image1 and image2. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "Second coverage rdd to operate."
      }
    ]
  },
  "Coverage.or": {
    "description": "Returns 1 iff either values are non-zero for each matched pair of bands in coverage1 and coverage2. If both have only 1 band, the 2 band will match",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      }
    ]
  },
  "Coverage.bitwiseOr": {
    "description": "Calculates the bitwise Or of the input values for each matched pair of bands in image1 and image2. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage rdd to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "Second coverage rdd to operate."
      }
    ]
  },
  "Coverage.bitwiseXor": {
    "description": "Calculates the bitwise XOR of the input values for each matched pair of bands in coverage1 and coverage2. If both have only 1 band, the 2 band will match",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "First coverage to operate."
      }
    ]
  },
  "Coverage.not": {
    "description": "Returns 0 if the input is non-zero, and 1 otherwise.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage to operate."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "First coverage to operate."
      }
    ]
  },
  "Coverage.bitwiseNot": {
    "description": "Calculates the bitwise Not of the input values for a coverage. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "Coverage to operate."
      }
    ]
  },
  "Coverage.binarization": {
    "description": "Returns 0 iff the first value is smaller than threshold,else return 255",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage from which the left operand bands are taken"
      },
      {
        "name": "threshold",
        "type": "Double",
        "description": "threshold"
      }
    ]
  },
  "Coverage.normalizedDifference": {
    "description": "Computes the normalized difference between two bands.The normalized difference is computed as (first − second) / (first + second). ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Covergae",
        "description": "The input covergae"
      },
      {
        "name": "bandNames",
        "type": "List<String>",
        "description": "A list of names specifying the bands to use. If not specified, the first and second bands are used",
        "optional": "True",
        "default": "None"
      }
    ]
  },
  "Coverage.bandNames": {
    "description": "Get all bands names from a coverage.",
    "returns": "String",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to operate."
      }
    ]
  },
  "Coverage.bandNum": {
    "description": "Get the count of the coverage.",
    "returns": "Integer",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage."
      }
    ]
  },
  "Coverage.selectBands": {
    "description": "",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "bands",
        "type": "List<String>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.aspectByQGIS": {
    "description": "Calculates the aspect of the Digital Terrain Model in input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Digital Terrain Model raster layer."
      },
      {
        "name": "zFactor",
        "type": "Double",
        "description": "Vertical exaggeration.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Coverage.calNDVI": {
    "description": "Calculates the NDVI in input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Digital Terrain Model raster layer."
      }
    ]
  },
  "Coverage.calLSWI": {
    "description": "Calculates the aspect of the Digital Terrain Model in input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Digital Terrain Model raster layer."
      }
    ]
  },
  "Coverage.getParaData": {
    "description": "Calculates the aspect of the Digital Terrain Model in input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "year",
        "type": "String",
        "description": "NPP year."
      },
      {
        "name": "quarter",
        "type": "String",
        "description": "NPP quarter."
      }
    ]
  },
  "Coverage.calNPP": {
    "description": "Calculates the aspect of the Digital Terrain Model in input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "inputLSWI",
        "type": "Coverage",
        "description": "raster layer."
      },
      {
        "name": "inputNDVI",
        "type": "Coverage",
        "description": "raster layer."
      },
      {
        "name": "paraData",
        "type": "Coverage",
        "description": "parameter layer."
      }
    ]
  },
  "Coverage.slopeByQGIS": {
    "description": "Calculates the slope from an input raster layer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Digital Terrain Model raster layer."
      },
      {
        "name": "zFactor",
        "type": "Double",
        "description": "Vertical exaggeration.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Coverage.rescaleRasterByQGIS": {
    "description": "Rescales raster layer to a new value range.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Digital Terrain Model raster layer."
      },
      {
        "name": "minimum",
        "type": "Double",
        "description": "Minimum pixel value to use in the rescaled layer.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "maximum",
        "type": "Double",
        "description": "Maximum pixel value to use in the rescaled layer.",
        "optional": "True",
        "default": 255.0
      },
      {
        "name": "band",
        "type": "Int",
        "description": "If the raster is multiband, choose a band.",
        "optional": "True",
        "default": 1
      }
    ]
  },
  "Coverage.ruggednessIndexByQGIS": {
    "description": "Calculates the quantitative measurement of terrain heterogeneity .",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster layer."
      },
      {
        "name": "zFactor",
        "type": "Double",
        "description": "Vertical exaggeration.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Feature.projectPointsByQGIS": {
    "description": "Projects point geometries by a specified distance and bearing.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Distance to offset geometries, in layer units ",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "bearing",
        "type": "Double",
        "description": "Clockwise angle starting from North, in degree (°) unit ",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.addFieldByQGIS": {
    "description": "Adds a new field to a vector layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "fieldType",
        "type": "String",
        "description": "Type of the new field. You can choose between",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "fieldPrecision",
        "type": "Double",
        "description": "Precision of the field. Useful with Float field type.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "fieldName",
        "type": "String",
        "description": "Name of the new field",
        "optional": "True",
        "default": ""
      },
      {
        "name": "fieldLength",
        "type": "Double",
        "description": "Length of the field",
        "optional": "True",
        "default": 10
      }
    ]
  },
  "Feature.addXYFieldByQGIS": {
    "description": "Adds X and Y (or latitude/longitude) fields to a point layer",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "Coordinate reference system to use for the generated x and y fields.",
        "optional": "True",
        "default": "EPSG:4326"
      },
      {
        "name": "prefix",
        "type": "String",
        "description": "Prefix to add to the new field names to avoid name collisions with fields in the input layer.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.affineTransformByQGIS": {
    "description": "Applies an affine transformation to the layer geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "scaleX",
        "type": "Double",
        "description": "Scaling value (expansion or contraction) to apply on the X axis.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "scaleZ",
        "type": "Double",
        "description": "Scaling value (expansion or contraction) to apply on the Z axis.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "rotationZ",
        "type": "Double",
        "description": "Angle of the rotation in degrees.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "scaleY",
        "type": "Double",
        "description": "Scaling value (expansion or contraction) to apply on the Y axis.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "scaleM",
        "type": "Double",
        "description": "Scaling value (expansion or contraction) to apply on the M axis.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "deltaM",
        "type": "Double",
        "description": "Displacement to apply on the M axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaX",
        "type": "Double",
        "description": "Displacement to apply on the X axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaY",
        "type": "Double",
        "description": "Displacement to apply on the Y axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaZ",
        "type": "Double",
        "description": "Displacement to apply on the Z axis.",
        "optional": "True",
        "default": 0
      }
    ]
  },
  "Feature.antimeridianSplitByQGIS": {
    "description": "Splits a line into multiple geodesic segments",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      }
    ]
  },
  "Feature.arrayOffsetLinesByQGIS": {
    "description": "Creates copies of line features in a layer",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "segments",
        "type": "Double",
        "description": "Number of line segments to use to approximate a quarter circle when creating rounded offsets",
        "optional": "True",
        "default": 8
      },
      {
        "name": "joinStyle",
        "type": "String",
        "description": "Specify whether round, miter or beveled joins should be used when offsetting corners in a line",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "offset",
        "type": "Double",
        "description": "Specify the output line layer with offset features",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "count",
        "type": "Double",
        "description": "Number of offset copies to generate for each feature",
        "optional": "True",
        "default": 10
      },
      {
        "name": "miterLimit",
        "type": "Double",
        "description": "Only applicable for mitered join styles",
        "optional": "True",
        "default": 2.0
      }
    ]
  },
  "Feature.translatedFeaturesByQGIS": {
    "description": "Applies an affine transformation to the layer geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "count",
        "type": "Double",
        "description": "Number of copies to generate for each feature",
        "optional": "True",
        "default": 10
      },
      {
        "name": "deltaM",
        "type": "Double",
        "description": "Displacement to apply on the M axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaX",
        "type": "Double",
        "description": "Displacement to apply on the X axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaY",
        "type": "Double",
        "description": "Displacement to apply on the Y axis.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "deltaZ",
        "type": "Double",
        "description": "Displacement to apply on the Z axis.",
        "optional": "True",
        "default": 0
      }
    ]
  },
  "Feature.assignProjectionByQGIS": {
    "description": "Assigns a new projection to a vector layer",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "crs",
        "type": "String",
        "description": "Select the new CRS to assign to the vector layer",
        "optional": "True",
        "default": "EPSG:4326 - WGS84"
      }
    ]
  },
  "Feature.offsetLineByQGIS": {
    "description": "Offsets lines by a specified distance",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "segments",
        "type": "Int",
        "description": "Controls the number of line segments to use to approximate a quarter circle",
        "optional": "True",
        "default": 8
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Offset distance",
        "optional": "True",
        "default": 10
      },
      {
        "name": "joinStyle",
        "type": "String",
        "description": "Specifies whether round, miter or beveled joins should be used when offsetting corners in a line",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "miterLimit",
        "type": "Double",
        "description": "Controls the maximum distance from the offset curve",
        "optional": "True",
        "default": 2.0
      }
    ]
  },
  "Feature.pointsAlongLinesByQGIS": {
    "description": "Creates points at regular intervals along line or polygon geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "startOffset",
        "type": "Double",
        "description": "Distance from the beginning of the input line",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Distance between two consecutive points along the line",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "endOffset",
        "type": "Double",
        "description": "Distance from the end of the input line",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.polygonizeByQGIS": {
    "description": "Creates a polygon layer whose features boundaries are generated from a line layer of closed features.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "keepFields",
        "type": "String",
        "description": "Check to keep the field",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Feature.polygonsToLinesByQGIS": {
    "description": "Takes a polygon layer and creates a line layer",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      }
    ]
  },
  "Feature.shortestPathPointToPointByQGIS": {
    "description": "Computes the optimal (shortest or fastest) route between a given start point and a given end point.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "valueForward",
        "type": "String",
        "description": "Value set in the direction field to identify edges with a forward direction"
      },
      {
        "name": "valueBoth",
        "type": "String",
        "description": "Value set in the direction field to identify bidirectional edges"
      },
      {
        "name": "startPoint",
        "type": "String",
        "description": "Point feature representing the start point of the routes"
      },
      {
        "name": "defaultDirection",
        "type": "String",
        "description": "If a feature has no value set in the direction field or if no direction field is set, then this direction value is used. One of: 0 — Forward direction 1 — Backward direction 2 — Both directions",
        "default": "2"
      },
      {
        "name": "strategy",
        "type": "String",
        "description": "The type of path to calculate. One of: 0 — Shortest 1 — Fastest",
        "default": "0"
      },
      {
        "name": "tolerance",
        "type": "Double",
        "description": "Two lines with nodes closer than the specified tolerance are considered connected",
        "default": 0.0
      },
      {
        "name": "defaultSpeed",
        "type": "Double",
        "description": "Value to use to calculate the travel time if no speed field is provided for an edge",
        "default": 50.0
      },
      {
        "name": "directionField",
        "type": "String",
        "description": "The field used to specify directions for the network edges."
      },
      {
        "name": "endPoint",
        "type": "String",
        "description": "Point feature representing the end point of the routes."
      },
      {
        "name": "valueBackward",
        "type": "String",
        "description": "Value set in the direction field to identify edges with a backward direction."
      },
      {
        "name": "speedField",
        "type": "String",
        "description": "Field providing the speed value (in ) for the edges of the network when looking for the fastest path."
      }
    ]
  },
  "Feature.rasterSamplingByQGIS": {
    "description": "Extracts raster values at the point locations. If the raster layer is multiband, each band is sampled.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Point vector layer to use for sampling."
      },
      {
        "name": "rasterCopy",
        "type": "Coverage",
        "description": "Raster layer to sample at the given point locations.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "columnPrefix",
        "type": "String",
        "description": "Prefix for the names of the added columns.",
        "optional": "True",
        "default": "SAMPLE_"
      }
    ]
  },
  "Feature.randomPointsInPolygonsByQGIS": {
    "description": "Creates a point layer with points placed inside the polygons of another layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "minDistance",
        "type": "Double",
        "description": "The minimum distance between points within one polygon feature",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "includePolygonAttributes",
        "type": "String",
        "description": "a point will get the attributes from the line",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "maxTriesPerPoint",
        "type": "Int",
        "description": "The maximum number of tries per point",
        "optional": "True",
        "default": 10
      },
      {
        "name": "pointsNumber",
        "type": "Int",
        "description": "Number of points to create",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minDistanceGlobal",
        "type": "Double",
        "description": "The global minimum distance between points",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.randomPointsOnLinesByQGIS": {
    "description": "Creates a point layer with points placed on the lines of another layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "minDistance",
        "type": "Double",
        "description": "The minimum distance between points within one polygon feature",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "includeLineAttributes",
        "type": "String",
        "description": "a point will get the attributes from the line",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "maxTriesPerPoint",
        "type": "Int",
        "description": "The maximum number of tries per point",
        "optional": "True",
        "default": 10
      },
      {
        "name": "pointsNumber",
        "type": "Int",
        "description": "Number of points to create",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minDistanceGlobal",
        "type": "Double",
        "description": "The global minimum distance between points",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.rotateFeaturesByQGIS": {
    "description": "Rotates feature geometries by the specified angle clockwise.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "anchor",
        "type": "String",
        "description": "X,Y coordinates of the point to rotate the features around",
        "optional": "True",
        "default": ""
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Angle of the rotation in degrees",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.simplifyByQGIS": {
    "description": "Simplifies the geometries in a line or polygon layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "method",
        "type": "String",
        "description": "Simplification method",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "tolerance",
        "type": "Double",
        "description": "Threshold tolerance",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Feature.convertFromStringByQGIS": {
    "description": "Simplifies the geometries in a line or polygon layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "inputString",
        "type": "String",
        "description": "Carbon result"
      }
    ]
  },
  "Coverage.warpGeoreByGDAL": {
    "description": "Warp one or several datasets.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      },
      {
        "name": "GCPs",
        "type": "String",
        "description": "The path of GCPs.",
        "optional": "True"
      },
      {
        "name": "resampleMethod",
        "type": "String",
        "description": " resampling mode."
      }
    ]
  },
  "Feature.rasterizeByGDAL": {
    "description": "Converts vector geometries (points, lines and polygons) into a raster image.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "field",
        "type": "String",
        "description": "Defines the attribute field from which the attributes for the pixels should be chosen",
        "optional": "True",
        "default": ""
      },
      {
        "name": "burn",
        "type": "Double",
        "description": "A fixed value to burn into a band for all features.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "useZ",
        "type": "String",
        "description": "Indicates that a burn value should be extracted from the “Z” values",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "units",
        "type": "String",
        "description": "Units to use when defining the output raster size/resolution. ",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "width",
        "type": "Double",
        "description": "Sets the width (if size units is “Pixels”) or horizontal resolution",
        "optional": "True",
        "default": 1
      },
      {
        "name": "height",
        "type": "Double",
        "description": "Sets the height (if size units is “Pixels”) or vertical resolution",
        "optional": "True",
        "default": 1
      },
      {
        "name": "extent",
        "type": "String",
        "description": "Extent of the output raster layer.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "Assigns a specified NoData value to output bands",
        "optional": "True",
        "default": 0
      }
    ]
  },
  "Feature.smoothByQGIS": {
    "description": "Smooths the geometries in a line or polygon layer by adding more vertices and corners to the feature geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "maxAngle",
        "type": "Double",
        "description": "Every node below this value will be smoothed",
        "optional": "True",
        "default": 180.0
      },
      {
        "name": "iterations",
        "type": "Int",
        "description": "Increasing the number of iterations will give smoother geometries",
        "optional": "True",
        "default": 1
      },
      {
        "name": "offset",
        "type": "Double",
        "description": "Increasing values will move the smoothed lines",
        "optional": "True",
        "default": 0.25
      }
    ]
  },
  "Feature.swapXYByQGIS": {
    "description": "Switches the X and Y coordinate values in input geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      }
    ]
  },
  "Feature.transectQGIS": {
    "description": "Switches the X and Y coordinate values in input geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      },
      {
        "name": "side",
        "type": "String",
        "description": "Choose the side of the transect. Available options are",
        "optional": "True",
        "default": ""
      },
      {
        "name": "length",
        "type": "Double",
        "description": "Length in map unit of the transect",
        "optional": "True",
        "default": 5.0
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Change the angle of the transect",
        "optional": "True",
        "default": 90.0
      }
    ]
  },
  "Feature.translateGeometryByQGIS": {
    "description": "Moves the geometries within a layer, by offsetting with a predefined X and Y displacement.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "delta_x",
        "type": "Double",
        "description": "Displacement to apply on the X axis",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "delta_y",
        "type": "Double",
        "description": "Displacement to apply on the Y axis",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "delta_z",
        "type": "Double",
        "description": "Displacement to apply on the Z axis",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "delta_m",
        "type": "Double",
        "description": "Displacement to apply on the Z axis",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.convertGeometryTypeByQGIS": {
    "description": "Generates a new layer based on an existing one, with a different type of geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "geometryType",
        "type": "String",
        "description": "Geometry type to apply to the output features. One of:0 — Centroids;1 — Nodes;2 — Linestrings;3 — Multilinestrings;4 — Polygons",
        "optional": "True",
        "default": "0"
      }
    ]
  },
  "Feature.linesToPolygonsByQGIS": {
    "description": "Generates a polygon layer using as polygon rings the lines from an input line layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input line vector layer"
      }
    ]
  },
  "Feature.pointsDisplacementByQGIS": {
    "description": "Given a distance of proximity, identifies nearby point features and radially distributes them over a circle whose center represents their barycenter.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer"
      },
      {
        "name": "proximity",
        "type": "Double",
        "description": "Distance below which point features are considered close. Close features are distributed altogether.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Radius of the circle on which close features are placed",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "horizontal",
        "type": "String",
        "description": "When only two points are identified as close, aligns them horizontally on the circle instead of vertically.",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Feature.randomPointsAlongLineByQGIS": {
    "description": "Creates a new point layer, with points placed on the lines of another layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input line vector layer"
      },
      {
        "name": "pointsNumber",
        "type": "Int",
        "description": "Number of points to create",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minDistance",
        "type": "Double",
        "description": "The minimum distance between points",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.randomPointsInLayerBoundsByQGIS": {
    "description": "Creates a new point layer with a given number of random points, all of them within the extent of a given layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input polygon layer defining the area"
      },
      {
        "name": "pointsNumber",
        "type": "Int",
        "description": "Number of points to create",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minDistance",
        "type": "Double",
        "description": "The minimum distance between points",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.angleToNearestByQGIS": {
    "description": "Calculates the rotation required to align point features with their nearest feature from another reference layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Point features to calculate the rotation for"
      },
      {
        "name": "referenceLayer",
        "type": "Feature",
        "description": "Layer to find the closest feature from for rotation calculation",
        "optional": "True",
        "default": ""
      },
      {
        "name": "maxDistance",
        "type": "Double",
        "description": "If no reference feature is found within this distance, no rotation is assigned to the point feature.",
        "optional": "True",
        "default": "Not Set"
      },
      {
        "name": "fieldName",
        "type": "String",
        "description": "Field in which to store the rotation value.",
        "optional": "True",
        "default": "rotation"
      },
      {
        "name": "applySymbology",
        "type": "String",
        "description": "Rotates the symbol marker of the features using the angle field value",
        "optional": "True",
        "default": "True"
      }
    ]
  },
  "Feature.boundaryByQGIS": {
    "description": "Returns the closure of the combinatorial boundary of the input geometries",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input line or polygon vector layer"
      }
    ]
  },
  "Feature.miniEnclosingCircleByQGIS": {
    "description": "Calculates the minimum enclosing circles of the features in the input layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "segments",
        "type": "Int",
        "description": "The number of segment used to approximate a circle. Minimum 8, maximum 100000.",
        "optional": "True",
        "default": 72
      }
    ]
  },
  "Feature.multiRingConstantBufferByQGIS": {
    "description": "Computes multi-ring (donut) buffer for the features of the input layer, using a fixed or dynamic distance and number of rings.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "rings",
        "type": "Int",
        "description": "The number of rings. It can be a unique value (same number of rings for all the features) or it can be taken from features data (the number of rings depends on feature values).",
        "optional": "True",
        "default": 1
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Distance between the rings. It can be a unique value (same distance for all the features) or it can be taken from features data (the distance depends on feature values).",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Feature.orientedMinimumBoundingBoxByQGIS": {
    "description": "Calculates the minimum area rotated rectangle for each feature in the input layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      }
    ]
  },
  "Feature.pointOnSurfaceByQGIS": {
    "description": "For each feature of the input layer, returns a point that is guaranteed to lie on the surface of the feature geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "allParts",
        "type": "String",
        "description": "If checked, a point will be created for each part of the geometry.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.poleOfInaccessibilityByQGIS": {
    "description": "Calculates the pole of inaccessibility for a polygon layer, which is the most distant internal point from the boundary of the surface.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "tolerance",
        "type": "Double",
        "description": "Set the tolerance for the calculation",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Feature.rectanglesOvalsDiamondsByQGIS": {
    "description": "Creates a buffer area with a rectangle, oval or diamond shape for each feature of the input point layer",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "rotation",
        "type": "Double",
        "description": "Rotation of the buffer shape.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "shape",
        "type": "String",
        "description": "The shape to use.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "segments",
        "type": "Int",
        "description": "Number of segments for a full circle (Ovals shape).",
        "optional": "True",
        "default": 36
      },
      {
        "name": "width",
        "type": "Double",
        "description": "Width of the buffer shape.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "height",
        "type": "Double",
        "description": "Height of the buffer shape.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "Feature.singleSidedBufferByQGIS": {
    "description": "Computes a buffer on lines by a specified distance on one side of the line only.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input line vector layer."
      },
      {
        "name": "side",
        "type": "String",
        "description": "Which side to create the buffer on.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "Buffer distance.",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "segments",
        "type": "Int",
        "description": "Controls the number of line segments to use to approximate a quarter circle when creating rounded offsets.",
        "optional": "True",
        "default": 8
      },
      {
        "name": "joinStyle",
        "type": "String",
        "description": "Options are: 0 --- Round 1 --- Miter 2 --- Bevel.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "miterLimit",
        "type": "Double",
        "description": "Sets the maximum distance from the offset geometry to use when creating a mitered join as a factor of the offset distance.",
        "optional": "True",
        "default": 2.0
      }
    ]
  },
  "Feature.taperedBufferByQGIS": {
    "description": "Creates tapered buffer along line geometries, using a specified start and end buffer diameter.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input line vector layer."
      },
      {
        "name": "segments",
        "type": "Int",
        "description": "Controls the number of line segments to use to approximate a quarter circle when creating rounded offsets.",
        "optional": "True",
        "default": 16
      },
      {
        "name": "startWidth",
        "type": "Double",
        "description": "Represents the radius of the buffer applied at the start point of the line feature.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "endWidth",
        "type": "Double",
        "description": "Represents the radius of the buffer applied at the end point of the line feature.",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.wedgeBuffersByQGIS": {
    "description": "Creates wedge shaped buffers from input points.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "innerRadius",
        "type": "Double",
        "description": "Inner radius value. If 0 the wedge will begin from the source point.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "outerRadius",
        "type": "Double",
        "description": "The outer size (length) of the wedge: the size is meant from the source point to the edge of the wedge shape.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "width",
        "type": "Double",
        "description": "Width (in degrees) of the buffer.",
        "optional": "True",
        "default": 45.0
      },
      {
        "name": "azimuth",
        "type": "Double",
        "description": "Angle (in degrees) as the middle value of the wedge.",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.concaveHullByQGIS": {
    "description": "Computes the concave hull of the features in an input point layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "noMultigeometry",
        "type": "String",
        "description": "Check if you want to have singlepart geometries instead of multipart ones.",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "holes",
        "type": "String",
        "description": "Choose whether to allow holes in the final concave hull.",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "alpha",
        "type": "Double",
        "description": "Number from 0 (maximum concave hull) to 1 (convex hull).",
        "optional": "True",
        "default": 0.3
      }
    ]
  },
  "Feature.delaunayTriangulationByQGIS": {
    "description": "Creates a polygon layer with the Delaunay triangulation corresponding to the input point layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      }
    ]
  },
  "Feature.voronoiPolygonsByQGIS": {
    "description": "Takes a point layer and generates a polygon layer containing the Voronoi polygons corresponding to those input points.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "buffer",
        "type": "Double",
        "description": "The extent of the output layer will be this much bigger than the extent of the input layer.",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "Feature.extractFromLocationByQGIS": {
    "description": "Geometric predicates are boolean functions used to determine the spatial relation a feature has with another by comparing whether and how their geometries share a portion of space.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "intersect",
        "type": "Feature",
        "description": "Intersection vector layer."
      },
      {
        "name": "predicate",
        "type": "String",
        "description": "Type of spatial relation the input feature should have with an intersect feature so that it could be selected.",
        "optional": "True",
        "default": "0"
      }
    ]
  },
  "Feature.intersectionByQGIS": {
    "description": "Extracts the portions of features from the input layer that overlap features in the overlay layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "overlay",
        "type": "Feature",
        "description": "Layer containing the features to check for overlap. Its features"
      },
      {
        "name": "inputFields",
        "type": "String",
        "description": "Field(s) of the input layer to keep in the output.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "overlayFields",
        "type": "String",
        "description": "Field(s) of the overlay layer to keep in the output.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "overlayFieldsPrefix",
        "type": "String",
        "description": "Add a prefix to identify fields of the overlay layer. ",
        "optional": "True",
        "default": ""
      },
      {
        "name": "gridSize",
        "type": "Double",
        "description": "Add a prefix to identify fields of the overlay layer. ",
        "optional": "True",
        "default": 1
      }
    ]
  },
  "Coverage.edgeExtractionByOTB": {
    "description": "This application computes edge features on a selected channel of the input.It uses different filters such as gradient, Sobel and Touzi.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "channel",
        "type": "Int",
        "description": "The selected channel index.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "filter",
        "type": "String",
        "description": "Choice of edge feature, which contains gradient, sobel, touzi.",
        "optional": "True",
        "default": "gradient"
      }
    ]
  },
  "Coverage.dimensionalityReductionByOTB": {
    "description": "Performs dimensionality reduction on input image. PCA,NA-PCA,MAF,ICA methods are available. It is also possible to compute the inverse transform to reconstruct the image and to optionally export the transformation matrix to a text file.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The input image to apply dimensionality reduction."
      },
      {
        "name": "method",
        "type": "String",
        "description": "Selection of the reduction dimension method.",
        "optional": "True",
        "default": "pca"
      },
      {
        "name": "rescale",
        "type": "String",
        "description": "Enable rescaling of the reduced output image.",
        "optional": "True",
        "default": "no"
      }
    ]
  },
  "Coverage.SFSTextureExtractionByOTB": {
    "description": "Computes Structural Feature Set textures on every pixel of the input image selected channel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The input image to compute the features on."
      },
      {
        "name": "channel",
        "type": "Int",
        "description": "The selected channel index.",
        "default": 1
      },
      {
        "name": "spectralThreshold",
        "type": "Double",
        "description": "Spectral Threshold.",
        "optional": "True",
        "default": 50
      },
      {
        "name": "spatialThreshold",
        "type": "Int",
        "description": "Spatial Threshold.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "numberOfDirection",
        "type": "Int",
        "description": "Number of Direction.",
        "optional": "True",
        "default": 20
      },
      {
        "name": "alpha",
        "type": "Double",
        "description": "Alpha.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "ratioMaximumConsiderationNumber",
        "type": "Int",
        "description": "Ratio Maximum Consideration Number.",
        "optional": "True",
        "default": 5
      }
    ]
  },
  "Coverage.multivariateAlterationDetectorByOTB": {
    "description": "Change detection by Multivariate Alteration Detector (MAD) algorithm.",
    "returns": "Coverage",
    "args": [
      {
        "name": "inputBefore",
        "type": "Coverage",
        "description": "Multiband image of the scene before perturbations."
      },
      {
        "name": "inputAfter",
        "type": "Coverage",
        "description": "Mutliband image of the scene after perturbations."
      }
    ]
  },
  "Coverage.radiometricIndicesByOTB": {
    "description": "This application computes radiometric indices using the relevant channels of the input image. The output is a multi band image into which each channel is one of the selected indices.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input image."
      },
      {
        "name": "channelsBlue",
        "type": "Int",
        "description": "Blue channel index",
        "optional": "True",
        "default": 1
      },
      {
        "name": "channelsGreen",
        "type": "Int",
        "description": "Green channel index.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "channelsRed",
        "type": "Int",
        "description": "Red channel index.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "channelsNir",
        "type": "Int",
        "description": "NIR channel index.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "channelsMir",
        "type": "Int",
        "description": "MIR channel index.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "ram",
        "type": "Int",
        "description": "Available memory for processing (in MB).",
        "optional": "True",
        "default": 256
      },
      {
        "name": "indicesList",
        "type": "List[String]",
        "description": "List of available radiometric indices with their relevant channels in brackets.",
        "optional": "True",
        "default": ["Vegetation:NDVI"]
      }
    ]
  },
  "Coverage.obtainUTMZoneFromGeoPointByOTB": {
    "description": "UTM zone determination from a geographic point.",
    "returns": "void",
    "args": [
      {
        "name": "lat",
        "type": "Double",
        "description": "Latitude value of desired point."
      },
      {
        "name": "lon",
        "type": "Double",
        "description": "Longitude value of desired point."
      }
    ]
  },
  "Coverage.largeScaleMeanShiftVectorByOTB": {
    "description": "This application chains together the 4 steps of the MeanShift framework, that is the MeanShiftSmoothing, the LSMSSegmentation, the LSMSSmallRegionsMerging and the LSMSVectorization.In this mode, the application will produce a vector file or database and compute field values for each region",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "spatialr",
        "type": "Int",
        "description": "Radius of the spatial neighborhood for averaging. Higher values will result in more smoothing and higher processing time.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "ranger",
        "type": "Float",
        "description": "Threshold on spectral signature euclidean distance (expressed in radiometry unit) to consider neighborhood pixel for averaging. Higher values will be less edge-preserving (more similar to simple average in neighborhood), whereas lower values will result in less noise smoothing. Note that this parameter has no effect on processing time.",
        "optional": "True",
        "default": 15
      },
      {
        "name": "minsize",
        "type": "Int",
        "description": "Minimum Segment Size. If, after the segmentation, a segment is of size strictly lower than this criterion, the segment is merged with the segment that has the closest sepctral signature.",
        "optional": "True",
        "default": 50
      },
      {
        "name": "tilesizex",
        "type": "Int",
        "description": "Size of tiles along the X-axis for tile-wise processing.",
        "optional": "True",
        "default": 500
      },
      {
        "name": "tilesizey",
        "type": "Int",
        "description": "Size of tiles along the Y-axis for tile-wise processing.",
        "optional": "True",
        "default": 500
      }
    ]
  },
  "Coverage.largeScaleMeanShiftRasterByOTB": {
    "description": "This application chains together the 4 steps of the MeanShift framework, that is the MeanShiftSmoothing, the LSMSSegmentation, the LSMSSmallRegionsMerging and the LSMSVectorization.In this mode, the application will produce a standard labeled raster.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "spatialr",
        "type": "Int",
        "description": "Radius of the spatial neighborhood for averaging. Higher values will result in more smoothing and higher processing time.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "ranger",
        "type": "Float",
        "description": "Threshold on spectral signature euclidean distance (expressed in radiometry unit) to consider neighborhood pixel for averaging. Higher values will be less edge-preserving (more similar to simple average in neighborhood), whereas lower values will result in less noise smoothing. Note that this parameter has no effect on processing time.",
        "optional": "True",
        "default": 15
      },
      {
        "name": "minsize",
        "type": "Int",
        "description": "Minimum Segment Size. If, after the segmentation, a segment is of size strictly lower than this criterion, the segment is merged with the segment that has the closest sepctral signature.",
        "optional": "True",
        "default": 50
      },
      {
        "name": "tilesizex",
        "type": "Int",
        "description": "Size of tiles along the X-axis for tile-wise processing.",
        "optional": "True",
        "default": 500
      },
      {
        "name": "tilesizey",
        "type": "Int",
        "description": "Size of tiles along the Y-axis for tile-wise processing.",
        "optional": "True",
        "default": 500
      }
    ]
  },
  "Coverage.meanShiftSmoothingByOTB": {
    "description": "This application smooths an image using the MeanShift algorithm.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "spatialr",
        "type": "Int",
        "description": "Radius of the spatial neighborhood for averaging. Higher values will result in more smoothing and higher processing time.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "ranger",
        "type": "Float",
        "description": "Threshold on spectral signature euclidean distance (expressed in radiometry unit) to consider neighborhood pixel for averaging. Higher values will be less edge-preserving (more similar to simple average in neighborhood), whereas lower values will result in less noise smoothing. Note that this parameter has no effect on processing time.",
        "optional": "True",
        "default": 15
      },
      {
        "name": "thres",
        "type": "Float",
        "description": "Algorithm will stop if update of average spectral signature and spatial position is below this threshold.",
        "optional": "True",
        "default": 0.1
      },
      {
        "name": "maxiter",
        "type": "Int",
        "description": "Algorithm will stop if convergence threshold is not met after the maximum number of iterations.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "rangeramp",
        "type": "Float",
        "description": "Vary the range radius linearly with the central pixel intensity (experimental).",
        "optional": "True",
        "default": 0
      }
    ]
  },
  "Coverage.localStatisticExtractionByOTB": {
    "description": "Computes local statistical moments on every pixel in the selected channel of the input image",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "channel",
        "type": "Int",
        "description": "The selected channel index (1 based)",
        "optional": "True",
        "default": 1
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The computational window radius.",
        "optional": "True",
        "default": 3
      }
    ]
  },
  "Coverage.segmentationMeanshiftRasterByOTB": {
    "description": "Performs segmentation of an image, and output a raster file.OTB implementation of the Mean-Shift algorithm (multi-threaded).",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "spatialr",
        "type": "Int",
        "description": "Spatial radius of the neighborhood.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "ranger",
        "type": "Float",
        "description": "Range radius defining the radius (expressed in radiometry unit) in the multispectral space.",
        "optional": "True",
        "default": 15
      },
      {
        "name": "thres",
        "type": "Float",
        "description": "Algorithm iterative scheme will stop if mean-shift vector is below this threshold or if iteration number reached maximum number of iterations.",
        "optional": "True",
        "default": 0.1
      },
      {
        "name": "maxiter",
        "type": "Int",
        "description": "Algorithm iterative scheme will stop if convergence hasn’t been reached after the maximum number of iterations.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "minsize",
        "type": "Int",
        "description": "Minimum size of a region (in pixel unit) in segmentation. Smaller clusters will be merged to the neighboring cluster with the closest radiometry. If set to 0 no pruning is done.",
        "optional": "True",
        "default": 100
      }
    ]
  },
  "Coverage.segmentationMeanshiftVectorByOTB": {
    "description": "Performs segmentation of an image, and output a vector file.OTB implementation of the Mean-Shift algorithm (multi-threaded)",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "spatialr",
        "type": "Int",
        "description": "Spatial radius of the neighborhood.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "ranger",
        "type": "Float",
        "description": "Range radius defining the radius (expressed in radiometry unit) in the multispectral space.",
        "optional": "True",
        "default": 15
      },
      {
        "name": "thres",
        "type": "Float",
        "description": "Algorithm iterative scheme will stop if mean-shift vector is below this threshold or if iteration number reached maximum number of iterations.",
        "optional": "True",
        "default": 0.1
      },
      {
        "name": "maxiter",
        "type": "Int",
        "description": "Algorithm iterative scheme will stop if convergence hasn’t been reached after the maximum number of iterations.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "minsize",
        "type": "Int",
        "description": "Minimum size of a region (in pixel unit) in segmentation. Smaller clusters will be merged to the neighboring cluster with the closest radiometry. If set to 0 no pruning is done.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "neighbor",
        "type": "Boolean",
        "description": "Activate 8-Neighborhood connectivity (default is 4).",
        "optional": "True",
        "default": false
      },
      {
        "name": "stitch",
        "type": "Boolean",
        "description": "Scan polygons on each side of tiles and stitch polygons which connect by more than one pixel",
        "optional": "True",
        "default": true
      },
      {
        "name": "minsize",
        "type": "Int",
        "description": "Objects whose size is below the minimum object size (area in pixels) will be ignored during vectorization.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "simplify",
        "type": "Float",
        "description": "Simplify polygons according to a given tolerance (in pixel). This option allows reducing the size of the output file or database.",
        "optional": "True",
        "default": 0.1
      },
      {
        "name": "tilesize",
        "type": "Int",
        "description": "User defined tiles size for tile-based segmentation. Optimal tile size is selected according to available RAM if null.",
        "optional": "True",
        "default": 1024
      },
      {
        "name": "startlabel",
        "type": "Int",
        "description": "Starting value of the geometry index field",
        "optional": "True",
        "default": 1
      }
    ]
  },
  "Coverage.segmentationWatershedRasterByOTB": {
    "description": "Performs segmentation of an image, and output a raster file.The traditional watershed algorithm. The height function is the gradient magnitude of the amplitude (square root of the sum of squared bands).",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "threshold",
        "type": "Float",
        "description": "Depth threshold Units in percentage of the maximum depth in the image.",
        "optional": "True",
        "default": 0.01
      },
      {
        "name": "level",
        "type": "Float",
        "description": "flood level for generating the merge tree from the initial segmentation (between 0 and 1).",
        "optional": "True",
        "default": 0.1
      }
    ]
  },
  "Coverage.segmentationWatershedVectorByOTB": {
    "description": "Performs segmentation of an image, and output a vector file.The traditional watershed algorithm. The height function is the gradient magnitude of the amplitude (square root of the sum of squared bands).",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "threshold",
        "type": "Float",
        "description": "Depth threshold Units in percentage of the maximum depth in the image.",
        "optional": "True",
        "default": 0.01
      },
      {
        "name": "level",
        "type": "Float",
        "description": "flood level for generating the merge tree from the initial segmentation (between 0 and 1).",
        "optional": "True",
        "default": 0.1
      },
      {
        "name": "neighbor",
        "type": "Boolean",
        "description": "Activate 8-Neighborhood connectivity (default is 4).",
        "optional": "True",
        "default": false
      },
      {
        "name": "stitch",
        "type": "Boolean",
        "description": "Scan polygons on each side of tiles and stitch polygons which connect by more than one pixel",
        "optional": "True",
        "default": true
      },
      {
        "name": "minsize",
        "type": "Int",
        "description": "Objects whose size is below the minimum object size (area in pixels) will be ignored during vectorization.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "simplify",
        "type": "Float",
        "description": "Simplify polygons according to a given tolerance (in pixel). This option allows reducing the size of the output file or database.",
        "optional": "True",
        "default": 0.1
      },
      {
        "name": "tilesize",
        "type": "Int",
        "description": "User defined tiles size for tile-based segmentation. Optimal tile size is selected according to available RAM if null.",
        "optional": "True",
        "default": 1024
      },
      {
        "name": "startlabel",
        "type": "Int",
        "description": "Starting value of the geometry index field",
        "optional": "True",
        "default": 1
      }
    ]
  },
  "Coverage.segmentationMprofilesdRasterByOTB": {
    "description": "Performs segmentation of an image, and output a raster file.Segmentation based on morphological profiles.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "size",
        "type": "Int",
        "description": "Size of the profiles.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "start",
        "type": "Int",
        "description": "Initial radius of the structuring element (in pixels).",
        "optional": "True",
        "default": 1
      },
      {
        "name": "step",
        "type": "Int",
        "description": "Radius step along the profile (in pixels)",
        "optional": "True",
        "default": 1
      },
      {
        "name": "float",
        "type": "Float",
        "description": "Profiles values under the threshold will be ignored.",
        "optional": "True",
        "default": 1
      }
    ]
  },
  "Feature.ComputeOGRLayersFeaturesStatisticsByOTB": {
    "description": "Compute statistics (mean and standard deviation) of the features in a set of OGR Layers, and write them in an XML file. The resulting XML file can then be used by the training application.",
    "returns": "string",
    "args": [
      {
        "name": "inshp",
        "type": "Feature",
        "optional": "True",
        "description": "Name of the input shapefile"
      },
      {
        "name": "feat",
        "type": "ListBuffer",
        "description": "List of features to consider for statistics.",
        "default": "['perimeter']"
      }
    ]
  },
  "Coverage.KMeansClassificationByOTB": {
    "description": "Unsupervised KMeans image classification. This is a composite application, using existing training and classification applications. The SharkKMeans model is used.",
    "returns": "Coverage",
    "args": [{
      "name": "in",
      "type": "Coverage",
      "description": "Input image filename.",
      "optional": "True"
    }, {
      "name": "nc",
      "type": "Int",
      "description": "Number of modes, which will be used to generate class membership.",
      "default": 5
    }, {
      "name": "ts",
      "type": "Int",
      "description": "Size of the training set (in pixels).",
      "default": 100
    }, {
      "name": "maxit",
      "type": "Int",
      "description": "Maximum number of iterations for the learning step. If this parameter is set to 0, the KMeans algorithm will not stop until convergence",
      "default": 1000
    }, {
      "name": "centroids.in",
      "type": "String",
      "description": "Input text file containing centroid positions used to initialize the algorithm. Each centroid must be described by p parameters, p being the number of bands in the input image, and the number of centroids must be equal to the number of classes (one centroid per line with values separated by spaces).",
      "optional": "False"
    }, {
      "name": "centroids.out",
      "type": "String",
      "description": "Output text file containing centroids after the kmean algorithm.",
      "optional": "False"
    }, {
      "name": "ram",
      "type": "Int",
      "description": "Available memory for processing (in MB).",
      "default": 256
    }, {
      "name": "sampler",
      "type": "null",
      "description": "Type of sampling (periodic, pattern based, random)",
      "default": "periodic"
    }, {
      "name": "sampler.periodic.jitter",
      "type": "Int",
      "description": "Jitter amplitude added during sample selection (0 = no jitter)",
      "default": 0
    }, {
      "name": "vm",
      "type": "Coverage",
      "description": "Validity mask, only non-zero pixels will be used to estimate KMeans modes.",
      "optional": "False"
    }, {
      "name": "nodatalabel",
      "type": "Int",
      "description": "By default, hidden pixels will have the assigned label 0 in the output image. It’s possible to define the label mask by another value, but be careful to not take a label from another class. This application initializes the labels from 0 to N-1, N is the number of class (defined by ‘nc’ parameter).",
      "default": 0
    }, {
      "name": "cleanup",
      "type": "Boolean",
      "description": "If activated, the application will try to clean all temporary files it created",
      "default": "true"
    }, {
      "name": "rand",
      "type": "Int",
      "description": "Set a specific random seed with integer value.",
      "optional": "False"
    }]
  },
  "Coverage.SOMClassificationByOTB": {
    "description": "SOM image classification.",
    "returns": "Coverage",
    "args": [
      {
        "name": "in",
        "type": "Coverage",
        "optional": "True",
        "description": "Input image to classify"
      },
      {
        "name": "vm",
        "type": "Coverage",
        "description": "Validity mask (only pixels corresponding to a mask value greater than 0 will be used for learning)."
      },
      {
        "name": "tp",
        "type": "Float",
        "description": "Probability for a sample to be selected in the training set.",
        "default": 1
      },
      {
        "name": "som",
        "type": "Coverage",
        "description": "Output image containing the Self-Organizing Map."
      },
      {
        "name": "ts",
        "type": "Int",
        "description": "Maximum training set size (in pixels)."
      },
      {
        "name": "sx",
        "type": "Int",
        "description": "X size of the SOM map.",
        "default": 32
      },
      {
        "name": "sy",
        "type": "Int",
        "description": "Y size of the SOM map.",
        "default": 32
      },
      {
        "name": "nx",
        "type": "Int",
        "description": "X size of the initial neighborhood in the SOM map.",
        "default": 10
      },
      {
        "name": "ny",
        "type": "Int",
        "description": "Y size of the initial neighborhood in the SOM map.",
        "default": 10
      },
      {
        "name": "ni",
        "type": "Int",
        "description": "Number of iterations for SOM learning.",
        "default": 5
      },
      {
        "name": "bi",
        "type": "Float",
        "description": "Initial learning coefficient.",
        "default": 1
      },
      {
        "name": "bf",
        "type": "Float",
        "description": "Final learning coefficient.",
        "default": 0.1
      },
      {
        "name": "iv",
        "type": "Float",
        "description": "Maximum initial neuron weight",
        "default":0
      },
      {
        "name": "rand",
        "type": "Int",
        "description": "Set a specific random seed with integer value."
      },
      {
        "name": "ram",
        "type": "Int",
        "description": "Available memory for processing (in MB).",
        "default":256
      }
    ]
  },
  "Coverage.SampleExtractionByOTB": {
    "description": "The application extracts samples values from animage using positions contained in a vector data file.",
    "returns": "Feature",
    "args": [{
      "name": "in",
      "type": "Coverage",
      "description": "Support image",
      "optional": "True"
    }, {
      "name": "vec",
      "type": "Feature",
      "description": "Vector data file containing samplingpositions. (OGR format)",
      "optional": "True"
    }, {
      "name": "outfield",
      "type": "List<String>",
      "description": "Choice between naming method for output fields",
      "default": "prefix"
    }, {
      "name": "outfield.prefix.name",
      "type": "String",
      "description": "Prefix used to form the field names thatwill contain the extracted values.",
      "default": "value_"
    }, {
      "name": "outfield.list.names",
      "type": "List<String>",
      "description": "Full list of output field names.",
      "optional": "True"
    }, {
      "name": "field",
      "type": "String",
      "description": "Name of the field carrying the class name in the input vectors."
    }, {
      "name": "layer",
      "type": "Int",
      "description": "Layer index to read in the input vector file.",
      "default": 0
    }, {
      "name": "ram",
      "type": "Int",
      "description": "Available memory for processing (in MB).",
      "default": 256
    }]
  },
  "Feature.SampleSelectionByOTB": {
    "description": "The application selects a set of samples from geometries intended for training (they should have a field giving the associated class).",
    "returns": "Feature",
    "args": [{
      "name": "in",
      "type": "Coverage",
      "description": "Support image that will be classified",
      "optional": "True"
    }, {
      "name": "mask",
      "type": "Coverage",
      "description": "Validity mask (only pixels corresponding to a mask value greater than 0 will be used for statistics)",
      "optional": "False"
    }, {
      "name": "vec",
      "type": "Feature",
      "description": "Input geometries to analyse",
      "optional": "True"
    }, {
      "name": "instats",
      "type": "String",
      "description": "Input file storing statistics (XML format)",
      "optional": "True"
    }, {
      "name": "outrates",
      "type": "String",
      "description": "Output rates (CSV formatted)",
      "optional": "False"
    }, {
      "name": "sampler",
      "type": "List<String>",
      "description": "Type of sampling (periodic, pattern based, random)",
      "default": "periodic"
    }, {
      "name": "sampler.periodic.jitter",
      "type": "Int",
      "description": "Jitter amplitude added during sample selection (0 = no jitter)",
      "default": 0
    }, {
      "name": "strategy",
      "type": "String",
      "description": "[Set samples count for each class|Set the same samples counts for all classes| Use a percentage of the samples available for each class|Set the total number of samples to generate, and use class proportions.|Set the same number of samples for all classes, with the smallest class fully sampled|Use all samples]",
      "default": "smallest"
    }, {
      "name": "strategy.byclass.in",
      "type": "String",
      "description": "Number of samples by class (CSV format with class name in 1st column and required samples in the 2nd.",
      "optional": "True"
    }, {
      "name": "strategy.constant.nb",
      "type": "Int",
      "description": "Number of samples for all classes",
      "optional": "True"
    }, {
      "name": "strategy.percent.p",
      "type": "Float",
      "description": "The percentage to use",
      "default": "0.5"
    }, {
      "name": "strategy.total.v",
      "type": "Int",
      "description": "The number of samples to generate",
      "default": 1000
    }, {
      "name": "field",
      "type": "String",
      "description": "Name of the field carrying the class name in the input vectors."
    }, {
      "name": "layer",
      "type": "Int",
      "description": "Layer index to read in the input vector file.",
      "default": 0
    }, {
      "name": "elev.dem",
      "type": "String",
      "description": "This parameter allows selecting a directory containing Digital Elevation Model files. Note that this directory should contain only DEM files. Unexpected behaviour might occurs if other images are found in this directory. Input DEM tiles should be in a raster format supported by GDAL."
    }, {
      "name": "elev.geoid",
      "type": "String",
      "description": "Use a geoid grid to get the height above the ellipsoid in case there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles. A version of the geoid can be found on the OTB website (egm96.grd and egm96.grd.hdr at)."
    }, {
      "name": "elev.default",
      "type": "Float",
      "description": "This parameter allows setting the default height above ellipsoid when there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles, and no geoid file has been set. This is also used by some application as an average elevation value.",
      "default": 0
    }, {
      "name": "rand",
      "type": "Int",
      "description": "Set a specific random seed with integer value.",
      "optional": "False"
    }, {
      "name": "ram",
      "type": "Int",
      "description": "Available memory for processing (in MB).",
      "default": 256
    }]
  },
  "Coverage.segmentationMprofilesdVectorByOTB": {
    "description": "Performs segmentation of an image, and output a vector file.Segmentation based on morphological profiles.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "size",
        "type": "Int",
        "description": "Size of the profiles.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "start",
        "type": "Int",
        "description": "Initial radius of the structuring element (in pixels).",
        "optional": "True",
        "default": 1
      },
      {
        "name": "step",
        "type": "Int",
        "description": "Radius step along the profile (in pixels)",
        "optional": "True",
        "default": 1
      },
      {
        "name": "float",
        "type": "Float",
        "description": "Profiles values under the threshold will be ignored.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "neighbor",
        "type": "Boolean",
        "description": "Activate 8-Neighborhood connectivity (default is 4).",
        "optional": "True",
        "default": false
      },
      {
        "name": "stitch",
        "type": "Boolean",
        "description": "Scan polygons on each side of tiles and stitch polygons which connect by more than one pixel",
        "optional": "True",
        "default": true
      },
      {
        "name": "minsize",
        "type": "Int",
        "description": "Objects whose size is below the minimum object size (area in pixels) will be ignored during vectorization.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "simplify",
        "type": "Float",
        "description": "Simplify polygons according to a given tolerance (in pixel). This option allows reducing the size of the output file or database.",
        "optional": "True",
        "default": 0.1
      },
      {
        "name": "tilesize",
        "type": "Int",
        "description": "User defined tiles size for tile-based segmentation. Optimal tile size is selected according to available RAM if null.",
        "optional": "True",
        "default": 1024
      },
      {
        "name": "startlabel",
        "type": "Int",
        "description": "Starting value of the geometry index field",
        "optional": "True",
        "default": 1
      }
    ]
  },
  "Coverage.trainImagesRegressionLibSvmByOTB": {
    "description": " Train a regression model from multiple triplets of feature images, predictor images.This group of parameters allows setting SVM classifier parameters.",
    "returns": "String",
    "args": [
      {
        "name": "input_predict",
        "type": "CoverageCollection",
        "description": "A list of input predictor images."
      },
      {
        "name": "input_label",
        "type": "CoverageCollection",
        "description": " A list of input label images"
      },
      {
        "name": "ratio",
        "type": "Float",
        "description": "Ratio between training and validation samples.",
        "optional": "True",
        "default": 0.5
      },
      {
        "name": "kernel",
        "type": "String",
        "description": "SVM Kernel Type.",
        "optional": "True",
        "default": "linear"
      },
      {
        "name": "model",
        "type": "String",
        "description": "Type of SVM formulation.",
        "optional": "True",
        "default": "epssvr"
      },
      {
        "name": "costc",
        "type": "Float",
        "description": "SVM models have a cost parameter C (1 by default) to control the trade-off between training errors and forcing rigid margins.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "gamma",
        "type": "Float",
        "description": "Set gamma parameter in poly/rbf/sigmoid kernel function",
        "optional": "True",
        "default": 1
      },
      {
        "name": "coefficient",
        "type": "Float",
        "description": "Set coef0 parameter in poly/sigmoid kernel function",
        "optional": "True",
        "default": 0
      },
      {
        "name": "degree",
        "type": "Int",
        "description": "Set polynomial degree in poly kernel function",
        "optional": "True",
        "default": 3
      },
      {
        "name": "costnu",
        "type": "Float",
        "description": "Cost parameter Nu, in the range 0..1, the larger the value, the smoother the decision.",
        "optional": "True",
        "default": 0.5
      },
      {
        "name": "opt",
        "type": "Boolean",
        "description": "SVM parameters optimization flag.",
        "optional": "True",
        "default": false
      },
      {
        "name": "prob",
        "type": "Boolean",
        "description": "Probability estimation flag.",
        "optional": "True",
        "default": false
      },
      {
        "name": "epsilon",
        "type": "Int",
        "description": "The training algorithm attempts to split each node while its depth is smaller than the maximum possible depth of the tree. The actual depth may be smaller if the other termination criteria are met, and/or if the tree is pruned.",
        "optional": "True",
        "default": 10
      }
    ]
  },
  "Coverage.trainImagesRegressionDtByOTB": {
    "description": " Train a regression model from multiple triplets of feature images, predictor images.This group of parameters allows setting Decision tree classifier parameters.",
    "returns": "String",
    "args": [
      {
        "name": "input_predict",
        "type": "CoverageCollection",
        "description": "A list of input predictor images."
      },
      {
        "name": "input_label",
        "type": "CoverageCollection",
        "description": " A list of input label images"
      },
      {
        "name": "ratio",
        "type": "Float",
        "description": "Ratio between training and validation samples.",
        "optional": "True",
        "default": 0.5
      },
      {
        "name": "max",
        "type": "Int",
        "description": "The training algorithm attempts to split each node while its depth is smaller than the maximum possible depth of the tree. The actual depth may be smaller if the other termination criteria are met, and/or if the tree is pruned.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "min",
        "type": "Int",
        "description": "If the number of samples in a node is smaller than this parameter, then this node will not be split.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "ra",
        "type": "Float",
        "description": "If all absolute differences between an estimated value in a node and the values of the train samples in this node are smaller than this regression accuracy parameter, then the node will not be split further.",
        "optional": "True",
        "default": 0.01
      },
      {
        "name": "cat",
        "type": "Int",
        "description": "Cluster possible values of a categorical variable into K <= cat clusters to find a suboptimal split.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "r",
        "type": "Boolean",
        "description": "If true, then a pruning will be harsher. This will make a tree more compact and more resistant to the training data noise but a bit less accurate.",
        "optional": "True",
        "default": false
      },
      {
        "name": "t",
        "type": "Boolean",
        "description": "If true, then pruned branches are physically removed from the tree.",
        "optional": "True",
        "default": false
      }
    ]
  },
  "Coverage.trainImagesRegressionRfByOTB": {
    "description": " Train a regression model from multiple triplets of feature images, predictor images.This group of parameters allows setting Random forests classifier parameters.",
    "returns": "String",
    "args": [
      {
        "name": "input_predict",
        "type": "CoverageCollection",
        "description": "A list of input predictor images."
      },
      {
        "name": "input_label",
        "type": "CoverageCollection",
        "description": " A list of input label images"
      },
      {
        "name": "ratio",
        "type": "Float",
        "description": "Ratio between training and validation samples.",
        "optional": "True",
        "default": 0.5
      },
      {
        "name": "max",
        "type": "Int",
        "description": "The depth of the tree. A low value will likely underfit and conversely a high value will likely overfit. The optimal value can be obtained using cross validation or other suitable methods.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "min",
        "type": "Int",
        "description": "If the number of samples in a node is smaller than this parameter, then the node will not be split. A reasonable value is a small percentage of the total data e.g. 1 percent.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "ra",
        "type": "Float",
        "description": "If all absolute differences between an estimated value in a node and the values of the train samples in this node are smaller than this regression accuracy parameter, then the node will not be split.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "cat",
        "type": "Int",
        "description": "Cluster possible values of a categorical variable into K <= cat clusters to find a suboptimal split.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "var_",
        "type": "Int",
        "description": "The size of the subset of features, randomly selected at each tree node, that are used to find the best split(s). If you set it to 0, then the size will be set to the square root of the total number of features.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "nbtrees",
        "type":  "Int",
        "description": "The maximum number of trees in the forest. Typically, the more trees you have, the better the accuracy. However, the improvement in accuracy generally diminishes and reaches an asymptote for a certain number of trees. Also to keep in mind, increasing the number of trees increases the prediction time linearly.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "acc",
        "type":  "Float",
        "description": "Sufficient accuracy (OOB error).",
        "optional": "True",
        "default": 0.01
      }
    ]
  },
  "Coverage.trainImagesRegressionKnnByOTB": {
    "description": " Train a regression model from multiple triplets of feature images, predictor images.This group of parameters allows setting KNN classifier parameters.",
    "returns": "String",
    "args": [
      {
        "name": "input_predict",
        "type": "CoverageCollection",
        "description": "A list of input predictor images."
      },
      {
        "name": "input_label",
        "type": "CoverageCollection",
        "description": " A list of input label images"
      },
      {
        "name": "ratio",
        "type": "Float",
        "description": "Ratio between training and validation samples.",
        "optional": "True",
        "default": 0.5
      },
      {
        "name": "number",
        "type": "Int",
        "description": "The number of neighbors to use.",
        "optional": "True",
        "default": 32
      },
      {
        "name": "rule",
        "type": "String",
        "description": "Decision rule for regression output",
        "optional": "True",
        "default": "mean"
      }
    ]
  },
  "Coverage.trainImagesRegressionSharkrfByOTB": {
    "description": " Train a regression model from multiple triplets of feature images, predictor images.This group of parameters allows setting Shark Random forests classifier parameters.",
    "returns": "String",
    "args": [
      {
        "name": "input_predict",
        "type": "CoverageCollection",
        "description": "A list of input predictor images."
      },
      {
        "name": "input_label",
        "type": "CoverageCollection",
        "description": " A list of input label images"
      },
      {
        "name": "ratio",
        "type": "Float",
        "description": "Ratio between training and validation samples.",
        "optional": "True",
        "default": 0.5
      },
      {
        "name": "nbtrees",
        "type": "Int",
        "description": "The maximum number of trees in the forest. Typically, the more trees you have, the better the accuracy. However, the improvement in accuracy generally diminishes and reaches an asymptote for a certain number of trees. Also to keep in mind, increasing the number of trees increases the prediction time linearly.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "nodesize",
        "type": "Int",
        "description": "If the number of samples in a node is smaller than this parameter, then the node will not be split. A reasonable value is a small percentage of the total data e.g. 1 percent.",
        "optional": "True",
        "default": 25
      },
      {
        "name": "mtry",
        "type": "Int",
        "description": "The number of features (variables) which will be tested at each node in order to compute the split. If set to zero, the square root of the number of features is used.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "oobr",
        "type": "Float",
        "description": "Set the fraction of the original training dataset to use as the out of bag sample.A good default value is 0.66.",
        "optional": "True",
        "default": 0.66
      }
    ]
  },
  "Feature.ComputeOGRLayersFeaturesStatisticsByOTB": {
    "description": "Compute statistics (mean and standard deviation) of the features in a set of OGR Layers, and write them in an XML file. The resulting XML file can then be used by the training application.",
    "returns": "string",
    "args": [
      {
        "name": "inshp",
        "type": "Feature",
        "optional": "True",
        "description": "Name of the input shapefile"
      },
      {
        "name": "feat",
        "type": "List<String>",
        "description": "List of features to consider for statistics.",
        "default": "['perimeter']"
      }
    ]
  },
  "Coverage.KMeansClassificationByOTB": {
    "description": "Unsupervised KMeans image classification. This is a composite application, using existing training and classification applications. The SharkKMeans model is used.",
    "returns": "Coverage",
    "args": [{
      "name": "in",
      "type": "Coverage",
      "description": "Input image filename.",
      "optional": "True"
    }, {
      "name": "nc",
      "type": "Int",
      "description": "Number of modes, which will be used to generate class membership.",
      "default": 5
    }, {
      "name": "ts",
      "type": "Int",
      "description": "Size of the training set (in pixels).",
      "default": 100
    }, {
      "name": "maxit",
      "type": "Int",
      "description": "Maximum number of iterations for the learning step. If this parameter is set to 0, the KMeans algorithm will not stop until convergence",
      "default": 1000
    }, {
      "name": "centroids.in",
      "type": "String",
      "description": "Input text file containing centroid positions used to initialize the algorithm. Each centroid must be described by p parameters, p being the number of bands in the input image, and the number of centroids must be equal to the number of classes (one centroid per line with values separated by spaces).",
      "optional": "False"
    }, {
      "name": "centroids.out",
      "type": "String",
      "description": "Output text file containing centroids after the kmean algorithm.",
      "optional": "False"
    }, {
      "name": "ram",
      "type": "Int",
      "description": "Available memory for processing (in MB).",
      "default": 256
    }, {
      "name": "sampler",
      "type": "null",
      "description": "Type of sampling (periodic, pattern based, random)",
      "default": "periodic"
    }, {
      "name": "sampler.periodic.jitter",
      "type": "Int",
      "description": "Jitter amplitude added during sample selection (0 = no jitter)",
      "default": 0
    }, {
      "name": "vm",
      "type": "Coverage",
      "description": "Validity mask, only non-zero pixels will be used to estimate KMeans modes.",
      "optional": "False"
    }, {
      "name": "nodatalabel",
      "type": "Int",
      "description": "By default, hidden pixels will have the assigned label 0 in the output image. It’s possible to define the label mask by another value, but be careful to not take a label from another class. This application initializes the labels from 0 to N-1, N is the number of class (defined by ‘nc’ parameter).",
      "default": 0
    }, {
      "name": "cleanup",
      "type": "Boolean",
      "description": "If activated, the application will try to clean all temporary files it created",
      "default": "true"
    }, {
      "name": "rand",
      "type": "Int",
      "description": "Set a specific random seed with integer value.",
      "optional": "False"
    }]
  },
  "Coverage.SOMClassificationByOTB": {
    "description": "SOM image classification.",
    "returns": "Coverage",
    "args": [
      {
        "name": "in",
        "type": "Coverage",
        "optional": "True",
        "description": "Input image to classify"
      },
      {
        "name": "vm",
        "type": "Coverage",
        "description": "Validity mask (only pixels corresponding to a mask value greater than 0 will be used for learning)."
      },
      {
        "name": "tp",
        "type": "Float",
        "description": "Probability for a sample to be selected in the training set.",
        "default": 1
      },
      {
        "name": "som",
        "type": "Coverage",
        "description": "Output image containing the Self-Organizing Map."
      },
      {
        "name": "ts",
        "type": "Int",
        "description": "Maximum training set size (in pixels)."
      },
      {
        "name": "sx",
        "type": "Int",
        "description": "X size of the SOM map.",
        "default": 32
      },
      {
        "name": "sy",
        "type": "Int",
        "description": "Y size of the SOM map.",
        "default": 32
      },
      {
        "name": "nx",
        "type": "Int",
        "description": "X size of the initial neighborhood in the SOM map.",
        "default": 10
      },
      {
        "name": "ny",
        "type": "Int",
        "description": "Y size of the initial neighborhood in the SOM map.",
        "default": 10
      },
      {
        "name": "ni",
        "type": "Int",
        "description": "Number of iterations for SOM learning.",
        "default": 5
      },
      {
        "name": "bi",
        "type": "Float",
        "description": "Initial learning coefficient.",
        "default": 1
      },
      {
        "name": "bf",
        "type": "Float",
        "description": "Final learning coefficient.",
        "default": 0.1
      },
      {
        "name": "iv",
        "type": "Float",
        "description": "Maximum initial neuron weight",
        "default":0
      },
      {
        "name": "rand",
        "type": "Int",
        "description": "Set a specific random seed with integer value."
      },
      {
        "name": "ram",
        "type": "Int",
        "description": "Available memory for processing (in MB).",
        "default":256
      }
    ]
  },
  "Coverage.SampleExtractionByOTB": {
    "description": "The application extracts samples values from animage using positions contained in a vector data file.",
    "returns": "Feature",
    "args": [{
      "name": "in",
      "type": "Coverage",
      "description": "Support image",
      "optional": "True"
    }, {
      "name": "vec",
      "type": "Feature",
      "description": "Vector data file containing samplingpositions. (OGR format)",
      "optional": "True"
    }, {
      "name": "outfield",
      "type": "List<String>",
      "description": "Choice between naming method for output fields",
      "default": "prefix"
    }, {
      "name": "outfield.prefix.name",
      "type": "String",
      "description": "Prefix used to form the field names thatwill contain the extracted values.",
      "default": "value_"
    }, {
      "name": "outfield.list.names",
      "type": "List<String>",
      "description": "Full list of output field names.",
      "optional": "True"
    }, {
      "name": "field",
      "type": "String",
      "description": "Name of the field carrying the class name in the input vectors."
    }, {
      "name": "layer",
      "type": "Int",
      "description": "Layer index to read in the input vector file.",
      "default": 0
    }, {
      "name": "ram",
      "type": "Int",
      "description": "Available memory for processing (in MB).",
      "default": 256
    }]
  },
  "Feature.SampleSelectionByOTB": {
    "description": "The application selects a set of samples from geometries intended for training (they should have a field giving the associated class).",
    "returns": "Feature",
    "args": [{
      "name": "in",
      "type": "Coverage",
      "description": "Support image that will be classified",
      "optional": "True"
    }, {
      "name": "mask",
      "type": "Coverage",
      "description": "Validity mask (only pixels corresponding to a mask value greater than 0 will be used for statistics)",
      "optional": "False"
    }, {
      "name": "vec",
      "type": "Feature",
      "description": "Input geometries to analyse",
      "optional": "True"
    }, {
      "name": "instats",
      "type": "String",
      "description": "Input file storing statistics (XML format)",
      "optional": "True"
    }, {
      "name": "outrates",
      "type": "String",
      "description": "Output rates (CSV formatted)",
      "optional": "False"
    }, {
      "name": "sampler",
      "type": "List<String>",
      "description": "Type of sampling (periodic, pattern based, random)",
      "default": "periodic"
    }, {
      "name": "sampler.periodic.jitter",
      "type": "Int",
      "description": "Jitter amplitude added during sample selection (0 = no jitter)",
      "default": 0
    }, {
      "name": "strategy",
      "type": "String",
      "description": "[Set samples count for each class|Set the same samples counts for all classes| Use a percentage of the samples available for each class|Set the total number of samples to generate, and use class proportions.|Set the same number of samples for all classes, with the smallest class fully sampled|Use all samples]",
      "default": "smallest"
    }, {
      "name": "strategy.byclass.in",
      "type": "String",
      "description": "Number of samples by class (CSV format with class name in 1st column and required samples in the 2nd.",
      "optional": "True"
    }, {
      "name": "strategy.constant.nb",
      "type": "Int",
      "description": "Number of samples for all classes",
      "optional": "True"
    }, {
      "name": "strategy.percent.p",
      "type": "Float",
      "description": "The percentage to use",
      "default": "0.5"
    }, {
      "name": "strategy.total.v",
      "type": "Int",
      "description": "The number of samples to generate",
      "default": 1000
    }, {
      "name": "field",
      "type": "String",
      "description": "Name of the field carrying the class name in the input vectors."
    }, {
      "name": "layer",
      "type": "Int",
      "description": "Layer index to read in the input vector file.",
      "default": 0
    }, {
      "name": "elev.dem",
      "type": "String",
      "description": "This parameter allows selecting a directory containing Digital Elevation Model files. Note that this directory should contain only DEM files. Unexpected behaviour might occurs if other images are found in this directory. Input DEM tiles should be in a raster format supported by GDAL."
    }, {
      "name": "elev.geoid",
      "type": "String",
      "description": "Use a geoid grid to get the height above the ellipsoid in case there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles. A version of the geoid can be found on the OTB website (egm96.grd and egm96.grd.hdr at)."
    }, {
      "name": "elev.default",
      "type": "Float",
      "description": "This parameter allows setting the default height above ellipsoid when there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles, and no geoid file has been set. This is also used by some application as an average elevation value.",
      "default": 0
    }, {
      "name": "rand",
      "type": "Int",
      "description": "Set a specific random seed with integer value.",
      "optional": "False"
    }, {
      "name": "ram",
      "type": "Int",
      "description": "Available memory for processing (in MB).",
      "default": 256
    }]
  },
  "String.TrainImagesClassifierByOTB": {
    "description": "Train a classifier from multiple pairs of images and training vector data. Samples are composed of pixel values in each band optionally centered and reduced using an XML statistics file produced by the ComputeImagesStatistics application.",
    "returns": "String",
    "args": [{
      "name": "io.il",
      "type": "List<Coverage>",
      "description": "A list of input images.",
      "optional": "True"
    }, {
      "name": "io.vd",
      "type": "List<Feature>",
      "description": "A list of vector data to select the training samples.",
      "optional": "True"
    }, {
      "name": "io.valid",
      "type": "List<Feature>",
      "description": "A list of vector data to select the validation samples."
    }, {
      "name": "io.imstat",
      "type": "String",
      "description": "XML file containing mean and variance of each feature."
    }, {
      "name": "io.confmatout",
      "type": "String",
      "description": "Output file containing the confusion matrix or contingency table (.csv format).The contingency table is output when we unsupervised algorithms is used otherwise the confusion matrix is output."
    }, {
      "name": "cleanup",
      "type": "Boolean",
      "description": "If activated, the application will try to clean all temporary files it created",
      "default": "true"
    }, {
      "name": "sample.mt",
      "type": "Int",
      "description": "Maximum size per class (in pixels) of the training sample list (default = 1000) (no limit = -1). If equal to -1, then the maximal size of the available training sample list per class will be equal to the surface area of the smallest class multiplied by the training sample ratio.",
      "default": 1000
    }, {
      "name": "sample.mv",
      "type": "Int",
      "description": "Maximum size per class (in pixels) of the validation sample list (default = 1000) (no limit = -1). If equal to -1, then the maximal size of the available validation sample list per class will be equal to the surface area of the smallest class multiplied by the validation sample ratio.",
      "default": 1000
    }, {
      "name": "sample.bm",
      "type": "Int",
      "description": "Bound the number of samples for each class by the number of available samples by the smaller class. Proportions between training and validation are respected. Default is true (=1).",
      "default": 1
    }, {
      "name": "sample.vtr",
      "type": "Float",
      "description": "Ratio between training and validation samples (0.0 = all training, 1.0 = all validation) (default = 0.5).",
      "default": "0.5"
    }, {
      "name": "sample.vfn",
      "type": "String",
      "description": "Field containing the class id for supervision. The values in this field shall be cast into integers."
    }, {
      "name": "ram",
      "type": "Int",
      "description": "Available memory for processing (in MB).",
      "default": 256
    }, {
      "name": "elev.dem",
      "type": "String",
      "description": "This parameter allows selecting a directory containing Digital Elevation Model files. Note that this directory should contain only DEM files. Unexpected behaviour might occurs if other images are found in this directory. Input DEM tiles should be in a raster format supported by GDAL."
    }, {
      "name": "elev.geoid",
      "type": "String",
      "description": "Use a geoid grid to get the height above the ellipsoid in case there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles. A version of the geoid can be found on the OTB website (egm96.grd and egm96.grd.hdr at)."
    }, {
      "name": "elev.default",
      "type": "Float",
      "description": "This parameter allows setting the default height above ellipsoid when there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles, and no geoid file has been set. This is also used by some application as an average elevation value.",
      "default": 0
    }, {
      "name": "classifier",
      "type": "String",
      "description": "Choice of the classifier to use for the training.",
      "default": "libsvm"
    }, {
      "name": "classifier.libsvm.k",
      "type": "String",
      "description": "SVM Kernel Type.",
      "default": "linear"
    }, {
      "name": "classifier.libsvm.m",
      "type": "String",
      "description": "Type of SVM formulation.",
      "default": "csvc"
    }, {
      "name": "classifier.libsvm.c",
      "type": "Float",
      "description": "SVM models have a cost parameter C (1 by default) to control the trade-off between training errors and forcing rigid margins.",
      "default": 1
    }, {
      "name": "classifier.libsvm.gamma",
      "type": "Float",
      "description": "Set gamma parameter in poly/rbf/sigmoid kernel function",
      "default": 1
    }, {
      "name": "classifier.libsvm.coef0",
      "type": "Float",
      "description": "Set coef0 parameter in poly/sigmoid kernel function",
      "default": 0
    }, {
      "name": "classifier.libsvm.degree",
      "type": "Int",
      "description": "Set polynomial degree in poly kernel function",
      "default": 3
    }, {
      "name": "classifier.libsvm.nu",
      "type": "Float",
      "description": "Cost parameter Nu, in the range 0..1, the larger the value, the smoother the decision.",
      "default": 0.5
    }, {
      "name": "classifier.libsvm.opt",
      "type": "Boolean",
      "description": "SVM parameters optimization flag.",
      "default": "false"
    }, {
      "name": "classifier.libsvm.prob",
      "type": "Boolean",
      "description": "Probability estimation flag.",
      "default": "false"
    }, {
      "name": "classifier.boost.t",
      "type": "String",
      "description": "Type of Boosting algorithm.",
      "default": "real"
    }, {
      "name": "classifier.boost.w",
      "type": "Int",
      "description": "The number of weak classifiers.",
      "default": 100
    }, {
      "name": "classifier.boost.r",
      "type": "Float",
      "description": "A threshold between 0 and 1 used to save computational time. Samples with summary weight <= (1 - weight_trim_rate) do not participate in the next iteration of training. Set this parameter to 0 to turn off this functionality.",
      "default": 0.95
    }, {
      "name": "classifier.boost.m",
      "type": "Int",
      "description": "Maximum depth of the tree.",
      "default": 1
    }, {
      "name": "classifier.dt.max",
      "type": "Int",
      "description": "The training algorithm attempts to split each node while its depth is smaller than the maximum possible depth of the tree. The actual depth may be smaller if the other termination criteria are met, and/or if the tree is pruned.",
      "default": 10
    }, {
      "name": "classifier.dt.min",
      "type": "Int",
      "description": "If the number of samples in a node is smaller than this parameter, then this node will not be split.",
      "default": 10
    }, {
      "name": "classifier.dt.ra",
      "type": "Float",
      "description": "If all absolute differences between an estimated value in a node and the values of the train samples in this node are smaller than this regression accuracy parameter, then the node will not be split further.",
      "default": 0.01
    }, {
      "name": "classifier.dt.cat",
      "type": "Int",
      "description": "Cluster possible values of a categorical variable into K <= cat clusters to find a suboptimal split.",
      "default": 10
    }, {
      "name": "classifier.dt.r",
      "type": "Boolean",
      "description": "If true, then a pruning will be harsher. This will make a tree more compact and more resistant to the training data noise but a bit less accurate."
    }, {
      "name": "classifier.dt.t",
      "type": "Boolean",
      "description": "If true, then pruned branches are physically removed from the tree."
    }, {
      "name": "classifier.ann.t",
      "type": "String",
      "description": "Type of training method for the multilayer perceptron (MLP) neural network.",
      "default": "reg"
    }, {
      "name": "classifier.ann.sizes",
      "type": "List<String>",
      "description": "The number of neurons in each intermediate layer (excluding input and output layers).",
      "optional": "True"
    }, {
      "name": "classifier.ann.f",
      "type": "String",
      "description": "This function determine whether the output of the node is positive or not depending on the output of the transfer function.",
      "default": "sig"
    }, {
      "name": "classifier.ann.a",
      "type": "Float",
      "description": "Alpha parameter of the activation function (used only with sigmoid and gaussian functions).",
      "default": 1
    }, {
      "name": "classifier.ann.b",
      "type": "Float",
      "description": "Beta parameter of the activation function (used only with sigmoid and gaussian functions).",
      "default": 1
    }, {
      "name": "classifier.ann.bpdw",
      "type": "Float",
      "description": "Strength of the weight gradient term in the BACKPROP method. The recommended value is about 0.1.",
      "default": 0.1
    }, {
      "name": "classifier.ann.bpms",
      "type": "Float",
      "description": "Strength of the momentum term (the difference between weights on the 2 previous iterations). This parameter provides some inertia to smooth the random fluctuations of the weights. It can vary from 0 (the feature is disabled) to 1 and beyond. The value 0.1 or so is good enough.",
      "default": 0.1
    }, {
      "name": "classifier.ann.rdw",
      "type": "Float",
      "description": "Initial value Delta_0 of update-values Delta_{ij} in RPROP method (default = 0.1).",
      "default": 0.1
    }, {
      "name": "classifier.ann.rdwm",
      "type": "Float",
      "description": "Update-values lower limit Delta_{min} in RPROP method. It must be positive (default = 1e-7).",
      "default": 1e-07
    }, {
      "name": "classifier.ann.term",
      "type": "null",
      "description": "Termination criteria.",
      "default": "all"
    }, {
      "name": "classifier.ann.eps",
      "type": "Float",
      "description": "Epsilon value used in the Termination criteria.",
      "default": "0.01"
    }, {
      "name": "classifier.ann.iter",
      "type": "Int",
      "description": "Maximum number of iterations used in the Termination criteria.",
      "default": 1000
    }, {
      "name": "classifier.rf.max",
      "type": "Int",
      "description": "The depth of the tree. A low value will likely underfit and conversely a high value will likely overfit. The optimal value can be obtained using cross validation or other suitable methods.",
      "default": 5
    }, {
      "name": "classifier.rf.min",
      "type": "Int",
      "description": "If the number of samples in a node is smaller than this parameter, then the node will not be split. A reasonable value is a small percentage of the total data e.g. 1 percent.",
      "default": 10
    }, {
      "name": "classifier.rf.ra",
      "type": "Float",
      "description": "If all absolute differences between an estimated value in a node and the values of the train samples in this node are smaller than this regression accuracy parameter, then the node will not be split.",
      "default": 0
    }, {
      "name": "classifier.rf.cat",
      "type": "Int",
      "description": "Cluster possible values of a categorical variable into K <= cat clusters to find a suboptimal split.",
      "default": 10
    }, {
      "name": "classifier.rf.var",
      "type": "Int",
      "description": "The size of the subset of features, randomly selected at each tree node, that are used to find the best split(s). If you set it to 0, then the size will be set to the square root of the total number of features.",
      "default": 0
    }, {
      "name": "classifier.rf.nbtrees",
      "type": "Int",
      "description": "The maximum number of trees in the forest. Typically, the more trees you have, the better the accuracy. However, the improvement in accuracy generally diminishes and reaches an asymptote for a certain number of trees. Also to keep in mind, increasing the number of trees increases the prediction time linearly.",
      "default": 100
    }, {
      "name": "classifier.rf.acc",
      "type": "Float",
      "description": "Sufficient accuracy (OOB error).",
      "default": "0.01"
    }, {
      "name": "classifier.knn.k",
      "type": "Int",
      "description": "The number of neighbors to use.",
      "default": 32
    }, {
      "name": "classifier.sharkrf.nbtrees",
      "type": "Int",
      "description": "The maximum number of trees in the forest. Typically, the more trees you have, the better the accuracy. However, the improvement in accuracy generally diminishes and reaches an asymptote for a certain number of trees. Also to keep in mind, increasing the number of trees increases the prediction time linearly.",
      "default": 100
    }, {
      "name": "classifier.sharkrf.nodesize",
      "type": "Int",
      "description": "If the number of samples in a node is smaller than this parameter, then the node will not be split. A reasonable value is a small percentage of the total data e.g. 1 percent.",
      "default": 25
    }, {
      "name": "classifier.sharkrf.mtry",
      "type": "Int",
      "description": "The number of features (variables) which will be tested at each node in order to compute the split. If set to zero, the square root of the number of features is used.",
      "default": 0
    }, {
      "name": "classifier.sharkrf.oobr",
      "type": "Float",
      "description": "Set the fraction of the original training dataset to use as the out of bag sample.A good default value is 0.66.",
      "default": "0.66"
    }, {
      "name": "classifier.sharkkm.maxiter",
      "type": "Int",
      "description": "The maximum number of iterations for the kmeans algorithm. 0=unlimited",
      "default": 10
    }, {
      "name": "classifier.sharkkm.k",
      "type": "Int",
      "description": "The number of classes used for the kmeans algorithm. Default set to 2 class",
      "default": 2
    }, {
      "name": "classifier.sharkkm.incentroids",
      "type": "String",
      "description": "Input text file containing centroid posistions used to initialize the algorithm. Each centroid must be described by p parameters, p being the number of features in the input vector data, and the number of centroids must be equal to the number of classes (one centroid per line with values separated by spaces).",
      "optional": "False"
    }, {
      "name": "classifier.sharkkm.cstats",
      "type": "String",
      "description": "A XML file containing mean and standard deviation to centerand reduce the input centroids before the KMeans algorithm, produced by ComputeImagesStatistics application.",
      "optional": "False"
    }, {
      "name": "classifier.sharkkm.outcentroids",
      "type": "String",
      "description": "Output text file containing centroids after the kmean algorithm.",
      "optional": "False"
    }, {
      "name": "rand",
      "type": "Int",
      "description": "Set a specific random seed with integer value.",
      "optional": "False"
    }]
  },
  "Coverage.OpticalCalibrationByOTB": {
    "description": "The application allows converting pixel values from DN (for Digital Numbers) to reflectance. Calibrated values are called surface reflectivity and its values lie in the range [0, 1].The first level is called Top Of Atmosphere (TOA) reflectivity. It takes into account the sensor gain, sensor spectral response and the solar illuminations.",
    "returns": "Coverage",
    "args": [{
      "name": "input",
      "type": "Coverage",
      "description": "Input image filename",
      "optional": "True"
    }, {
      "name": "level",
      "type": "String",
      "description": "",
      "default": "toa"
    }, {
      "name": "milli",
      "type": "Boolean",
      "description": "Flag to use milli-reflectance instead of reflectance.This allows saving the image with integer pixel type (in the range [0, 1000]  instead of floating point in the range [0, 1]. In order to do that, use this option and set the output pixel type (-out filename double for example)",
      "default": "false"
    }, {
      "name": "clamp",
      "type": "Boolean",
      "description": "Clamping in the range [0, 1]. It can be useful to preserve area with specular reflectance.",
      "default": "true"
    }, {
      "name": "acquiMinute",
      "type": "Int",
      "description": "Minute (0-59)",
      "default": 0
    }, {
      "name": "acquiHour",
      "type": "Int",
      "description": "Hour (0-23)",
      "default": 12
    }, {
      "name": "acquiDay",
      "type": "Int",
      "description": "Day (1-31)",
      "default": 1
    }, {
      "name": "acquiMonth",
      "type": "Int",
      "description": "Month (1-12)",
      "default": 1
    }, {
      "name": "acquiYear",
      "type": "Int",
      "description": "Year",
      "default": 2000
    }, {
      "name": "acquiFluxnormcoeff",
      "type": "Float",
      "description": "Flux Normalization Coefficient"
    }, {
      "name": "acquiSolardistance",
      "type": "Float",
      "description": "Solar distance (in AU)"
    }, {
      "name": "acquiSunElev",
      "type": "Float",
      "description": "Sun elevation angle (in degrees)",
      "default": 90
    }, {
      "name": "acquiSunAzim",
      "type": "Float",
      "description": "Sun azimuth angle (in degrees)",
      "default": 0
    }, {
      "name": "acquiViewElev",
      "type": "Float",
      "description": "Viewing elevation angle (in degrees)",
      "default": 90
    }, {
      "name": "acquiViewAzim",
      "type": "Float",
      "description": "Viewing azimuth angle (in degrees)",
      "default": 0
    }, {
      "name": "acquiGainbias",
      "type": "String",
      "description": "A text file containing user defined gains and biases"
    }, {
      "name": "acquiSolarilluminations",
      "type": "String",
      "description": "Solar illuminations (one value per band, in W/m^2/micron)"
    }, {
      "name": "ram",
      "type": "Int",
      "description": "Available memory for processing (in MB).",
      "default": 256
    }]
  },
  "Coverage.OpticalAtmosphericByOTB": {
    "description": "The second level is called Top Of Canopy (TOC) reflectivity. In addition to sensor gain and solar illuminations, it takes into account the optical thickness of the atmosphere, the atmospheric pressure, the water vapor amount, the ozone amount, as well as the composition and amount of aerosol gasses.\nIt is also possible to indicate an AERONET file which contains atmospheric parameters (version 1 and version 2 of Aeronet file are supported. Note that computing TOC reflectivity will internally compute first TOA and then TOC reflectance.",
    "returns": "Coverage",
    "args": [{
      "name": "input",
      "type": "Coverage",
      "description": "Input image filename",
      "optional": "True"
    }, {
      "name": "acquiGainbias",
      "type": "String",
      "description": "A text file containing user defined gains and biases"
    }, {
      "name": "acquiSolarilluminations",
      "type": "String",
      "description": "Solar illuminations (one value per band, in W/m^2/micron)"
    }, {
      "name": "atmoAerosol",
      "type": "String",
      "description": "",
      "default": "noaersol"
    }, {
      "name": "atmoOz",
      "type": "Float",
      "description": "Stratospheric ozone layer content (in cm-atm)",
      "default": 0
    }, {
      "name": "atmoWa",
      "type": "Float",
      "description": "Total water vapor content over vertical atmospheric column (in g/cm2)",
      "default": 2.5
    }, {
      "name": "atmoPressure",
      "type": "Float",
      "description": "Atmospheric Pressure (in hPa)",
      "default": 1030
    }, {
      "name": "atmoOpt",
      "type": "Float",
      "description": "Aerosol Optical Thickness (unitless)",
      "default": 0.2
    }, {
      "name": "atmoAeronet",
      "type": "String",
      "description": "Aeronet file containing atmospheric parameters"
    }, {
      "name": "atmoRsr",
      "type": "String",
      "description": "Sensor relative spectral response file By default the application gets this information in the metadata"
    }, {
      "name": "atmoRadius",
      "type": "Int",
      "description": "Window radius for adjacency effects correctionsSetting this parameters will enable the correction ofadjacency effects",
      "default": 2
    }, {
      "name": "atmoPixsize",
      "type": "Float",
      "description": "Pixel size (in km) used tocompute adjacency effects, it does not have tomatch the image spacing",
      "default": 1
    },  {
      "name": "level",
      "type": "String",
      "description": "",
      "default": "toc"
    },{
      "name": "ram",
      "type": "Int",
      "description": "Available memory for processing (in MB).",
      "default": 256
    }]
  },
  "Coverage.OrthoRectificationByOTB": {
    "description": "This application uses inverse sensor modelling combined with a choice of interpolation functions to resample a sensor geometry image into a ground geometry regular grid. The ground geometry regular grid is defined with respect to a map projection (see map parameter). The application offers several modes to estimate the output grid parameters (origin and ground sampling distance), including automatic estimation of image size, ground sampling distance, or both, from image metadata, user-defined ROI corners, or another ortho-image.A digital Elevation Model along with a geoid file can be specified to account for terrain deformations.In case of SPOT5 images, the sensor model can be approximated by an RPC model in order to speed-up computation.",
    "returns": "Coverage",
    "args": [{
      "name": "ioIn",
      "type": "Coverage",
      "description": "The input image to ortho-rectify",
      "optional": "True"
    }, {
      "name": "map",
      "type": "String",
      "description": "Defines the map projection to be used.",
      "default": "utm"
    }, {
      "name": "mapUtmZone",
      "type": "Int",
      "description": "The zone number ranges from 1 to 60 and allows defining the transverse mercator projection (along with the hemisphere)",
      "default": 31
    }, {
      "name": "mapUtmNorthhem",
      "type": "Boolean",
      "description": "The transverse mercator projections are defined by their zone number as well as the hemisphere. Activate this parameter if your image is in the northern hemisphere.",
      "default": "false"
    }, {
      "name": "mapEpsgCode",
      "type": "Int",
      "description": "See www.spatialreference.org to find which EPSG code is associated to your projection",
      "default": 4326
    }, {
      "name": "outputsMode",
      "type": "String",
      "description": "User Defined|Automatic Size from Spacing|Automatic Spacing from Size|Automatic Size from Spacing and output corners|Fit to ortho",
      "default": "auto"
    }, {
      "name": "outputsUlx",
      "type": "Double",
      "description": "Cartographic X coordinate of upper-left corner (meters for cartographic projections, degrees for geographic ones)",
      "optional": "True"
    }, {
      "name": "outputsUly",
      "type": "Double",
      "description": "Cartographic Y coordinate of the upper-left corner (meters for cartographic projections, degrees for geographic ones)",
      "optional": "True"
    }, {
      "name": "outputsSizex",
      "type": "Int",
      "description": "Size of projected image along X (in pixels)",
      "optional": "True"
    }, {
      "name": "outputsSizey",
      "type": "Int",
      "description": "Size of projected image along Y (in pixels)",
      "optional": "True"
    }, {
      "name": "outputsSpacingx",
      "type": "Double",
      "description": "Size of each pixel along X axis (meters for cartographic projections, degrees for geographic ones)",
      "optional": "True"
    }, {
      "name": "outputsSpacingy",
      "type": "Double",
      "description": "Size of each pixel along Y axis (meters for cartographic projections, degrees for geographic ones)",
      "optional": "True"
    }, {
      "name": "outputsLrx",
      "type": "Double",
      "description": "Cartographic X coordinate of the lower-right corner (meters for cartographic projections, degrees for geographic ones)"
    }, {
      "name": "outputsLry",
      "type": "Double",
      "description": "Cartographic Y coordinate of the lower-right corner (meters for cartographic projections, degrees for geographic ones)"
    }, {
      "name": "outputsOrtho",
      "type": "String",
      "description": "A model ortho-image that can be used to compute size, origin and spacing of the output"
    }, {
      "name": "outputsIsotropic",
      "type": "Boolean",
      "description": "Default spacing (pixel size) values are estimated from the sensor modeling of the image. It can therefore result in a non-isotropic spacing. This option allows you to force default values to be isotropic (in this case, the minimum of spacing in both direction is applied. Values overridden by user are not affected by this option.",
      "default": "true"
    }, {
      "name": "outputsDefault",
      "type": "Double",
      "description": "Default value to write when outside of input image.",
      "default": 0
    }, {
      "name": "elevDem",
      "type": "String",
      "description": "This parameter allows selecting a directory containing Digital Elevation Model files. Note that this directory should contain only DEM files. Unexpected behaviour might occurs if other images are found in this directory. Input DEM tiles should be in a raster format supported by GDAL."
    }, {
      "name": "elevGeoid",
      "type": "String",
      "description": "Use a geoid grid to get the height above the ellipsoid in case there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles. A version of the geoid can be found on the OTB website (egm96.grd and egm96.grd.hdr at)."
    }, {
      "name": "elevDefault",
      "type": "Float",
      "description": "This parameter allows setting the default height above ellipsoid when there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles, and no geoid file has been set. This is also used by some application as an average elevation value.",
      "default": 0
    }, {
      "name": "interpolator",
      "type": "String",
      "description": "This group of parameters allows one to define how the input image will be interpolated during resampling.",
      "default": "bco"
    }, {
      "name": "interpolatorBcoRadius",
      "type": "Int",
      "description": "This parameter allows one to control the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artifacts.",
      "default": 2
    }, {
      "name": "optRpc",
      "type": "Int",
      "description": "Enabling RPC modeling allows one to speed-up SPOT5 ortho-rectification. Value is the number of control points per axis for RPC estimation",
      "default": 10
    }, {
      "name": "optRam",
      "type": "Int",
      "description": "This allows setting the maximum amount of RAM available for processing. As the writing task is time consuming, it is better to write large pieces of data, which can be achieved by increasing this parameter (pay attention to your system capabilities)",
      "default": 256
    }, {
      "name": "optGridspacing",
      "type": "Double",
      "description": "Resampling is done according to a coordinate mapping deformation grid, whose pixel size is set by this parameter, and expressed in the coordinate system of the output image The closer to the output spacing this parameter is, the more precise will be the ortho-rectified image,but increasing this parameter will reduce processing time.",
      "default": 4
    }]
  },
  "Coverage.BundleToPerfectSensorByOTB": {
    "description": "This application performs P+XS pansharpening. The default mode use Pan and XS sensor models to estimate the transformation to superimpose XS over Pan before the fusion (\u201cdefault mode\u201d). The application provides also a PHR mode for Pleiades images which does not use sensor models as Pan and XS products are already coregistered but only estimate an affine transformation to superimpose XS over the Pan.Note that this option is automatically activated in case Pleiades images are detected as input.",
    "returns": "Coverage",
    "args": [{
      "name": "inp",
      "type": "Coverage",
      "description": "Input panchromatic image.",
      "optional": "True"
    }, {
      "name": "inxs",
      "type": "Coverage",
      "description": "Input XS image.",
      "optional": "True"
    }, {
      "name": "elevDem",
      "type": "String",
      "description": "This parameter allows selecting a directory containing Digital Elevation Model files. Note that this directory should contain only DEM files. Unexpected behaviour might occurs if other images are found in this directory. Input DEM tiles should be in a raster format supported by GDAL."
    }, {
      "name": "elevGeoid",
      "type": "String",
      "description": "Use a geoid grid to get the height above the ellipsoid in case there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles. A version of the geoid can be found on the OTB website (egm96.grd and egm96.grd.hdr at)."
    }, {
      "name": "elevDefault",
      "type": "Float",
      "description": "This parameter allows setting the default height above ellipsoid when there is no DEM available, no coverage for some points or pixels with no_data in the DEM tiles, and no geoid file has been set. This is also used by some application as an average elevation value.",
      "default": 0
    }, {
      "name": "mode",
      "type": "String",
      "description": "Superimposition mode",
      "default": "default"
    }, {
      "name": "method",
      "type": "String",
      "description": "Selection of the pan-sharpening method.",
      "default": "rcs"
    }, {
      "name": "methodRcsRadiusx",
      "type": "Int",
      "description": "Set the x radius of the sliding window.",
      "default": 9
    }, {
      "name": "methodRcsRadiusy",
      "type": "Int",
      "description": "Set the y radius of the sliding window.",
      "default": 9
    }, {
      "name": "methodLmvmRadiusx",
      "type": "Int",
      "description": "Set the x radius of the sliding window.",
      "default": 3
    }, {
      "name": "methodLmvmRadiusy",
      "type": "Int",
      "description": "Set the y radius of the sliding window.",
      "default": 3
    }, {
      "name": "methodBayesLambda",
      "type": "Float",
      "description": "Set the weighting value.",
      "default": 0.9999
    }, {
      "name": "methodBayesS",
      "type": "Float",
      "description": "Set the S coefficient.",
      "default": 1
    }, {
      "name": "lms",
      "type": "Float",
      "description": "Spacing of the deformation field. Default is 10 times the PAN image spacing.",
      "default": 4
    }, {
      "name": "interpolator",
      "type": "String",
      "description": "This group of parameters allows defining how the input image will be interpolated during resampling.",
      "default": "bco"
    }, {
      "name": "interpolatorBcoRadius",
      "type": "Int",
      "description": "This parameter allows controlling the size of the bicubic interpolation filter. If the target pixel size is higher than the input pixel size, increasing this parameter will reduce aliasing artifacts.",
      "default": 2
    }, {
      "name": "fv",
      "type": "Float",
      "description": "Fill value for area outside the reprojected image",
      "default": 0
    }, {
      "name": "ram",
      "type": "Int",
      "description": "Available memory for processing (in MB).",
      "default": 256
    }]
  },

  "Coverage.gridStatisticsForPolygonsBySAGA": {
    "description": "Zonal grid statistics. For each polygon statistics based on all covered grid cells will be calculated.",
    "returns": "String",
    "args": [
      {
        "name": "grids",
        "type": "CoverageCollection",
        "description": "Grid"
      },
      {
        "name": "polygons",
        "type": "Feature",
        "description": "Polygons"
      },
      {
        "name": "fieldNaming",
        "type": "Int",
        "description": "Available Choices: [0] grid number [1] grid name Default: 1",
        "default": 1
      },
      {
        "name": "method",
        "type": "Int",
        "description": "Available Choices: [0] simple and fast [1] polygon wise (cell centers) [2] polygon wise (cell area) [3] polygon wise (cell area weighted) Default: 0",
        "optional": "True",
        "default": 0
      },
      {
        "name": "useMultipleCores",
        "type": "String",
        "description": "Default: 0",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "numberOfCells",
        "type": "String",
        "description": "PARALLELIZED Default: 1",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "minimum",
        "type": "String",
        "description": "min Default: 1",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "maximum",
        "type": "String",
        "description": "max Default: 1",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "range",
        "type": "String",
        "description": "range Default: 1",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "sum",
        "type": "String",
        "description": "Sum Default: 1",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "mean",
        "type": "String",
        "description": "Mean Default: 1",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "variance",
        "type": "String",
        "description": "Variance Default: 1",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "standardDeviation",
        "type": "String",
        "description": "Standard Deviation Default: 1",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "gini",
        "type": "String",
        "description": "Gini Default: 0",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "percentiles",
        "type": "String",
        "description": "QUANTILES Separate the desired percentiles by semicolon, e.g. \"5; 25; 50; 75; 95\""
      }
    ]
  },

  "Coverage.histogramMatchingBySAGA": {
    "description": "This tool alters the values of a grid so that its value distribution (its histogram), matches that of a reference grid. The first method simply uses arithmetic mean and standard deviation for adjustment, which usually is sufficient for normal distributed values. The second method performs a more precise adjustment based on the grids' histograms.",
    "returns": "Coverage",
    "args": [
      {
        "name": "grid",
        "type": "Coverage",
        "description": "Grid"
      },
      {
        "name": "referenceGrid",
        "type": "Coverage",
        "description": "Reference Grid"
      },
      {
        "name": "method",
        "type": "Int",
        "description": "Available Choices: [0] standard deviation [1] histogram Default: 1",
        "optional": "True",
        "default": 1
      },
      {
        "name": "nclasses",
        "type": "Int",
        "description": "Number of histogram classes for internal use.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "maxSamples",
        "type": "Int",
        "description": "If set to zero all data will be used to build the histograms.",
        "optional": "True",
        "default": 1000000
      }
    ]
  },
  "Coverage.ISODATAClusteringForGridsBySAGA": {
    "description": "This tool executes the Isodata unsupervised classification - clustering algorithm. Isodata stands for Iterative Self-Organizing Data Analysis Techniques. This is a more sophisticated algorithm which allows the number of clusters to be automatically adjusted during the iteration by merging similar clusters and splitting clusters with large standard deviations. The tool is based on Christos Iosifidis' Isodata implementation.",
    "returns": "Coverage",
    "args": [
      {
        "name": "features",
        "type": "CoverageCollection",
        "description": "grid list"
      },
      {
        "name": "normalize",
        "type": "String",
        "description": "Normalize",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "iterations",
        "type": "Int",
        "description": "Maximum Number of Iterations",
        "optional": "True",
        "default": 20
      },
      {
        "name": "clusterINI",
        "type": "Int",
        "description": "Initial Number of Clusters.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "clusterMAX",
        "type": "Int",
        "description": "Maximum Number of Clusters.",
        "optional": "True",
        "default": 16
      },
      {
        "name": "samplesMIN",
        "type": "Int",
        "description": "Minimum Number of Samples in a Cluster.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "initialize",
        "type": "String",
        "description": "Start Partition.choice tAvailable Choices: [0] random [1] periodical [2] keep values",
        "optional": "True",
        "default": "0"
      }
    ]
  },
  "Coverage.maximumlikelihoodClassificationBySAGA": {
    "description": "Standard methods for supervised image classification, including minimum distance, maximum likelihood, spectral angle mapping. Classifiers can be trained by areas defined through shapes, samples supplied as table records, or statistics previously stored to file.",
    "returns": "Coverage",
    "args": [
      {
        "name": "grids",
        "type": "Coverage",
        "description": "-"
      },
      {
        "name": "training",
        "type": "Feature",
        "description": "Training Areas"
      },
      {
        "name": "training_samples",
        "type": "Feature",
        "description": "Provide a class identifier in the first field followed by sample data corresponding to the input feature grids."
      },
      {
        "name": "normalise",
        "type": "Boolean",
        "default": 0
      },
      {
        "name": "training_class",
        "type": "String",
        "description": "-"
      },
      {
        "name": "training_with",
        "type": "Int",
        "description": "Available Choices: [0] training areas [1] training samples [2] load from file Default: 0",
        "optional": "True",
        "default": 0
      },
      {
        "name": "train_buffer",
        "type": "Float",
        "description": "For non-polygon type training areas, distance to buffer the sample area with the grid cell center.",
        "default": 1.0
      },
      {
        "name": "threshold_dist",
        "type": "Float",
        "description": "Let pixel stay unclassified, if minimum Euclidean distance is greater than threshold.",
        "default": 0.0
      },
      {
        "name": "threshold_angle",
        "type": "Float",
        "description": "Let pixel stay unclassified, if spectral angle distance is greater than threshold.",
        "default": 0.0
      },
      {
        "name": "threshold_prob",
        "type": "Float",
        "description": "Let pixel stay unclassified, if maximum likelihood probability value is less than threshold.",
        "default": 0.0
      },
      {
        "name": "file_load",
        "type": "String"
      },
      {
        "name": "relative_prob",
        "type": "Int",
        "description": "Available Choices: [0] absolute [1] relative Default: 1",
        "default": 1
      },
      {
        "name": "method",
        "type": "Int",
        "description": "-",
        "default": 4
      }
    ]
  },
  "Coverage.simpleFilterBySAGA": {
    "description": "Simple standard filters for grids.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Grid"
      },
      {
        "name": "method",
        "type": "Int",
        "optional": "True",
        "description": "choice Available Choices: [0] Smooth [1] Sharpen [2] Edge Default: 0",
        "default": 0
      },
      {
        "name": "kernelType",
        "type": "Int",
        "description": "choice Available Choices: [0] Square [1] Circle Default: 1",
        "optional": "True",
        "default": 1
      },
      {
        "name": "kernelRadius",
        "type": "Int",
        "description": "integer number Minimum: 0 Default: 2",
        "optional": "True",
        "default": 2
      }
    ]
  },
  "Coverage.minimumdistanceClassificationBySAGA": {
    "description": "Standard methods for supervised image classification, including minimum distance, maximum likelihood, spectral angle mapping. Classifiers can be trained by areas defined through shapes, samples supplied as table records, or statistics previously stored to file.",
    "returns": "Coverage",
    "args": [
      {
        "name": "grids",
        "type": "Coverage",
        "description": "-"
      },
      {
        "name": "training",
        "type": "Feature",
        "description": "Training Areas"
      },
      {
        "name": "training_samples",
        "type": "Feature",
        "description": "Provide a class identifier in the first field followed by sample data corresponding to the input feature grids."
      },
      {
        "name": "normalise",
        "type": "Boolean",
        "default": 0
      },
      {
        "name": "training_class",
        "type": "String",
        "description": "-"
      },
      {
        "name": "training_with",
        "type": "Int",
        "description": "Available Choices: [0] training areas [1] training samples [2] load from file Default: 0",
        "optional": "True",
        "default": 0
      },
      {
        "name": "train_buffer",
        "type": "Float",
        "description": "For non-polygon type training areas, distance to buffer the sample area with the grid cell center.",
        "default": 1.0
      },
      {
        "name": "threshold_dist",
        "type": "Float",
        "description": "Let pixel stay unclassified, if minimum Euclidean distance is greater than threshold.",
        "default": 0.0
      },
      {
        "name": "threshold_angle",
        "type": "Float",
        "description": "Let pixel stay unclassified, if spectral angle distance is greater than threshold.",
        "default": 0.0
      },
      {
        "name": "threshold_prob",
        "type": "Float",
        "description": "Let pixel stay unclassified, if maximum likelihood probability value is less than threshold.",
        "default": 0.0
      },
      {
        "name": "file_load",
        "type": "String"
      },
      {
        "name": "relative_prob",
        "type": "Int",
        "description": "Available Choices: [0] absolute [1] relative Default: 1",
        "default": 1
      }
    ]
  },
  "Coverage.simpleFilterBySAGA": {
    "description": "Simple standard filters for grids.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Grid"
      },
      {
        "name": "method",
        "type": "Int",
        "optional": "True",
        "description": "choice Available Choices: [0] Smooth [1] Sharpen [2] Edge Default: 0",
        "default": 0
      },
      {
        "name": "kernelType",
        "type": "Int",
        "description": "choice Available Choices: [0] Square [1] Circle Default: 1",
        "optional": "True",
        "default": 1
      },
      {
        "name": "kernelRadius",
        "type": "Int",
        "description": "integer number Minimum: 0 Default: 2",
        "optional": "True",
        "default": 2
      }
    ]
  },
  "Coverage.svmClassificationBySAGA": {
    "description": "Support Vector Machine (SVM) based classification for grids.",
    "returns": "Coverage",
    "args": [
      {
        "name": "grid",
        "type": "Coverage",
        "description": "Grid"
      },
      {
        "name": "ROI",
        "type": "Feature",
        "description": "ROI"
      },
      {
        "name": "scaling",
        "type": "Int",
        "description": "Available Choices: [0] none [1] normalize (0-1) [2] standardize",
        "optional": "True",
        "default": 2
      },
      {
        "name": "message",
        "type": "Int",
        "description": "MESSAGE",
        "optional": "True",
        "default": 0
      },
      {
        "name": "model_src",
        "type": "Int",
        "description": "Available Choices: [0] create from training areas [1] restore from file",
        "optional": "True",
        "default": 0
      },
      {
        "name": "ROI_id",
        "type": "String",
        "description": "ROI_ID",
        "optional": "True"
      },
      {
        "name": "svm_type",
        "type": "Int",
        "description": "Available Choices: [0] C-SVC [1] nu-SVC [2] one-class SVM [3] epsilon-SVR [4] nu-SVR",
        "optional": "True",
        "default": 0
      },
      {
        "name": "kernel_type",
        "type": "Int",
        "description": "linear: u'*v polynomial: (gamma*u'*v + coef0)^degree radial basis function: exp(-gamma*|u-v|^2) sigmoid: tanh(gamma*u'*v + coef0)",
        "optional": "True",
        "default": 2
      },
      {
        "name": "degree",
        "type": "Int",
        "description": "degree in kernel function",
        "optional": "True",
        "default": 3
      },
      {
        "name": "gamma",
        "type": "Float",
        "description": "degree in kernel function",
        "optional": "True",
        "default": 0.000000
      },
      {
        "name": "coef0",
        "type": "Float",
        "description": "coef0 in kernel function",
        "optional": "True",
        "default": 0.000000
      },
      {
        "name": "cost",
        "type": "Float",
        "description": "parameter C (cost) of C-SVC, epsilon-SVR, and nu-SVR",
        "optional": "True",
        "default": 1.000000
      },
      {
        "name": "nu",
        "type": "Float",
        "description": "parameter nu of nu-SVC, one-class SVM, and nu-SVR",
        "optional": "True",
        "default": 0.500000
      },
      {
        "name": "eps_svr",
        "type": "Float",
        "description": "epsilon in loss function of epsilon-SVR",
        "optional": "True",
        "default": 0.100000
      },
      {
        "name": "cache_size",
        "type": "Float",
        "description": "cache memory size in MB",
        "optional": "True",
        "default": 100.000000
      },
      {
        "name": "eps",
        "type": "Float",
        "description": "tolerance of termination criterion",
        "optional": "True",
        "default": 0.001000
      },
      {
        "name": "shrinking",
        "type": "Boolean",
        "description": "whether to use the shrinking heuristics",
        "optional": "True",
        "default": 0
      },
      {
        "name": "probability",
        "type": "Boolean",
        "description": "whether to train a SVC or SVR model for probability estimates",
        "optional": "True",
        "default": 0
      },
      {
        "name": "crossval",
        "type": "Int",
        "description": "n-fold cross validation: n must > 1",
        "optional": "True",
        "default": 1
      }
    ]
  },
  "Coverage.aspectByGDAL": {
    "description": "Generates an aspect map from any GDAL-supported elevation raster.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      },
      {
        "name": "band",
        "type": "Int",
        "description": "The number of the band to use as elevation.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "trigAngle",
        "type": "String",
        "description": "Activating the trigonometric angle results in different categories: 0° (East), 90° (North), 180° (West), 270° (South).",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "zeroFlat",
        "type": "String",
        "description": "Activating this option will insert a 0-value for the value -9999 on flat areas.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "zevenbergen",
        "type": "String",
        "description": "Activates Zevenbergen&Thorne formula for smooth landscapes.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.sieveByGDAL": {
    "description": "Removes raster polygons smaller than a provided threshold size (in pixels) and replaces them with the pixel value of the largest neighbour polygon. It is useful if you have a large amount of small areas on your raster map.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input elevation raster layer."
      },
      {
        "name": "threshold",
        "type": "Int",
        "description": "Only raster polygons smaller than this size will be removed.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "eightConnectedness",
        "type": "String",
        "description": "Use eight connectedness instead of four connectedness.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "noMask",
        "type": "String",
        "description": "Do not use the default validity mask for the input band.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "maskLayer",
        "type": "String",
        "description": "Validity mask to use instead of the default.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      }
    ]
  },

  "Coverage.contourByGDAL": {
    "description": "Extracts contour lines from any GDAL-supported elevation raster.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster."
      },
      {
        "name": "interval",
        "type": "Double",
        "description": "Defines the interval between the contour lines in the given units of the elevation raster (minimum value 0).",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "ignoreNodata",
        "type": "String",
        "description": "Ignores any nodata values in the dataset.",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options. Refer to the corresponding GDAL utility documentation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "create3D",
        "type": "String",
        "description": "Forces production of 3D vectors instead of 2D. Includes elevation at every vertex.",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "nodata",
        "type": "String",
        "description": "Defines a value that should be inserted for the nodata values in the output raster.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "offset",
        "type": "Double",
        "description": "",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Raster band to create the contours from.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "fieldName",
        "type": "String",
        "description": "Provides a name for the attribute in which to put the elevation.",
        "optional": "True",
        "default": "ELEV"
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL creation options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.demRender": {
    "description": "render the dem",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "DEM Coverage"
      }
    ]
  },

  "Coverage.contourPolygonByGDAL": {
    "description": "Extracts contour polygons from any GDAL-supported elevation raster.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster."
      },
      {
        "name": "interval",
        "type": "Double",
        "description": "Defines the interval between the contour lines in the given units of the elevation raster (minimum value 0).",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "ignoreNodata",
        "type": "String",
        "description": "Ignores any nodata values in the dataset.",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options. Refer to the corresponding GDAL utility documentation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "create3D",
        "type": "String",
        "description": "Forces production of 3D vectors instead of 2D. Includes elevation at every vertex.",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "nodata",
        "type": "String",
        "description": "Defines a value that should be inserted for the nodata values in the output raster.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "offset",
        "type": "Double",
        "description": "Defines an offset from the base contour elevation for the first contour.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Raster band to create the contours from.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "fieldNameMax",
        "type": "String",
        "description": "Provides a name for the attribute in which to put the maximum elevation of contour polygon. If not provided no maximum elevation attribute is attached.",
        "optional": "True",
        "default": "ELEV_MAX"
      },
      {
        "name": "fieldNameMin",
        "type": "String",
        "description": "Provides a name for the attribute in which to put the minimum elevation of contour polygon. If not provided no minimum elevation attribute is attached.",
        "optional": "True",
        "default": "ELEV_MIN"
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL creation options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.fillNodataByGDAL": {
    "description": "Fill raster regions with no data values by interpolation from edges.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster layer."
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "The number of pixels to search in all directions to find values to interpolate from.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "iterations",
        "type": "Double",
        "description": "The number of 3x3 filter passes to run (0 or more) to smoothen the results of the interpolation.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "maskLayer",
        "type": "String",
        "description": "A raster layer that defines the areas to fill.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "noMask",
        "type": "String",
        "description": "Activates the user-defined validity mask.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "The band to operate on. Nodata values must be represented by the value 0.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridAverageByGDAL": {
    "description": "The Moving Average is a simple data averaging algorithm.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "minPoints",
        "type": "Double",
        "description": "Minimum number of data points to average. If less amount of points found the grid node considered empty and will be filled with NODATA marker.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Angle of ellipse rotation in degrees. Ellipse rotated counter clockwise.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "AField for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "radius2",
        "type": "Double",
        "description": "The second radius (Y axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "radius1",
        "type": "Double",
        "description": "The first radius (X axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridDataMetricsByGDAL": {
    "description": "Computes some data metrics using the specified window and output grid geometry.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "minPoints",
        "type": "Double",
        "description": "Minimum number of data points to average.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "metric",
        "type": "String",
        "description": "Data metric to use.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Angle of ellipse rotation in degrees. Ellipse rotated counter clockwise.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "Field for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Output data type.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "radius2",
        "type": "Double",
        "description": "The second radius (Y axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "radius1",
        "type": "Double",
        "description": "The first radius (X axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created (colors, block size, file compression...).",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridInverseDistanceByGDAL": {
    "description": "The Inverse Distance to a Power gridding method is a weighted average interpolator.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "power",
        "type": "Double",
        "description": "Weighting power.",
        "optional": "True",
        "default": 2.0
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Angle of ellipse rotation in degrees. Ellipse rotated counter clockwise.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "radius2",
        "type": "Double",
        "description": "The second radius (Y axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "radius1",
        "type": "Double",
        "description": "The first radius (X axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "smoothing",
        "type": "Double",
        "description": "Smoothing parameter.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "maxPoints",
        "type": "Double",
        "description": "Do not search for more points than this number.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "minPoints",
        "type": "Double",
        "description": "Minimum number of data points to average. If less amount of points found the grid node considered empty and will be filled with NODATA marker.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "Field for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridInverseDistanceNNRByGDAL": {
    "description": "Computes the Inverse Distance to a Power gridding combined to the nearest neighbor method.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "power",
        "type": "Double",
        "description": "Weighting power.",
        "optional": "True",
        "default": 2.0
      },
      {
        "name": "radius",
        "type": "Double",
        "description": "The radius of the search circle.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "smoothing",
        "type": "Double",
        "description": "Smoothing parameter.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "maxPoints",
        "type": "Double",
        "description": "Do not search for more points than this number.",
        "optional": "True",
        "default": 12
      },
      {
        "name": "minPoints",
        "type": "Double",
        "description": "Minimum number of data points to average. If less amount of points found the grid node considered empty and will be filled with NODATA marker.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "Field for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridLinearByGDAL": {
    "description": "The Linear method perform linear interpolation by computing a Delaunay triangulation of the point cloud, finding in which triangle of the triangulation the point is, and by doing linear interpolation from its barycentric coordinates within the triangle.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "radius",
        "type": "Double",
        "description": "In case the point to be interpolated does not fit into a triangle of the Delaunay triangulation, use that maximum distance to search a nearest neighbour, or use nodata otherwise. If set to -1, the search distance is infinite. If set to 0, no data value will be used.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "Field for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.gridNearestNeighborByGDAL": {
    "description": "The Nearest Neighbor method doesn’t perform any interpolation or smoothing, it just takes the value of nearest point found in grid node search ellipse and returns it as a result.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input point vector layer."
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "No data marker to fill empty points.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "angle",
        "type": "Double",
        "description": "Angle of ellipse rotation in degrees. Ellipse rotated counter clockwise.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "radius1",
        "type": "Double",
        "description": "The first radius (X axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "radius2",
        "type": "Double",
        "description": "The second radius (Y axis if rotation angle is 0) of the search ellipse.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "zField",
        "type": "String",
        "description": "Field for the interpolation.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.hillShadeByGDAL": {
    "description": "Outputs a raster with a nice shaded relief effect. It’s very useful for visualizing the terrain.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "combined",
        "type": "String",
        "description": "",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Band containing the elevation information.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "altitude",
        "type": "Double",
        "description": "Defines the altitude of the light, in degrees. 90 if the light comes from above the elevation raster, 0 if it is raking light.",
        "optional": "True",
        "default": 45.0
      },
      {
        "name": "zevenbergenThorne",
        "type": "String",
        "description": "Activates Zevenbergen&Thorne formula for smooth landscapes.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "zFactor",
        "type": "Double",
        "description": "The factor exaggerates the height of the output elevation raster.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "multidirectional",
        "type": "String",
        "description": "",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "scale",
        "type": "Double",
        "description": "The ratio of vertical units to horizontal units.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "azimuth",
        "type": "Double",
        "description": "Defines the azimuth of the light shining on the elevation raster in degrees. If it comes from the top of the raster the value is 0, if it comes from the east it is 90 a.s.o.",
        "optional": "True",
        "default": 315.0
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.nearBlackByGDAL": {
    "description": "Converts nearly black/white borders to black.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "white",
        "type": "String",
        "description": "Search for nearly white (255) pixels instead of nearly black pixels.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "near",
        "type": "Int",
        "description": "Select how far from black, white or custom colors the pixel values can be and still considered near black, white or custom color.",
        "optional": "True",
        "default": 15
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.proximityByGDAL": {
    "description": "Generates a raster proximity map indicating the distance from the center of each pixel to the center of the nearest pixel identified as a target pixel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "Specify the nodata value to use for the output raster.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "values",
        "type": "String",
        "description": "A list of target pixel values in the source image to be considered target pixels.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Band containing the elevation information.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "maxDistance",
        "type": "Double",
        "description": "The maximum distance to be generated.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "replace",
        "type": "Double",
        "description": "Specify a value to be applied to all pixels that are closer than the maximum distance from target pixels (including the target pixels) instead of a distance value.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "units",
        "type": "String",
        "description": "Indicate whether distances generated should be in pixel or georeferenced coordinates.",
        "optional": "True",
        "default": "1"
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.roughnessByGDAL": {
    "description": "Outputs a single-band raster with values computed from the elevation.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Band containing the elevation information.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.slopeByGDAL": {
    "description": "Generates a slope map from any GDAL-supported elevation raster.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "Band containing the elevation information.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "asPercent",
        "type": "String",
        "description": "Express slope as percent instead of degrees.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Additional GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "scale",
        "type": "Double",
        "description": "The ratio of vertical units to horizontal units.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "zevenbergen",
        "type": "String",
        "description": "Activates Zevenbergen&Thorne formula for smooth landscapes",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL command line options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.tpiTopographicPositionIndexByGDAL": {
    "description": "Outputs a single-band raster with values computed from the elevation. TPI stands for Topographic Position Index, which is defined as the difference between a central pixel and the mean of its surrounding cells.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "The number of the band to use for elevation values",
        "optional": "True",
        "default": 1
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL command line options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.triTerrainRuggednessIndexByGDAL": {
    "description": "Outputs a single-band raster with values computed from the elevation. TRI stands for Terrain Ruggedness Index, which is defined as the mean difference between a central pixel and its surrounding cells.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "The number of the band to use for elevation values",
        "optional": "True",
        "default": 1
      },
      {
        "name": "computeEdges",
        "type": "String",
        "description": "Generates edges from the elevation raster.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created (colors, block size, file compression...).",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.clipRasterByExtentByGDAL": {
    "description": "Clips any GDAL-supported raster file to a given extent.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster."
      },
      {
        "name": "projwin",
        "type": "String",
        "description": "",
        "optional": "True",
        "default": ""
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "Defines a value that should be inserted for the nodata values in the output raster.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the format of the output raster file.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.clipRasterByMaskLayerByGDAL": {
    "description": "Clips any GDAL-supported raster by a vector mask layer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input Elevation raster layer"
      },
      {
        "name": "mask",
        "type": "Feature",
        "description": "Vector mask for clipping the raster."
      },
      {
        "name": "cropToCutLine",
        "type": "String",
        "description": "Applies the vector layer extent to the output raster if checked.",
        "optional": "True",
        "default": "True"
      },
      {
        "name": "targetExtent",
        "type": "String",
        "description": "Extent of the output file to be created.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "setResolution",
        "type": "String",
        "description": "Shall the output resolution (cell size) be specified.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "targetCrs",
        "type": "String",
        "description": "Set the coordinate reference to use for the mask layer.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "keepResolution",
        "type": "String",
        "description": "The resolution of the output raster will not be changed.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "alphaBand",
        "type": "String",
        "description": "Creates an alpha band for the result. The alpha band then includes the transparency values of the pixels.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "multithreading",
        "type": "String",
        "description": "Two threads will be used to process chunks of image and perform input/output operation simultaneously. Note that computation is not multithreaded itself.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the format of the output raster file.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "sourceCrs",
        "type": "String",
        "description": "Set the coordinate reference to use for the input raster.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.polygonizeByGDAL": {
    "description": "Creates vector polygons for all connected regions of pixels in the raster sharing a common pixel value. Each polygon is created with an attribute indicating the pixel value of that polygon.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster layer"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options",
        "optional": "True",
        "default": ""
      },
      {
        "name": "field",
        "type": "String",
        "description": "Specify the field name for the attributes of the connected regions.",
        "optional": "True",
        "default": "DN"
      },
      {
        "name": "band",
        "type": "Int",
        "description": "If the raster is multiband, choose the band you want to use",
        "optional": "True",
        "default": 1
      },
      {
        "name": "eightConnectedness",
        "type": "String",
        "description": "If not set, raster cells must have a common border to be considered connected (4-connected). If set, touching raster cells are also considered connected (8-connected).",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Coverage.rasterizeOverByGDAL": {
    "description": "Overwrites a raster layer with values from a vector layer. New values are assigned based on the attribute value of the overlapping vector feature.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "inputRaster",
        "type": "Coverage",
        "description": "Input raster layer"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options",
        "optional": "True",
        "default": ""
      },
      {
        "name": "field",
        "type": "String",
        "description": "Defines the attribute field to use to set the pixels values",
        "optional": "True",
        "default": ""
      },
      {
        "name": "add",
        "type": "String",
        "description": "If False, pixels are assigned the selected field’s value. If True, the selected field’s value is added to the value of the input raster layer.",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Feature.rasterizeOverFixedValueByGDAL": {
    "description": "Overwrites parts of a raster layer with a fixed value. The pixels to overwrite are chosen based on the supplied (overlapping) vector layer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "inputRaster",
        "type": "Coverage",
        "description": "Input raster layer"
      },
      {
        "name": "burn",
        "type": "Double",
        "description": "The value to burn",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options",
        "optional": "True",
        "default": ""
      },
      {
        "name": "add",
        "type": "String",
        "description": "If False, pixels are assigned the selected field’s value. If True, the selected field’s value is added to the value of the input raster layer.",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Coverage.rgbToPctByGDAL": {
    "description": "Converts a 24 bit RGB image into a 8 bit paletted.Computes an optimal pseudo-color table for the given RGB-image using a median cut algorithm on a downsampled RGB histogram.Then it converts the image into a pseudo-colored image using the color table.This conversion utilizes Floyd-Steinberg dithering (error diffusion) to maximize output image visual quality.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input (RGB) raster layer"
      },
      {
        "name": "ncolors",
        "type": "Double",
        "description": "The number of colors the resulting image will contain. A value from 2-256 is possible.",
        "optional": "True",
        "default": 2
      }
    ]
  },
  "Coverage.translateByGDAL": {
    "description": "Converts raster data between different formats.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster layer"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Additional GDAL command line options",
        "optional": "True",
        "default": ""
      },
      {
        "name": "targetCrs",
        "type": "String",
        "description": "Specify a projection for the output file",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "nodata",
        "type": "Double",
        "description": "Defines the value to use for nodata in the output raster",
        "optional": "True",
        "default": 0
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the data type of the output raster file.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "copySubdatasets",
        "type": "String",
        "description": "Create individual files for subdatasets",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.warpByGDAL": {
    "description": "Reprojects a raster layer into another Coordinate Reference System (CRS). The output file resolution and the resampling method can be chosen.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Input raster layer to reproject"
      },
      {
        "name": "sourceCrs",
        "type": "String",
        "description": "Defines the CRS of the input raster layer",
        "optional": "True",
        "default": ""
      },
      {
        "name": "targetCrs",
        "type": "String",
        "description": "The CRS of the output layer",
        "optional": "True",
        "default": "EPSG:4326"
      },
      {
        "name": "resampling",
        "type": "String",
        "description": "Pixel value resampling method to use. Options:0 — Nearest neighbour 1 — Bilinear 2 — Cubic 3 — Cubic spline 4 — Lanczos windowed sinc 5 — Average 6 — Mode 7 — Maximum 8 — Minimum 9 — Median 10 — First quartile 11 — Third quartile",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "noData",
        "type": "Double",
        "description": "Sets nodata value for output bands. If not provided, then nodata values will be copied from the source dataset.",
        "optional": "True",
        "default": "not set"
      },
      {
        "name": "targetResolution",
        "type": "Double",
        "description": "Defines the output file resolution of reprojection result",
        "optional": "True",
        "default": "not set"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dataType",
        "type": "String",
        "description": "Defines the format of the output raster file.",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "targetExtent",
        "type": "String",
        "description": "Sets the georeferenced extent of the output file to be created",
        "optional": "True",
        "default": ""
      },
      {
        "name": "targetExtentCrs",
        "type": "String",
        "description": "Specifies the CRS in which to interpret the coordinates given for the extent of the output file. This must not be confused with the target CRS of the output dataset. It is instead a convenience e.g. when knowing the output coordinates in a geodetic long/lat CRS, but wanting a result in a projected coordinate system.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "multiThreading",
        "type": "String",
        "description": "Two threads will be used to process chunks of the image and perform input/output operations simultaneously. Note that the computation itself is not multithreaded.",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "extra",
        "type": "String",
        "description": "Add extra GDAL command line options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.assignProjectionByGDAL": {
    "description": "Clips any OGR-supported vector file to a given extent.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The input vector file"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "The projection (CRS) of the output layer.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.dissolveByGDAL": {
    "description": "Dissolve (combine) geometries that have the same value for a given attribute / field. The output geometries are multipart.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The input layer to dissolve"
      },
      {
        "name": "explodeCollections",
        "type": "String",
        "description": "Produce one feature for each geometry in any kind of geometry collection in the source file",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "field",
        "type": "String",
        "description": "The field of the input layer to use for dissolving",
        "optional": "True",
        "default": ""
      },
      {
        "name": "computeArea",
        "type": "String",
        "description": "Compute the area and perimeter of dissolved features and include them in the output layer",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "keepAttributes",
        "type": "String",
        "description": "Keep all attributes from the input layer",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "computeStatistics",
        "type": "String",
        "description": "Calculate statistics (min, max, sum and mean) for the numeric attribute specified and include them in the output layer",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "countFeatures",
        "type": "String",
        "description": "Count the dissolved features and include it in the output layer.",
        "optional": "True",
        "default": "false"
      },
      {
        "name": "statisticsAttribute",
        "type": "String",
        "description": "The numeric attribute to calculate statistics on",
        "optional": "True",
        "default": ""
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL creation options.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "geometry",
        "type": "String",
        "description": "The name of the input layer geometry column to use for dissolving.",
        "optional": "True",
        "default": "geometry"
      }
    ]
  },
  "Feature.clipVectorByExtentByGDAL": {
    "description": "Clips any OGR-supported vector file to a given extent.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The input vector file"
      },
      {
        "name": "extent",
        "type": "String",
        "description": "Defines the bounding box that should be used for the output vector file. It has to be defined in target CRS coordinates.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the raster to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.clipVectorByPolygonByGDAL": {
    "description": "Clips any OGR-supported vector layer by a mask polygon layer.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The input vector file"
      },
      {
        "name": "mask",
        "type": "Feature",
        "description": "Layer to be used as clipping extent for the input vector layer.",
        "optional": "True",
        "default": ""
      },
      {
        "name": "options",
        "type": "String",
        "description": "Additional GDAL creation options.",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.offsetCurveByGDAL": {
    "description": "Offsets lines by a specified distance. Positive distances will offset lines to the left, and negative distances will offset them to the right.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "The offset distance",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "geometry",
        "type": "String",
        "description": "The name of the input layer geometry column to use",
        "optional": "True",
        "default": "geometry"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the vector layer to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.pointsAlongLinesByGDAL": {
    "description": "Offsets lines by a specified distance. Positive distances will offset lines to the left, and negative distances will offset them to the right.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "The distance from the start of the line",
        "optional": "True",
        "default": 0.5
      },
      {
        "name": "geometry",
        "type": "String",
        "description": "The name of the input layer geometry column to use",
        "optional": "True",
        "default": "geometry"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the vector layer to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.bufferVectorsByGDAL": {
    "description": "Offsets lines by a specified distance. Positive distances will offset lines to the left, and negative distances will offset them to the right.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "The distance",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "explodeCollections",
        "type": "String",
        "description": "",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "field",
        "type": "String",
        "description": "Field to use for dissolving",
        "optional": "True",
        "default": ""
      },
      {
        "name": "dissolve",
        "type": "String",
        "description": "If set, the result is dissolved. If no field is set for dissolving",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "geometry",
        "type": "String",
        "description": "The name of the input layer geometry column to use",
        "optional": "True",
        "default": "geometry"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the vector layer to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Feature.oneSideBufferByGDAL": {
    "description": "Offsets lines by a specified distance. Positive distances will offset lines to the left, and negative distances will offset them to the right.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "Input vector layer"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "The distance",
        "optional": "True",
        "default": 10.0
      },
      {
        "name": "explodeCollections",
        "type": "String",
        "description": "",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "field",
        "type": "String",
        "description": "Field to use for dissolving",
        "optional": "True",
        "default": ""
      },
      {
        "name": "bufferSide",
        "type": "String",
        "description": "0: Right, 1: Left",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "dissolve",
        "type": "String",
        "description": "If set, the result is dissolved. If no field is set for dissolving",
        "optional": "True",
        "default": "False"
      },
      {
        "name": "geometry",
        "type": "String",
        "description": "The name of the input layer geometry column to use",
        "optional": "True",
        "default": "geometry"
      },
      {
        "name": "options",
        "type": "String",
        "description": "For adding one or more creation options that control the vector layer to be created",
        "optional": "True",
        "default": ""
      }
    ]
  },
  "Coverage.neighborsByGrass": {
    "description": "Makes each cell category value a function of the category values assigned to the cells around it,and stores new cell values in an output raster map layers.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "size",
        "type": "String",
        "description": "Neighborhood size",
        "optional": "True",
        "default": "3"
      },
      {
        "name": "method",
        "type": "String",
        "description": "Neighborhood operation    Options: average, median, mode, minimum , maximum, range, stddev, sum, count variance,diversity, nterspersion,quart1,quart3,perc90,quantile",
        "optional": "True",
        "default": "average"
      }
    ]
  },
  "Coverage.bufferByGrass": {
    "description": "Creates a raster map showing buffer zones surrounding cells that contain non-NULL category values.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map."
      },
      {
        "name": "distances",
        "type": "String",
        "description": "Distance zone(s)"
      },
      {
        "name": "unit",
        "type": "String",
        "description": "Units of distance    Options: meters, kilometers, feet,miles, nautmiles",
        "optional": "True",
        "default": "meters"
      }
    ]
  },
  "Coverage.crossByGrass": {
    "description": "Creates a cross product of the category values from multiple raster map layers.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "Names of 2-30 input raster maps"
      }
    ]
  },
  "Coverage.patchByGrass": {
    "description": "Creates a composite raster map layer by using known category values from one(or more) map layer(s) to fill in areas of 'no data' in another map layer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "Name of raster maps to be patched together"
      }
    ]
  },
  "Coverage.latlongByGrass": {
    "description": "Creates a latitude/longitude raster map.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      }
    ]
  },
  "Coverage.blendByGrass": {
    "description": "Blends color components of two raster maps by a given ratio.",
    "returns": "Coverage",
    "args": [
      {
        "name": "first",
        "type": "Coverage",
        "description": "Name of first raster map for blending"
      },
      {
        "name": "second",
        "type": "Coverage",
        "description": "Name of second raster map for blending"
      },
      {
        "name": "percent",
        "type": "String",
        "description": "Percentage weight of first map for color blending   Options: 0-100",
        "optional": "True",
        "default": "50"
      }
    ]
  },
  "Coverage.compositeByGrass": {
    "description": "Combines red, green and blue raster maps into a single composite raster map.",
    "returns": "Coverage",
    "args": [
      {
        "name": "red",
        "type": "Coverage",
        "description": "Name of raster map to be used for <red>"
      },
      {
        "name": "green",
        "type": "Coverage",
        "description": "Name of raster map to be used for <green>"
      },
      {
        "name": "blue",
        "type": "Coverage",
        "description": "Name of raster map to be used for <blue>"
      },
      {
        "name": "levels",
        "type": "String",
        "description": "Number of levels to be used for each component        Options: 1-256",
        "optional": "True",
        "default": "32"
      }
    ]
  },
  "Coverage.sunmaskByGrass": {
    "description": "Calculates cast shadow areas from sun position and elevation raster map.",
    "returns": "Coverage",
    "args": [
      {
        "name": "elevation",
        "type": "Coverage",
        "description": "Name of input elevation raster map"
      },
      {
        "name": "year",
        "type": "String",
        "description": "Year (B)    Options: 1950-2050"
      },
      {
        "name": "month",
        "type": "String",
        "description": "Month (B)    Options:0-12"
      },
      {
        "name": "day",
        "type": "String",
        "description": "Day (B)    Options:0-31"
      },
      {
        "name": "hour",
        "type": "String",
        "description": "Hour (B)    Options:0-24"
      },
      {
        "name": "minute",
        "type": "String",
        "description": "Minute (B)    Options:0-60"
      },
      {
        "name": "second",
        "type": "String",
        "description": "Second (B)    Options:0-60",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "timezone",
        "type": "String",
        "description": "East positive, offset from GMT, also use to adjust daylight savings"
      }
    ]
  },
  "Coverage.resampStatsByGrass": {
    "description": "Resamples raster map layers to a coarser grid using aggregation",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "res",
        "type": "String",
        "description": "New resolution ratio after resampling"
      },
      {
        "name": "method",
        "type": "String",
        "description": "Aggregation method",
        "optional": "True",
        "default": "average"
      },
      {
        "name": "quantile",
        "type": "String",
        "description": "Quantile to calculate for method=quantile Options: 0.0-1.0 ",
        "optional": "True",
        "default": "0.5"
      }
    ]
  },
  "Coverage.resampInterpByGrass": {
    "description": "Resamples raster map to a finer grid using interpolation",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "res",
        "type": "String",
        "description": "New resolution ratio after resampling"
      },
      {
        "name": "method",
        "type": "String",
        "description": "Sampling interpolation method Options: nearest, bilinear, bicubic, lanczos",
        "optional": "True",
        "default": "bilinear"
      }
    ]
  },
  "Coverage.resampBsplineByGrass": {
    "description": "Performs bilinear or bicubic spline interpolation with Tykhonov regularization.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "res",
        "type": "String",
        "description": "New resolution ratio after resampling"
      },
      {
        "name": "method",
        "type": "String",
        "description": "Spline interpolation algorithm Options: bilinear, bicubic",
        "optional": "True",
        "default": "bicubic"
      }
    ]
  },
  "Coverage.resampFilterByGrass": {
    "description": "Resamples raster map layers using an analytic kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "res",
        "type": "String",
        "description": "New resolution ratio after resampling"
      },
      {
        "name": "filter",
        "type": "String",
        "description": "Filter kernel(s) Options: box, bartlett, gauss, normal, hermite, sinc, lanczos1, lanczos2, lanczos3, hann, hamming, blackman"
      },
      {
        "name": "radius",
        "type": "String",
        "description": "Filter radius"
      }
    ]
  },
  "Coverage.resampleByGrass": {
    "description": "GRASS raster map layer data resampling capability. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "res",
        "type": "String",
        "description": "New resolution ratio after resampling"
      }
    ]
  },
  "Coverage.textureByGrass": {
    "description": " Generate images with textural features from a raster map.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "size",
        "type": "String",
        "description": "The size of moving window (odd and >= 3)",
        "optional": "True",
        "default": "3"
      },
      {
        "name": "distance",
        "type": "String",
        "description": "The distance between two samples (>= 1) The distance must be smaller than the size of the moving window",
        "optional": "True",
        "default": "1"
      },
      {
        "name": "method",
        "type": "String",
        "description": "Textural measurement method Options: asm, contrast, corr, var, idm, sa, sv, se, entr, dv, de, moc1, moc2 "
      }
    ]
  },
  "Coverage.viewshedByGrass": {
    "description": " Computes the viewshed of a point on an elevation raster map.                       Default format: NULL (invisible), vertical angle wrt viewpoint (visible). ",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "coordinates",
        "type": "String",
        "description": "Coordinates of viewing position"
      },
      {
        "name": "observer_elevation",
        "type": "String",
        "description": "Viewing elevation above the ground ",
        "optional": "True",
        "default": "1.75"
      },
      {
        "name": "target_elevation",
        "type": "String",
        "description": "Offset for target elevation above the ground",
        "optional": "True",
        "default": "0.0"
      },
      {
        "name": "max_distance",
        "type": "String",
        "description": "Maximum visibility radius. By default infinity (-1) ",
        "optional": "True",
        "default": "-1"
      },
      {
        "name": "refraction_coeff",
        "type": "String",
        "description": "Refraction coefficient Options: 0.0-1.0 ",
        "optional": "True",
        "default": "0.14286"
      }
    ]
  },
  "Coverage.shadeByGrass": {
    "description": "Drapes a color raster over an shaded relief or aspect map. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "shade",
        "type": "Coverage",
        "description": "Name of shaded relief or aspect raster map "
      },
      {
        "name": "color",
        "type": "Coverage",
        "description": "Name of raster to drape over relief raster map Typically, this raster is elevation or other colorful raster"
      },
      {
        "name": "brighten",
        "type": "String",
        "description": "Percent to brighten Options: -99-99 ",
        "optional": "True",
        "default": "0"
      }
    ]
  },
  "Coverage.surfIdwByGrass": {
    "description": "Provides surface interpolation from raster point data by Inverse Distance Squared Weighting.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "npoints",
        "type": "String",
        "description": "Number of interpolation points",
        "optional": "True",
        "default": "12"
      }
    ]
  },
  "Coverage.rescaleByGrass": {
    "description": "Rescales the range of category values in a raster map layer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The name of the raster map to be rescaled"
      },
      {
        "name": "to",
        "type": "String",
        "description": "The output data range"
      }
    ]
  },
  "Coverage.surfAreaByGrass": {
    "description": "Prints estimation of surface area for raster map.",
    "returns": "String",
    "args": [
      {
        "name": "map",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "vscale",
        "type": "String",
        "description": "Vertical scale",
        "optional": "True",
        "default": "1.0"
      }
    ]
  },
  "Coverage.statsByGrass": {
    "description": "Generates area statistics for raster map.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of raster map to report on"
      },
      {
        "name": "flags",
        "type": "String",
        "description": "select statistics data [-acpl1gxArnNCi]"
      },
      {
        "name": "separator",
        "type": "String",
        "description": "Field separator Special characters: pipe, comma, space, tab, newline",
        "optional": "True",
        "default": "space"
      },
      {
        "name": "null_value",
        "type": "String",
        "description": "String representing NULL value",
        "optional": "True",
        "default": "*"
      },
      {
        "name": "nsteps",
        "type": "String",
        "description": "Number of floating-point subranges to collect stats from ",
        "optional": "True",
        "default": "255"
      }
    ]
  },
  "Coverage.coinByGrass": {
    "description": "Tabulates the mutual occurrence (coincidence) of categories for two raster map layers.",
    "returns": "String",
    "args": [
      {
        "name": "first",
        "type": "Coverage",
        "description": "Name of first raster map"
      },
      {
        "name": "second",
        "type": "Coverage",
        "description": "Name of second raster map"
      },
      {
        "name": "units",
        "type": "String",
        "description": "Unit of measure c(ells), p(ercent), x(percent of category [column]), y(percent of category [row]), a(cres) h(ectares), k(square kilometers), m(square miles)Options: c,p,x,y,a,h,k,m"
      }
    ]
  },
  "Coverage.volumeByGrass": {
    "description": "Calculates the volume of data 'clumps'.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map representing data that will be summed within clumps"
      },
      {
        "name": "clump",
        "type": "Coverage",
        "description": "Name of input clump raster map"
      }
    ]
  },
  "Coverage.outPNGByGrass": {
    "description": "Export a GRASS raster map as a non-georeferenced PNG image.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "compression",
        "type": "String",
        "description": "Compression level of PNG file(0= none,1 = fastest, 9 = best)Options: O-9",
        "optional": "True",
        "default": "6"
      }
    ]
  },
  "Coverage.reclassByGrass": {
    "description": "Reclassify raster map based on category values.Creates a new raster map whose category values are based upon a reclassification of the categories in an existing raster map. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of raster map to be reclassified"
      },
      {
        "name": "rules",
        "type": "Coverage",
        "description": "File containing reclass rules '-' for standard input"
      }
    ]
  },
  "Coverage.reportByGrass": {
    "description": " Reports statistics for raster maps. ",
    "returns": "String",
    "args": [
      {
        "name": "map",
        "type": "Coverage",
        "description": "Name of raster map to report on"
      }
    ]
  },
  "Coverage.supportStatsByGrass": {
    "description": "Update raster map statistics",
    "returns": "String",
    "args": [
      {
        "name": "map",
        "type": "Coverage",
        "description": "Name of raster map"
      }
    ]
  },
  "Coverage.outDdalByGrass": {
    "description": " Exports GRASS raster maps into GDAL supported formats. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of raster map (or group) to export "
      },
      {
        "name": "format",
        "type": "String",
        "description": "Raster data format to write (case sensitive, see also -l flag) Options: VRT, GTiff, COG, NITF, HFA, ELAS, AAIGrid, DTED, PNG, JPEG, MEM, GIF, XPM, BMP, PCIDSK, PCRaster, ILWIS, SGI, SRTMHGT, Leveller, Terragen, netCDF, HDF4Image, ISIS3, ISIS2, PDS4, VICAR, ERS, ECW, JP2ECW, JP2OpenJPEG, FIT, GRIB, RMF, WMS, RST, GSAG, GSBG, GS7BG, R, KMLSUPEROVERLAY, WEBP, PDF, Rasterlite, MBTiles, CALS, WMTS, MRF, PNM, PAux, MFF, MFF2, BT, LAN, LCP, GTX, NTv2, CTable2, KRO, ROI_PAC, RRASTER, BYN, ARG, USGSDEM, NWT_GRD, ADRG, BLX, PostGISRaster, SAGA, XYZ, HF2, ZMap, SIGDEM, GPKG, NGW, ENVI, EHdr, ISCE, Zarr ",
        "optional": "True",
        "default": "GTiff"
      }
    ]
  },
  "Coverage.outBinByGrass": {
    "description": " Exports a GRASS raster to a binary array.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map"
      },
      {
        "name": "nu_ll",
        "type": "String",
        "description": "Value to write out for null ",
        "optional": "True",
        "default": "0"
      },
      {
        "name": "bytes",
        "type": "String",
        "description": "Number of bytes per cell Options: 1, 2, 4, 8 "
      },
      {
        "name": "order",
        "type": "String",
        "description": "Output byte order \nOptions: big, little, native, swap ",
        "optional": "True",
        "default": "native"
      }
    ]
  },
  "Coverage.inGdalByGrass": {
    "description": " Imports raster data into a GRASS raster map using GDAL library. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of raster file to be imported "
      },
      {
        "name": "band",
        "type": "String",
        "description": "Band(s) to select (default is all bands) "
      },
      {
        "name": "location",
        "type": "String",
        "description": "Name for new location to create "
      }
    ]
  },
  "Coverage.gorwByGrass": {
    "description": " Generates a raster map layer with contiguous areas grown by one cell.  ",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map. "
      }
    ]
  },
  "Coverage.fillnullByGrass": {
    "description": " Fills no-data areas in raster maps using spline interpolation. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map. "
      }
    ]
  },
  "Coverage.randomByGrass": {
    "description": "Creates randomly placed raster cells or vector points.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map "
      },
      {
        "name": "npoints",
        "type": "String",
        "description": "The number(%) of points/cells to generate."
      }
    ]
  },
  "Coverage.univarByGrass": {
    "description": "Calculate univariate statistics from the non-null cells of a raster map.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "Name of input raster map "
      }
    ]
  },
  "Kernel.fixed": {
    "description": "Creates a Kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "weights",
        "type": "List<List<Double>>",
        "description": "A 2-D list to use as the weights of the kernel."
      }
    ]
  },
  "Kernel.square": {
    "description": "Generates a square-shaped boolean kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "value",
        "type": "Double",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.prewitt": {
    "description": "Generates a 3x3 Prewitt edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.kirsch": {
    "description": "Generates a 3x3 kirsch edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.sobel": {
    "description": "Generates a 3x3 sobel edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "axis",
        "type": "String",
        "description": "Specify the direction of the convolution kernel,x/y."
      }
    ]
  },
  "Kernel.roberts": {
    "description": "Generates a 2x2 robert edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.rotate": {
    "description": "Rotate the kernel according to the rotations.",
    "returns": "Kernel",
    "args": [
      {
        "name": "kernel",
        "type": "Kernel",
        "description": "The kernel to be rotated."
      },
      {
        "name": "rotations",
        "type": "Int",
        "description": "Rotations to make (negative numbers rotate counterclockwise)."
      }
    ]
  },
  "Kernel.chebyshev": {
    "description": "Generates a distance kernel based on Chebyshev distance (greatest distance along any dimension).",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.circle": {
    "description": "Generates a circle-shaped boolean kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.compass": {
    "description": "Generates a 3x3 Prewitt's Compass edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.diamond": {
    "description": "Generates a diamond-shaped boolean kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.euclidean": {
    "description": "Generates a distance kernel based on Euclidean (straight-line) distance.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.gaussian": {
    "description": "Generates a Gaussian kernel from a sampled continuous Gaussian.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "sigma",
        "type": "Float",
        "description": "Standard deviation of the Gaussian function (same units as radius)."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.manhattan": {
    "description": "Generates a distance kernel based on rectilinear (city-block) distance.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.octagon": {
    "description": "Generates an octagon-shaped boolean kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.plus": {
    "description": "Generates a rectangular-shaped kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.rectangle": {
    "description": "Generates a plus-shaped boolean kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "xRadius",
        "type": "Int",
        "description": "The horizontal radius of the kernel to generate."
      },
      {
        "name": "yRadius",
        "type": "Int",
        "description": "The vertical radius of the kernel to generate."
      },
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      },
      {
        "name": "magnitude",
        "type": "Float",
        "description": "Scale each value by this amount."
      }
    ]
  },
  "Kernel.laplacian4": {
    "description": "Generates a 3x3 laplacian-4 edge-detection kernel.",
    "returns": "Kernel",
    "args": []
  },
  "Kernel.laplacian8": {
    "description": "Generates a 3x3 laplacian-8 edge-detection kernel.",
    "returns": "Kernel",
    "args": [
      {
        "name": "normalize",
        "type": "Boolean",
        "description": "Normalize the kernel values to sum to 1."
      }
    ]
  },
  "Kernel.add": {
    "description": "Adds two kernels",
    "returns": "Kernel",
    "args": [
      {
        "name": "kernel1",
        "type": "Kernel",
        "description": "The first kernel."
      },
      {
        "name": "kernel2",
        "type": "Kernel",
        "description": "The second kernel."
      }
    ]
  },
  "Kernel.inverse": {
    "description": "Returns a kernel which has each of its weights multiplicatively inverted. Weights with a value of zero are not inverted and remain zero.",
    "returns": "Kernel",
    "args": [
      {
        "name": "kernel",
        "type": "Kernel",
        "description": "The first kernel."
      }
    ]
  },
  "Coverage.bandTypes": {
    "description": " Returns a map of the coverage's band types.",
    "returns": "String",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage from which the left operand bands are taken."
      }
    ]
  },
  "Coverage.rename": {
    "description": "Rename the bands of a coverage.Returns the renamed coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "name",
        "type": "List<String>",
        "description": "The new names for the bands. Must match the number of bands in the Image."
      }
    ]
  },
  "Coverage.abs": {
    "description": "Computes the absolute value of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image to which the operation is applied."
      }
    ]
  },
  "Coverage.acos": {
    "description": "Computes the arc cosine in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.cos": {
    "description": "Computes the cosine in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.cosh": {
    "description": "Computes the hyperbolic cosine of the input in radians.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.asin": {
    "description": "Computes the arc sine in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.sin": {
    "description": "Computes the sine in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.sinh": {
    "description": "Computes the hyperbolic sine of the input in radians.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.atan": {
    "description": "Computes the arc tangent in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.tan": {
    "description": "Computes the tangent in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.tanh": {
    "description": "Computes the hyperbolic tangent in radians of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation"
      }
    ]
  },
  "Coverage.atan2": {
    "description": "Calculates the angle formed by the 2D vector [x, y] for each matched pair of bands in image1 and image2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "First coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "Second coverage for operation."
      }
    ]
  },
  "Coverage.neq": {
    "description": "Returns 1 iff the first value is not equal to the second for each matched pair of bands in image1 and image2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.addBands": {
    "description": "Returns an coverage containing all bands copied from the first input and selected bands from the second input,optionally overwriting bands in the first coverage with the same name.",
    "returns": "Coverage",
    "args": [
      {
        "name": "dstCoverage",
        "type": "Coverage",
        "description": "first coverage."
      },
      {
        "name": "srcCoverage",
        "type": "Coverage",
        "description": "second coverage."
      },
      {
        "name": "names",
        "type": "List<String>",
        "description": "the name of selected bands in srcCoverage"
      },
      {
        "name": "overwrite",
        "type": "Boolean",
        "description": "if true, overwrite bands in the first coverage with the same name. Otherwise the bands in the first coverage will be kept."
      }
    ]
  },
  "Coverage.signum": {
    "description": "Computes the signum function (sign) of the input; zero if the input is zero, 1 if the input is greater than zero, -1 if the input is less than zero.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image to which the operation is applied."
      }
    ]
  },
  "Coverage.pow": {
    "description": "Raises the first value to the power of the second for each matched pair of bands in image1 and image2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.mini": {
    "description": "Selects the minimum of the first and second values for each matched pair of bands in image1 and image2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.maxi": {
    "description": "Selects the maximum of the first and second values for each matched pair of bands in image1 and image2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.polynomial": {
    "description": "Compute a polynomial at each pixel using the given coefficients.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The input coverage."
      },
      {
        "name": "l",
        "type": "List<Double>",
        "description": "The polynomial coefficients in increasing order of degree starting with the constant term."
      }
    ]
  },
  "Coverage.log": {
    "description": "Computes the natural logarithm of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      }
    ]
  },
  "Coverage.log10": {
    "description": "Computes the base-10 logarithm of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      }
    ]
  },
  "Coverage.mask": {
    "description": "Generate a coverage with the values from the first coverage, but only include cells in which the corresponding cell in the second coverage *are not* set to the \"readMask\" value. Otherwise, the value of the cell will be set to the \"writeMask\".\n Both coverages are required to have the same number of bands, or the coverage2 must have 1 bands. If the coverage2 has a band count of 1, the mask is applied to each band of coverage1.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The input image"
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The mask image."
      },
      {
        "name": "readMask",
        "type": "Int",
        "description": "The number to be masked in the Mask."
      },
      {
        "name": "writeMask",
        "type": "Int",
        "description": "The number will be set if the values from coverage2 is equal to readMask."
      }
    ]
  },
  "Coverage.convolve": {
    "description": "Convolve each band of a image with the given kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to convolve."
      },
      {
        "name": "kernel",
        "type": "Kernel",
        "description": "The kernel to convolve with."
      }
    ]
  },
  "Coverage.focalMean": {
    "description": "Applies a morphological mean filter to each band of an image using a named or custom kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "kernelType",
        "type": "String",
        "description": "The type of kernel to use."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to use."
      }
    ]
  },
  "Coverage.focalMedian": {
    "description": "Applies a morphological median filter to each band of an image using a named or custom kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "kernelType",
        "type": "String",
        "description": "The type of kernel to use."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to use."
      }
    ]
  },
  "Coverage.focalMode": {
    "description": "Applies a morphological mode filter to each band of an coverage using a named or custom kernel. Mode does not currently support Double raster data. If you use a raster with a Double CellType, the raster will be rounded to integers.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "kernelType",
        "type": "String",
        "description": "The type of kernel to use."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to use."
      }
    ]
  },
  "Coverage.focalMax": {
    "description": "Applies a morphological max filter to each band of an image using a named or custom kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "kernelType",
        "type": "String",
        "description": "The type of kernel to use."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to use."
      }
    ]
  },
  "Coverage.focalMin": {
    "description": "Applies a morphological min filter to each band of an image using a named or custom kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to apply the operations."
      },
      {
        "name": "kernelType",
        "type": "String",
        "description": "The type of kernel to use."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the kernel to use."
      }
    ]
  },
  "Coverage.slice": {
    "description": "Selects a contiguous group of bands from a coverage by position.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage from which to select bands."
      },
      {
        "name": "start",
        "type": "Int",
        "description": "Where to start the selection."
      },
      {
        "name": "end",
        "type": "Int",
        "description": "Where to end the selection."
      }
    ]
  },
  "Coverage.histogram": {
    "description": "Return the histogram of the image, a map of bin label value and its associated count.",
    "returns": "Map[Int,Long]",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to compute the histogram."
      }
    ]
  },
  "Coverage.projection": {
    "description": "Returns the projection of an Image.",
    "returns": "String",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which to get the projection."
      }
    ]
  },
  "Coverage.reproject": {
    "description": "Force a coverage to be computed in a given projection",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to reproject."
      },
      {
        "name": "crsCode",
        "type": "Int",
        "description": "The code of new projection."
      },
      {
        "name": "resolution",
        "type": "Int",
        "description": "The resolution of reprojected image."
      }
    ]
  },
  "Coverage.resample": {
    "description": "Resample the image",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to resample."
      },
      {
        "name": "level",
        "type": "Double",
        "description": "The resampling level. eg:1 for up-sampling and -1 for down-sampling."
      },
      {
        "name": "mode",
        "type": "String",
        "description": "The interpolation mode to use"
      }
    ]
  },
  "Coverage.remap": {
    "description": "Maps from input values to output values, represented by two parallel lists. Any input values not included in the input list are either set to defaultValue if it is given, or masked if it isn't. Note that inputs containing floating point values might sometimes fail to match due to floating point precision errors.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to remap."
      },
      {
        "name": "from",
        "type": "List[Int]",
        "description": "The key list of the map."
      },
      {
        "name": "to",
        "type": "List[Double]",
        "description": "The value list of the map."
      },
      {
        "name": "defaultValue",
        "type": "Double",
        "default": "None",
        "optional": "True",
        "description": "Any input values not included in the input list are either set to defaultValue if it is given, or masked if it isn't."
      }
    ]
  },
  "Coverage.gradient": {
    "description": "Calculates the gradient.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the gradient."
      }
    ]
  },
  "Coverage.gt": {
    "description": "Returns 1 iff the first value is greater than the second for each matched pair of bands in coverage1 and coverage2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for operation."
      }
    ]
  },
  "Coverage.gte": {
    "description": "Returns 1 iff the first value is equal or greater to the second for each matched pair of bands in coverage1 and coverage2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for operation."
      }
    ]
  },
  "Coverage.lt": {
    "description": "Returns 1 iff the first value is less than the second for each matched pair of bands in coverage1 and coverage2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for operation."
      }
    ]
  },
  "Coverage.lte": {
    "description": "Returns 1 iff the first value is equal or less to the second for each matched pair of bands in coverage1 and coverage2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for operation."
      }
    ]
  },
  "Coverage.clip": {
    "description": "Clip the raster with the geometry.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to clip."
      },
      {
        "name": "geom",
        "type": "Geometry",
        "description": "The geometry used to clip."
      }
    ]
  },
  "Coverage.clamp": {
    "description": "Clamp the raster between low and high.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to clamp."
      },
      {
        "name": "low",
        "type": "Int",
        "description": "The low value."
      },
      {
        "name": "high",
        "type": "Int",
        "description": "The high value."
      }
    ]
  },
  "Coverage.rgbToHsv": {
    "description": "Transforms the coverage from the RGB color space to the HSV color space.Expects a 3 band coverage in the range [0, 255], and produces three bands: hue, saturation and value with values in the range [0, 1].",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "he coverage with three bands: R, G, B."
      }
    ]
  },
  "Coverage.hsvToRgb": {
    "description": "Transforms the coverage from the HSV color space to the RGB color space.Expects a 3 band coverage with hue, saturation and value in the ranges [0, 1], and produces three bands: R, G, B with values in the range [0, 255].",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage with three bands: H, S, V."
      }
    ]
  },
  "Coverage.entropy": {
    "description": "Computes the windowed entropy using the specified kernel centered on each input pixel. Entropy is computed as -sum(p * log2(p)), where p is the normalized probability of occurrence of the values encountered in each window.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the entropy."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the entropy, 1 for a 3×3 square."
      }
    ]
  },
  "Coverage.eq": {
    "description": "Returns 1 iff the first value is equal to the second for each matched pair of bands in coverage1 and coverage2.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The first coverage for operation."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The second coverage for operation."
      }
    ]
  },
  "Coverage.floor": {
    "description": "Computes the largest integer less than or equal to the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage1",
        "description": "Computes the largest integer less than or equal to the input."
      }
    ]
  },
  "Coverage.NDVI": {
    "description": "Calculation of image normalized vegetation index NDVI.",
    "returns": "Coverage",
    "args": [
      {
        "name": "NIR",
        "type": "Coverage",
        "description": "The Near-Infrared band."
      },
      {
        "name": "Red",
        "type": "Coverage",
        "description": "The Red band."
      }
    ]
  },
  "Coverage.cbrt": {
    "description": "Computes the cubic root of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image to which the operation is applied."
      }
    ]
  },
  "Coverage.sqrt": {
    "description": "Computes the square root of the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image to which the operation is applied."
      }
    ]
  },
  "Coverage.ceil": {
    "description": "Computes the smallest integer greater than or equal to the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      }
    ]
  },
  "Coverage.round": {
    "description": "Computes the integer nearest to the input.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage for operation."
      }
    ]
  },
  "Coverage.metadata": {
    "description": "Return the metadata of the input coverage.",
    "returns": "String",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image to get the metadata"
      }
    ]
  },
  "Coverage.toInt8": {
    "description": "Casts the input value to a signed 8-bit integer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toUint8": {
    "description": "Casts the input value to a unsigned 8-bit integer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toInt16": {
    "description": "Casts the input value to a signed 16-bit integer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toUint16": {
    "description": "Casts the input value to a unsigned 16-bit integer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toInt32": {
    "description": "Casts the input value to a signed 32-bit integer.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toFloat": {
    "description": "Casts the input value to a 32-bit float.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Coverage.toDouble": {
    "description": "Casts the input value to a 64-bit float.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to which the operation is applied."
      }
    ]
  },
  "Terrain.slope": {
    "description": "Calculates slope in degrees from a terrain DEM.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the slope."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the slope, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct slope calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Terrain.aspect": {
    "description": "Calculates aspect in degrees from a terrain DEM.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the aspect."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the aspect, 1 for a 3×3 square."
      }
    ]
  },
  "CoverageCollection.mosaic": {
    "description": "mosaic the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.mean": {
    "description": "mean the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.min": {
    "description": "min the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.max": {
    "description": "max the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.sum": {
    "description": "sum the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.or": {
    "description": "or the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.and": {
    "description": "and the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.median": {
    "description": "median the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.mode": {
    "description": "mode the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.cat": {
    "description": "cat the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      }
    ]
  },
  "CoverageCollection.visualizeOnTheFly": {
    "description": "",
    "returns": "Unit",
    "args": [
      {
        "name": "coverageCollection",
        "type": "collection",
        "description": ""
      },
      {
        "name": "visParam",
        "type": "VisualizationParam",
        "description": ""
      }
    ]
  },
  "Coverage.addStyles": {
    "description": "Add the styles to the coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to be added styles"
      },
      {
        "name": "bands",
        "type": "List<String>",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "",
        "default": "png",
        "optional": "True"
      }
    ]
  },
  "Cube.addStyles": {
    "description": "Add the styles to the coverage.",
    "returns": "Cube",
    "args": [
      {
        "name": "cube",
        "type": "Cube",
        "description": "The coverage to be added styles"
      },
      {
        "name": "bands",
        "type": "List<String>",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "List<List<String>>",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "",
        "default": "png",
        "optional": "True"
      }
    ]
  },
  "CoverageCollection.mergeCoverages": {
    "description": "Merge Coverages to a CoverageCollection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "coverages",
        "type": "List<Coverage>",
        "description": "A list of coverages."
      },
      {
        "name": "names",
        "type": "List<String>",
        "description": "A list of names."
      }
    ]
  },
  "CoverageCollection.addStyles": {
    "description": "Add the styles to the coverage collection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage collection to be added styles"
      },
      {
        "name": "bands",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "png",
        "default": "False",
        "optional": "True"
      },
      {
        "name": "method",
        "type": "String",
        "description": "",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Feature.point": {
    "description": "create a Point",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.lineString": {
    "description": "create a LineString",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.linearRing": {
    "description": "create a LinearRing",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.polygon": {
    "description": "create a Polygon",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.multiPoint": {
    "description": "create a multiPoint",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.multiLineString": {
    "description": "create a MultiLineString",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.multiPolygon": {
    "description": "create a MultiPoint",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.geometry": {
    "description": "create a geometry",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "geojson"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.load": {
    "description": "load data",
    "returns": "Feature",
    "args": [
      {
        "name": "productName",
        "type": "String",
        "description": "productName"
      },
      {
        "name": "dateTime",
        "type": "String",
        "description": "dataTime",
        "default": "null"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS",
        "default": "EPSG:4326"
      }
    ]
  },
  "Feature.featureCollection": {
    "description": "create a featureCollection",
    "returns": "Feature",
    "args": [
      {
        "name": "featureList",
        "type": "List[Feature]",
        "description": "featureList"
      }
    ]
  },
  "Feature.centroid": {
    "description": "compute bounds",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.buffer": {
    "description": "compute buffer",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "distance"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.convexHull": {
    "description": "compute convexHull",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.coordinates": {
    "description": "compute coordinates",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.reproject": {
    "description": "reproject",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "tarCrsCode",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.isUnbounded": {
    "description": "judge a geometry is unbounded",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.getType": {
    "description": "Returns the GeoJSON type of the geometry",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.projection": {
    "description": "Returns the projection of the geometry.",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.toGeoJSONString": {
    "description": "Returns a GeoJSON string representation of the geometry.",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.length": {
    "description": "compute length",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.dissolve": {
    "description": "Computes the union of all the elements of this geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.contains": {
    "description": "Returns true iff one geometry contains the other.",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.containedIn": {
    "description": "Returns true iff one geometry is contained in the other.",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.disjoint": {
    "description": "Returns true iff the geometries are disjoint.",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.distance": {
    "description": "Returns the minimum distance between two geometries.",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.difference": {
    "description": "Returns the result of subtracting the 'right' geometry from the 'left' geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.intersection": {
    "description": "Returns the intersection of the two geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.intersects": {
    "description": "Returns true iff the geometries intersect.",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.symmetricDifference": {
    "description": "Returns the symmetric difference between two geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.union": {
    "description": "Returns the union of the two geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.withDistance": {
    "description": "Returns true iff the geometries are within a specified distance.",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "distance"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.copyProperties": {
    "description": "Copies metadata properties from one element to another.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "properties",
        "type": "List[String]",
        "description": "The properties to copy. If omitted, all properties are copied.",
        "default": "None"
      }
    ]
  },
  "Feature.get": {
    "description": "Extract a property from a feature.",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.getNumber": {
    "description": "Extract a property from a feature.",
    "returns": "List[Double]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.getString": {
    "description": "Extract a property from a feature.",
    "returns": "List[String]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.getArray": {
    "description": "Extract a property from a feature.",
    "returns": "List[Array[String]]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.propertyNames": {
    "description": "Returns the names of properties on this element.",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.set": {
    "description": "Overrides one or more metadata properties of an Element.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "the property to set. it is a json"
      }
    ]
  },
  "Feature.setGeometry": {
    "description": "Returns the feature, with the geometry replaced by the specified geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "geom",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.inverseDistanceWeighted": {
    "description": "InverseDistanceWeighted Interpolation",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "propertyName",
        "type": "String",
        "description": "the property to select"
      },
      {
        "name": "maskGeom",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.area": {
    "description": "compute area",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.bounds": {
    "description": "compute area",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "Coordinates"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.addStyles": {
    "description": "Add the styles to the feature.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The coverage collection to be added styles"
      },
      {
        "name": "color",
        "type": "List<String>",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "attribute",
        "type": "String",
        "description": "",
        "default": "",
        "optional": "True"
      }
    ]
  },
  "FeatureCollection.addStyles": {
    "description": "Add the styles to the feature collection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection to be added styles"
      },
      {
        "name": "color",
        "type": "String",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "ProcessResult.addStyles": {
    "description": "Add the styles to the result of process.",
    "returns": "ProcessResult",
    "args": [
      {
        "name": "input",
        "type": "ProcessResult",
        "description": "The feature collection to be added styles"
      },
      {
        "name": "args",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "Item.addStyles": {
    "description": "Add the styles to item.",
    "returns": "Item",
    "args": [
      {
        "name": "input",
        "type": "Item",
        "description": "The item to be added styles"
      },
      {
        "name": "args",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "Item.getItemType": {
    "description": "Get type of item.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Item",
        "description": "The feature as the input data "
      }
    ]
  },
  "Filter.equals": {
    "description": "Check if filter equals others",
    "returns": "Filter",
    "args": [
      {
        "name": "leftField",
        "type": "String",
        "description": "Field name"
      },
      {
        "name": "rightValue",
        "type": "Object",
        "description": "value"
      }
    ]
  },
  "Filter.and": {
    "description": "Filter and",
    "returns": "Filter",
    "args": [
      {
        "name": "filters",
        "type": "List<String>",
        "description": "Filters"
      }
    ]
  },
  "Coverage.slope": {
    "description": "Compute the Slope of DEM",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "the input DEM"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "default": "1.0",
        "optional": "True"
      },
      {
        "name": "radius",
        "type": "Double",
        "description": "The radius."
      }
    ]
  },
  "CoverageCollection.slope": {
    "description": "Compute the Slope of DEM",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input DEM"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "default": "1.0",
        "optional": "True"
      }
    ]
  },
  "slope": {
    "description": "Compute the Slope of DEM",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input DEM"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "default": "1.0",
        "optional": "True"
      }
    ]
  },
  "Cube.fusion": {
    "description": "Fusion of two cube",
    "returns": "Cube",
    "args": [
      {
        "name": "leftCube",
        "type": "Cube",
        "description": "the left cube"
      },
      {
        "name": "rightCube",
        "type": "Cube",
        "description": "the other Cube"
      },
      {
        "name": "function",
        "type": "String",
        "description": "the String function to use"
      },
      {
        "name": "param",
        "type": "Object",
        "description": "the param to be added to function",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "newProduct",
        "type": "String",
        "description": "the new product from the process",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Coverage.aspect": {
    "description": "坡向计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius"
      }
    ]
  },
  "CoverageCollection.aspect": {
    "description": "坡向计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      }
    ]
  },
  "Coverage.hillShade": {
    "description": "山体阴影计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      },
      {
        "name": "Azimuth",
        "type": "Float",
        "description": "Set the horizontal angle(in degrees) of the sun(clockwise direction)Range:0 to 360.0",
        "optional": "True",
        "default": "300.0"
      },
      {
        "name": "Vertical_angle",
        "type": "Float",
        "description": "Set the vertical angle(in degrees) of the sun, that is the height of the sun",
        "optional": "True",
        "default": "40.0"
      }
    ]
  },
  "CoverageCollection.hillShade": {
    "description": "山体阴影计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      },
      {
        "name": "Azimuth",
        "type": "Float",
        "description": "Set the horizontal angle(in degrees) of the sun(clockwise direction)Range:0 to 360.0",
        "optional": "True",
        "default": "300.0"
      },
      {
        "name": "Vertical_angle",
        "type": "Float",
        "description": "Set the vertical angle(in degrees) of the sun, that is the height of the sun",
        "optional": "True",
        "default": "40.0"
      }
    ]
  },
  "Coverage.relief": {
    "description": "等值线计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      }
    ]
  },
  "CoverageCollection.relief": {
    "description": "等值线计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      }
    ]
  },
  "Coverage.ruggednessIndex": {
    "description": "粗糙度计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      }
    ]
  },
  "CoverageCollection.ruggednessIndex": {
    "description": "粗糙度计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      },
      {
        "name": "Z_factor",
        "type": "Float",
        "description": "Vertical exaggeration",
        "optional": "True",
        "default": "1"
      }
    ]
  },
  "Coverage.cellBalance": {
    "description": "洼地去除",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "CoverageCollection.cellBalance": {
    "description": "洼地去除",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Coverage.flowAccumulationTD": {
    "description": "流量(Top-Down)计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "CoverageCollection.flowAccumulationTD": {
    "description": "流量(Top-Down)计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Coverage.flowPathLength": {
    "description": "流域长度计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "CoverageCollection.flowPathLength": {
    "description": "流域长度计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Coverage.slopeLength": {
    "description": "坡长计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "CoverageCollection.slopeLength": {
    "description": "坡长计算",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Coverage.sceneClassification": {
    "description": "场景分类",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Coverage.imageSegmentation": {
    "description": "语义分割",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "the input coverage"
      }
    ]
  },
  "Algorithm.hargreaves": {
    "description": "水文hargreaves模型",
    "returns": "Table",
    "args": [
      {
        "name": "inputTemperature",
        "type": "String",
        "description": "温度表格数据"
      },
      {
        "name": "inputStation",
        "type": "String",
        "description": "站点数据"
      },
      {
        "name": "startTime",
        "type": "String",
        "description": "开始时间"
      },
      {
        "name": "endTime",
        "type": "String",
        "description": "结束时间"
      },
      {
        "name": "timeStep",
        "type": "Long",
        "description": "步长"
      }
    ]
  },
  "Algorithm.topmodel": {
    "description": "水文TOPMODEL模型",
    "returns": "Table",
    "args": [
      {
        "name": "rate",
        "type": "Double",
        "description": "rate"
      },
      {
        "name": "recession",
        "type": "Int",
        "description": "recession"
      },
      {
        "name": "tMax",
        "type": "Int",
        "description": "tMax"
      },
      {
        "name": "iterception",
        "type": "Int",
        "description": "iterception"
      },
      {
        "name": "waterShedArea",
        "type": "Int",
        "description": "waterShedArea"
      },
      {
        "name": "startTime",
        "type": "String",
        "description": "开始时间"
      },
      {
        "name": "endTime",
        "type": "String",
        "description": "结束时间"
      },
      {
        "name": "timeStep",
        "type": "Long",
        "description": "步长"
      },
      {
        "name": "inputTopoIndex",
        "type": "String",
        "description": ""
      },
      {
        "name": "inputPrecipEvapFile",
        "type": "String",
        "description": ""
      }
    ]
  },
  "Algorithm.swmm": {
    "description": "水文SWMM5模型",
    "returns": "Table",
    "args": [
      {
        "name": "input",
        "type": "String",
        "description": ""
      }
    ]
  },
  "Algorithm.virtualConstellation": {
    "description": "高分/哨兵2一致性产品生产",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "原始数据"
      },
      {
        "name": "bands",
        "type": "String",
        "description": "所处理的波段"
      }
    ]
  },
  "CoverageCollection.calVegIndex": {
    "description": "计算植被/水体指数",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "输入数据(Modis)"
      },
      {
        "name": "year",
        "type": "String",
        "description": "年份"
      },
      {
        "name": "quarter",
        "type": "String",
        "description": "季度"
      }
    ]
  },
  "CoverageCollection.calCrop": {
    "description": "用矢量裁剪",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "输入数据"
      },
      {
        "name": "feature",
        "type": "Feature",
        "description": "裁剪所用的矢量"
      },
      {
        "name": "year",
        "type": "String",
        "description": "年份"
      },
      {
        "name": "quarter",
        "type": "String",
        "description": "季度"
      },
      {
        "name": "sort",
        "type": "String",
        "description": "类型"
      }
    ]
  },
  "CoverageCollection.calVegCoverage": {
    "description": "计算植被覆盖度",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "输入数据(Modis)"
      },
      {
        "name": "year",
        "type": "String",
        "description": "年份"
      },
      {
        "name": "quarter",
        "type": "String",
        "description": "季度"
      }
    ]
  },
  "CoverageCollection.calNPP": {
    "description": "计算植被生产力",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "输入数据，即植被/水体指数"
      },
      {
        "name": "year",
        "type": "String",
        "description": "年份"
      },
      {
        "name": "quarter",
        "type": "String",
        "description": "季度"
      }
    ]
  },
  "CoverageCollection.calVEI": {
    "description": "计算生态指数",
    "returns": "Coverage",
    "args": [
      {
        "name": "inputFVC",
        "type": "CoverageCollection",
        "description": "输入的FVC产品"
      },
      {
        "name": "inputNPP",
        "type": "CoverageCollection",
        "description": "输入的NPP产品"
      },
      {
        "name": "year",
        "type": "String",
        "description": "年份"
      }
    ]
  },
  "CoverageCollection.fromCoverages": {
    "description": "从coverages列表中构造CoverageCollection",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "coverages",
        "type": "List<Object>",
        "description": "输入的coverages列表"
      }
    ]
  },
  "CoverageArray.add": {
    "description": "Adds the first value to the second for each matched pair of bands in every image of the CoverageArray and image. If either image of the CoverageArray or image has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types. ",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "CoverageArray.multiply": {
    "description": "Multiplies the first value by the second. If either image of the CoverageArray or image has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "CoverageArray.subtract": {
    "description": "Subtracts the second value from the first for each matched pair of bands in every image of the CoverageArray and image. If either image of the CoverageArray or image has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "CoverageArray.divide": {
    "description": "Divides the first value by the second, returning 0 for division by 0 for each matched pair of bands in every image of the CoverageArray and image2. If either image of the CoverageArray or image has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "CoverageArray.addNum": {
    "description": "Add the value to the CoverageArray.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value to add."
      }
    ]
  },
  "CoverageArray.subtractNum": {
    "description": "Subtract the corresponding value from the CoverageArray.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for subtract."
      }
    ]
  },
  "CoverageArray.divideNum": {
    "description": "Divide the corresponding value from the CoverageArray.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for divide."
      }
    ]
  },
  "CoverageArray.multiplyNum": {
    "description": "Multiply the corresponding value to the CoverageArray.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray for operation."
      },
      {
        "name": "i",
        "type": "Double",
        "description": "The value for multiply."
      }
    ]
  },
  "CoverageArray.toInt8": {
    "description": "Casts the input value to a signed 8-bit integer.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray to which the operation is applied."
      }
    ]
  },
  "CoverageArray.toUint8": {
    "description": "Casts the input value to a unsigned 8-bit integer.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray to which the operation is applied."
      }
    ]
  },
  "CoverageArray.toInt16": {
    "description": "Casts the input value to a signed 16-bit integer.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray to which the operation is applied."
      }
    ]
  },
  "CoverageArray.toUint16": {
    "description": "Casts the input value to a unsigned 16-bit integer.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray to which the operation is applied."
      }
    ]
  },
  "CoverageArray.toInt32": {
    "description": "Casts the input value to a signed 32-bit integer.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray to which the operation is applied."
      }
    ]
  },
  "CoverageArray.toFloat": {
    "description": "Casts the input value to a 32-bit float.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray to which the operation is applied."
      }
    ]
  },
  "CoverageArray.toDouble": {
    "description": "Casts the input value to a 64-bit float.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray to which the operation is applied."
      }
    ]
  },
  "CoverageArray.normalizedDifference": {
    "description": "Computes the normalized difference between two bands.The normalized difference is computed as (first − second) / (first + second). ",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The input CoverageArray"
      },
      {
        "name": "bandNames",
        "type": "List<String>",
        "description": "A list of names specifying the bands to use. If not specified, the first and second bands are used",
        "optional": "True",
        "default": "None"
      }
    ]
  },
  "CoverageArray.addStyles": {
    "description": "Add the styles to the coverageArray.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The coverageArray to be added styles"
      },
      {
        "name": "bands",
        "type": "List<String>",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "",
        "default": "png",
        "optional": "True"
      }
    ]
  },
  "CoverageArray.export": {
    "description": "Export a coverageArray.",
    "returns": "CoverageArray",
    "args": [
      {
        "name": "coverageArray",
        "type": "CoverageArray",
        "description": "The CoverageArray to be exported"
      },
      {
        "name": "description",
        "type": "String",
        "description": "The description of the CoverageArray",
        "optional": "True"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "The crs of the exported CoverageArray",
        "optional": "True"
      },
      {
        "name": "scale",
        "type": "Double",
        "description": "The scale of the exported CoverageArray",
        "optional": "True"
      },
      {
        "name": "folder",
        "type": "String",
        "description": "The folder path of the exported CoverageArray",
        "optional": "True"
      },
      {
        "name": "fileName",
        "type": "String",
        "description": "The file name of the exported CoverageArray",
        "optional": "True"
      },
      {
        "name": "fileFormat",
        "type": "String",
        "description": "The format of the exported CoverageArray",
        "optional": "True"
      }
    ]
  },
  "Service.getTable": {
    "description": "从service中获取表格数据",
    "returns": "Table",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of table product."
      }
    ]
  },
  "Table.getTable": {
    "description": "从加载表格数据",
    "returns": "Table",
    "args": [
      {
        "name": "productID",
        "type": "String",
        "description": "The id of table product."
      }
    ]
  },
  "Table.getDownloadUrl": {
    "description": "获取下载的url",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Table",
        "description": "The table to download."
      },
      {
        "name": "format",
        "type": "String",
        "description": "format of the  table file"
      },
      {
        "name": "name",
        "type": "String",
        "description": "file name of the  table file"
      }
    ]
  },
  "Table.addStyles": {
    "description": "获取下载的url",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Table",
        "description": "The table to download."
      }
    ]
  },
  "Cube.load": {
    "description": "Load a cube by some params",
    "returns": "Cube",
    "args": [
      {
        "name": "cubeID",
        "type": "String",
        "description": "The id of the cube."
      },
      {
        "name": "dateTime",
        "type": "List<String>",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The bounding box of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "measurements",
        "type": "List<String>",
        "description": "The measurements of the product.",
        "optional": "True",
        "default": "null"
      }
    ]
  },
  "Cube.band": {
    "description": "Select a new cube by band name",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to select bands from."
      },
      {
        "name": "bandName",
        "type": "String",
        "description": "The name of band to be selected"
      }
    ]
  },
  "Cube.visualize": {
    "description": "Produces an RGB or grayscale visualization of an Cube.  Each of the gain, bias, min, max and gamma arguments can take either a single value, which will be applied to all bands, or a list of values the same length as bands.",
    "returns": "Cube",
    "args": [
      {
        "name": "cube",
        "type": "Cube",
        "description": "The cube to visualize"
      },
      {
        "name": "products",
        "type": "Object",
        "description": "The products in cube to visualize"
      },
      {
        "name": "bands",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "png",
        "default": "False",
        "optional": "True"
      }
    ]
  },
  "Cube.NDWI": {
    "description": "Compute NDWI of the Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to compute NDWI."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product in cube to compute NDWI"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of NDWI"
      }
    ]
  },
  "Cube.binarization": {
    "description": "Compute binarization of the Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to compute NDWI."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product to compute binarization."
      },
      {
        "name": "threshold",
        "type": "Int",
        "description": "The threshold to binary"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of binary"
      }
    ]
  },
  "Cube.subtract": {
    "description": "Compute binarization of the Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to compute NDWI."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product to compute binarization."
      },
      {
        "name": "timeList",
        "type": "List<String>",
        "description": "The list of time."
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of binary"
      }
    ]
  },
  "Cube.ChangeDetection": {
    "description": "Get the change area of the target Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to find changed area."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product in cube to detect the change."
      },
      {
        "name": "certainTimes",
        "type": "List<String>",
        "description": "The time range of two images to get change"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of change detection."
      }
    ]
  },
  "Cube.overlayAnalysis": {
    "description": "Overlay analysis between two cube",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to overlay analysis."
      },
      {
        "name": "raster",
        "type": "String",
        "description": "The raster product in cube to overlay"
      },
      {
        "name": "vector",
        "type": "String",
        "description": "The target vector product in cube to overlay"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of overlay analysis."
      }
    ]
  },
  "Cube.conjointAnalysis": {
    "description": "Conjoin analysis between raster cube and tabular data",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to conjoint analysis."
      },
      {
        "name": "vector",
        "type": "String",
        "description": "The vector product in cube to conjoint."
      },
      {
        "name": "tabular",
        "type": "String",
        "description": "The tabular product in cube to conjoint."
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of conjoin analysis."
      }
    ]
  },
  "Coverage.terrSlope": {
    "description": "DEM坡度计算.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the slope."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the slope, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct slope calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrAspect": {
    "description": "DEM坡向计算.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the aspect."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the aspect, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct aspect calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrCurvature": {
    "description": "DEM曲率计算.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the curvature."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the curvature, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct curvature calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrRuggedness": {
    "description": "DEM粗糙度计算.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the ruggedness."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the ruggedness, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct ruggedness calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrSlopelength": {
    "description": "DEM坡长计算.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the slopelength."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "radius for DEM indexing, default is 16"
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct slopelength calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrHillshade": {
    "description": "DEM山体阴影计算.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the hillshade."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the hillshade, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct hillshade calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrPitrouter": {
    "description": "DEM洼地探测.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the pitrouter."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the pitrouter, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct pitrouter calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrPiteliminator": {
    "description": "DEM洼地填充.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the piteliminator."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the piteliminator, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct piteliminator calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrFlowdirection": {
    "description": "DEM流向.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the flowdirection."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the flowdirection, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct flowdirection calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrFlowaccumulation": {
    "description": "DEM流量.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The dem coverage to compute the flowaccumulation."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct flowaccumulation calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrChannelnetwork": {
    "description": "DEM河网矢量化.",
    "returns": "Feature",
    "args": [
      {
        "name": "DEM",
        "type": "Coverage",
        "description": "The dem coverage to compute the channelnetwork."
      },
      {
        "name": "FlowAccumulation",
        "type": "Coverage",
        "description": "The flowaccumulation coverage to compute the channelnetwork."
      },
      {
        "name": "FlowDirection",
        "type": "Coverage",
        "description": "The flowdirection coverage to compute the channelnetwork."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct channelnetwork calculations when the surface z units are expressed in units different from the ground x,y units."
      },
      {
        "name": "threshold",
        "type": "Double",
        "description": "Filter rivers with flow accumulation greater than the threshold."
      }
    ]
  },
  "Coverage.terrFilter": {
    "description": "栅格值筛选.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to filter."
      },
      {
        "name": "min",
        "type": "List[Double]",
        "description": "condition filter list min(include min)"
      },
      {
        "name": "max",
        "type": "List[Double]",
        "description": "condition filter list max(include max)"
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct filter calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrStrahlerOrder": {
    "description": "河网分级.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the strahlerorder."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the strahlerorder, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct strahlerorder calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrFlowConnectivity": {
    "description": "河流连接.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the flowconnectivity."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the flowconnectivity, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct flowconnectivity calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrFlowLength": {
    "description": "水流长度.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the flowlength."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the flowlength, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct flowlength calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrFlowWidth": {
    "description": "水流宽度.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the flowwidth."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the flowwidth, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct flowwidth calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrWatershedBasins": {
    "description": "流域分析.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The dem coverage to compute the WatershedBasins."
      },
      {
        "name": "FlowAccumulation",
        "type": "Coverage",
        "description": "The flowaccumulation coverage to compute the WatershedBasins."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct WatershedBasins calculations when the surface z units are expressed in units different from the ground x,y units."
      }
    ]
  },
  "Coverage.terrFeatureSelect": {
    "description": "特征点提取.",
    "returns": "Feature",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the FeatureSelect."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the FeatureSelect, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct FeatureSelect calculations when the surface z units are expressed in units different from the ground x,y units."
      },
      {
        "name": "vipValue",
        "type": "Double",
        "description": "Extract feature points whose importance is greater than value."
      }
    ]
  },
  "Coverage.terrTIN": {
    "description": "TIN.",
    "returns": "Feature",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to compute the TIN."
      },
      {
        "name": "radius",
        "type": "Int",
        "description": "The radius of the square neighborhood to compute the TIN, 1 for a 3×3 square."
      },
      {
        "name": "z-Factor",
        "type": "Double",
        "description": "a z-factor for correct TIN calculations when the surface z units are expressed in units different from the ground x,y units."
      },
      {
        "name": "vipValue",
        "type": "Double",
        "description": "Extract feature points whose importance is greater than value."
      },
      {
        "name": "geometryType",
        "type": "Int",
        "description": "type of result (1: points, 2: lines, 3: polygons)."
      }
    ]
  },
  "Cube.normalize": {
    "description": "Calculate the normalize index from the cube",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The input Cube."
      },
      {
        "name": "dimensionName",
        "type": "String",
        "description": "The dimension name to calculate the normalize index."
      },
      {
        "name": "dimensionMembers",
        "type": "List<String>",
        "description": "The dimension members of to calculate the normalize index"
      }
    ]
  },
  "Cube.export": {
    "description": "Export a Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "cube",
        "type": "Cube",
        "description": "The cube to be exported"
      },
      {
        "name": "description",
        "type": "String",
        "description": "The description of the Cube",
        "optional": "True"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "The crs of the exported Cube",
        "optional": "True"
      },
      {
        "name": "scale",
        "type": "Double",
        "description": "The scale of the exported Cube",
        "optional": "True"
      },
      {
        "name": "folder",
        "type": "String",
        "description": "The folder path of the exported Cube",
        "optional": "True"
      },
      {
        "name": "fileName",
        "type": "String",
        "description": "The file name of the exported Cube",
        "optional": "True"
      },
      {
        "name": "fileFormat",
        "type": "String",
        "description": "The format of the exported Cube",
        "optional": "True"
      }
    ]
  },
  "Cube.floodFillAnalysis": {
    "description": "Compute flood fill analysis of the Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "cubeId",
        "type": "String",
        "description": "The ID of Cube."
      },
      {
        "name": "rasterProductNames",
        "type": "String",
        "description": "The names of raster to analyse."
      },
      {
        "name": "vectorProductNames",
        "type": "String",
        "description": "The names of vector to analyse."
      },
      {
        "name": "vectorProductNames",
        "type": "String",
        "description": "The names of vector to analyse."
      },
      {
        "name": "extent",
        "type": "String",
        "description": "The extent to analyse."
      },
      {
        "name": "timeRange",
        "type": "List<String>",
        "description": "The range of time to analyse."
      }
    ]
  },
  "Cube.NDVI": {
    "description": "Compute NDWI of the Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to compute NDVI."
      },
      {
        "name": "bandNames",
        "type": "List<String>",
        "description": "A list of names specifying the bands to use. If not specified, the first and second bands are used",
        "optional": "True",
        "default": "None"
      }
    ]
  },
  "Cube.build": {
    "description": "Building Cube from coverage id",
    "returns": "Cube",
    "args": [
      {
        "name": "productIDList",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "coverageIDList",
        "type": "String",
        "description": "The id of target coverage."
      },
      {
        "name": "gridDimX",
        "type": "String",
        "description": "The grid column counts of the cube."
      },
      {
        "name": "gridDimY",
        "type": "String",
        "description": "The grid row counts of the cube."
      },
      {
        "name": "extent",
        "type": "String",
        "description": "The extent of the cube."
      },
      {
        "name": "startTime",
        "type": "String",
        "description": "The start time of the cube."
      },
      {
        "name": "endTime",
        "type": "String",
        "description": "The end time of the cube."
      },
      {
        "name": "subset",
        "type": "List<Float>",
        "description": "The subset of target coverage.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "properties",
        "type": "List<String>",
        "description": "Get the bands.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Cube.aggregate": {
    "description": "Aggregate along a dimension",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The input Cube."
      },
      {
        "name": "dimensionName",
        "type": "String",
        "description": "The dimension name to calculate the normalize index."
      },
      {
        "name": "method",
        "type": "String",
        "description": "The method name to perform aggregation"
      }
    ]
  },
  "Coverage.linearTransformation": {
    "description": "Gray-level linear transformations",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The Coverage to make gray-level linear transformations"
      },
      {
        "name": "k",
        "type": "Double",
        "description": "The coefficient to make gray-level linear transformations"
      },
      {
        "name": "b",
        "type": "Int",
        "description": "The constant to add in gray-level linear transformations"
      }
    ]
  },
  "Coverage.falseColorComposite": {
    "description": "Composite single-band photo and color photo",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The Coverage to make FalseColorComposite"
      },
      {
        "name": "BandRed",
        "type": "Int",
        "description": "Chose one band as red band, the number stands for bandindex"
      },
      {
        "name": "BandGreen",
        "type": "Int",
        "description": "Chose one band as green band, the number stands for bandindex"
      },
      {
        "name": "BandBlue",
        "type": "Int",
        "description": "Chose one band as Blue band, the number stands for bandindex"
      }
    ]
  },
  "Coverage.standardDeviationCalculation": {
    "description": "Calculate the standard deviation of each band of coverage",
    "returns": "Map",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to standard deviation calculation."
      }
    ]
  },
  "Coverage.cannyEdgeDetection": {
    "description": "Edge detection by Canny",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to Canny edge detection."
      },
      {
        "name": "lowCoefficient",
        "type": "Double",
        "description": "The constant to control the low threshold.",
        "default": "-1",
        "optional": "True"
      },
      {
        "name": "highCoefficient",
        "type": "Double",
        "description": "The constant to control the high threshold.",
        "default": "-1",
        "optional": "True"
      }
    ]
  },
  "Coverage.standardDeviationStretching": {
    "description": "Stretch the image by the standard deviation calculated early",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to be stretched based on standard deviation."
      }
    ]
  },
  "Coverage.histogramEqualization": {
    "description": "Return the new image based on equalized histogram.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to be histogram equalized."
      }
    ]
  },
  "Coverage.gaussianBlur": {
    "description": "Applies a gaussian filter to each band of an image using a named gaussian kernel.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to be filtered with gaussian filter.",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "d",
        "type": "Int",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "sigmaX",
        "type": "Double",
        "description": "The standard deviation of the gaussian distribution in the x-direction.",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "sigmaY",
        "type": "Double",
        "description": "The standard deviation of the gaussian distribution in the y-direction.",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "borderType",
        "type": "String",
        "description": "Flag for handling missing pixel values in image boundary processing.",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "Coverage.reduction": {
    "description": "To transform multi-band photo to single-band photo.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to be transformed.",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "option",
        "type": "Int",
        "description": "The flag indicating the way of reduction.",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "Coverage.broveyFusion": {
    "description": "Fusion two images to enhance clarity and keep image's spectral information.",
    "returns": "Coverage",
    "args": [
      {
        "name": "multispectral",
        "type": "Coverage",
        "description": "The coverage containing more spectral information.",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "panchromatic",
        "type": "Coverage",
        "description": "The coverage containing sharper resolution.",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "Coverage.bilateralFilter": {
    "description": "A function to remove the image noise and keep the edge distinct",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The photo to be processed",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "d",
        "type": "Int",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "sigmaSpace",
        "type": "Double",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "sigmaColor",
        "type": "Double",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "borderType",
        "type": "String",
        "description": "111",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "Coverage.dilate": {
    "description": "1111",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The photo to be processed",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "length",
        "type": "Int",
        "description": "111",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "Coverage.erosion": {
    "description": "1111",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The photo to be processed",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "k",
        "type": "Int",
        "description": "111",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "Coverage.GLCM": {
    "description": "1111",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The photo to be processed",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "d",
        "type": "Int",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "dist",
        "type": "Int",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "orient",
        "type": "Int",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "greyLevels",
        "type": "Int",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "feature",
        "type": "String",
        "description": "111",
        "default": "Mean",
        "optional": "True"
      },
      {
        "name": "borderType",
        "type": "String",
        "description": "111",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "Coverage.kMeans": {
    "description": "1111",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The photo to be processed",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "k",
        "type": "Int",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "distanceMeasure",
        "type": "String",
        "description": "111",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "Coverage.PCA": {
    "description": "1111",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The photo to be processed",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "num",
        "type": "Int",
        "description": "111",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "Coverage.IHSFusion": {
    "description": "1111",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The photo to be processed",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "111",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "Coverage.panSharp": {
    "description": "1111",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The photo to be processed",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "method",
        "type": "String",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "bandList",
        "type": "List<Short>",
        "description": "111",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "weightList",
        "type": "List<Double>",
        "description": "111",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "Coverage.catTwoCoverage": {
    "description": "1111",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The photo to be processed",
        "default": "None",
        "optional": "False"
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "111",
        "default": "None",
        "optional": "False"
      }
    ]
  },
  "SpatialStats.GWModels.GWRbasic.autoFit": {
    "description": "Basic GWR calculation with bandwidth auto selection",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "propertyY",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "propertiesX",
        "type": "String",
        "description": "independent variable properties, seperated by \",\" "
      },
      {
        "name": "kernel",
        "type": "String",
        "description": "kernel function: including gaussian (default), exponential, bisquare, tricube, boxcar",
        "default": "gaussian"
      },
      {
        "name": "approach",
        "type": "String",
        "description": "approach function: AICc, CV",
        "default": "AICc"
      },
      {
        "name": "adaptive",
        "type": "Boolean",
        "description": "true for adaptive distance, false for fixed distance",
        "default": "false"
      }
    ]
  },
  "SpatialStats.GWModels.GWRbasic.fit": {
    "description": "Basic GWR calculation with specific bandwidth",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "propertyY",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "propertiesX",
        "type": "String",
        "description": "independent variable properties, seperated by \",\" "
      },
      {
        "name": "bandwidth",
        "type": "Double",
        "description": "bandwidth value"
      },
      {
        "name": "kernel",
        "type": "String",
        "description": "kernel function: including gaussian (default), exponential, bisquare, tricube, boxcar",
        "default": "gaussian"
      },
      {
        "name": "adaptive",
        "type": "Boolean",
        "description": "true for adaptive distance, false for fixed distance",
        "default": "false"
      }
    ]
  },
  "SpatialStats.GWModels.GWRbasic.auto": {
    "description": "Basic GWR calculation with variable selection and bandwidth auto selection",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "propertyY",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "propertiesX",
        "type": "String",
        "description": "independent variable properties, seperated by \",\" "
      },
      {
        "name": "kernel",
        "type": "String",
        "description": "kernel function: including gaussian (default), exponential, bisquare, tricube, boxcar",
        "default": "gaussian"
      },
      {
        "name": "approach",
        "type": "String",
        "description": "approach function: AICc, CV",
        "default": "AICc"
      },
      {
        "name": "adaptive",
        "type": "Boolean",
        "description": "true for adaptive distance, false for fixed distance",
        "default": "false"
      },
      {
        "name": "varSelTh",
        "type": "Double",
        "description": "threshold of variable selection, default: 3.0",
        "default": "3.0",
        "optional": "True"
      }
    ]
  },
  "SpatialStats.BasicStatistics.AverageNearestNeighbor": {
    "description": "Average nearest neighbor stastics for feature",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input for calculation"
      }
    ]
  },
  "SpatialStats.BasicStatistics.DescriptiveStatistics": {
    "description": "Descriptive statistics for specific property of feature",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input for calculation"
      }
    ]
  },
  "SpatialStats.STCorrelations.CorrelationAnalysis.corrMat": {
    "description": "Correlation matrix for properties",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "The properties to calculate, seperated by \",\" "
      },
      {
        "name": "method",
        "type": "String",
        "description": "pearson or spearman method, default: pearson",
        "default": "pearson"
      }
    ]
  },
  "SpatialStats.STCorrelations.SpatialAutoCorrelation.globalMoranI": {
    "description": "Global Moran'I calculator for feature",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to calculate."
      },
      {
        "name": "plot",
        "type": "Boolean",
        "description": "whether to plot Moran points or not, default: false",
        "default": "false",
        "optional": "True"
      },
      {
        "name": "test",
        "type": "Boolean",
        "description": "whether to calculate p value, default: false",
        "default": "false",
        "optional": "True"
      },
      {
        "name": "weightstyle",
        "type": "String",
        "description": "neighbor weight type, including: W, B, C, U, default: W",
        "default": "\"W\"",
        "optional": "True"
      }
    ]
  },
  "SpatialStats.STCorrelations.SpatialAutoCorrelation.localMoranI": {
    "description": "Local Moran'I calculator for feature",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to calculate."
      },
      {
        "name": "adjust",
        "type": "Boolean",
        "description": "whether to adjust n, default: false",
        "default": "false",
        "optional": "True"
      }
    ]
  },
  "SpatialStats.STCorrelations.TemporalAutoCorrelation.ACF": {
    "description": "Autocorrelation Coefficient",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to calculate"
      },
      {
        "name": "timelag",
        "type": "Int",
        "description": "time lag"
      }
    ]
  },
  "SpatialStats.SpatialRegression.SpatialLagModel.fit": {
    "description": "Spatial Lag Model (SLM) for spatial regression",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "propertyY",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "propertiesX",
        "type": "String",
        "description": "independent variable properties, seperated by \",\" "
      }
    ]
  },
  "SpatialStats.SpatialRegression.SpatialErrorModel.fit": {
    "description": "Spatial Error Model (SEM) for spatial regression",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "propertyY",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "propertiesX",
        "type": "String",
        "description": "independent variable properties, seperated by \",\" "
      }
    ]
  },
  "SpatialStats.SpatialRegression.SpatialDurbinModel.fit": {
    "description": "Spatial Durbin Model (SDM) for spatial regression",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "propertyY",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "propertiesX",
        "type": "String",
        "description": "independent variable properties, seperated by \",\" "
      }
    ]
  },
  "SpatialStats.SpatialRegression.LinearRegression.feature": {
    "description": "Linear Regression for feature",
    "returns": "Feature",
    "args": [
      {
        "name": "data",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "y",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "x",
        "type": "String",
        "description": "independent variable properties, seperated by \",\" "
      },
      {
        "name": "Intercept",
        "type": "Boolean",
        "description": "whether need Intercept",
        "default": "true"
      }
    ]
  },
  "SpatialStats.GWModels.GWAverage": {
    "description": "Geographically weighted Statistic Summary: Average",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "propertyY",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "propertiesX",
        "type": "String",
        "description": "independent variable properties, seperated by \",\" "
      },
      {
        "name": "bandwidth",
        "type": "Double",
        "description": "bandwidth value"
      },
      {
        "name": "kernel",
        "type": "String",
        "description": "kernel function: including gaussian (default), exponential, bisquare, tricube, boxcar",
        "default": "gaussian"
      },
      {
        "name": "adaptive",
        "type": "Boolean",
        "description": "true for adaptive distance, false for fixed distance",
        "default": "false"
      },
      {
        "name": "quantile",
        "type": "Boolean",
        "description": "true for quantile",
        "default": "false"
      }
    ]
  },
  "SpatialStats.GWModels.GWCorrelation": {
    "description": "Geographically weighted Statistic Summary: Correlation",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "propertyY",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "propertiesX",
        "type": "String",
        "description": "independent variable properties, seperated by \",\" "
      },
      {
        "name": "bandwidth",
        "type": "Double",
        "description": "bandwidth value"
      },
      {
        "name": "kernel",
        "type": "String",
        "description": "kernel function: including gaussian (default), exponential, bisquare, tricube, boxcar",
        "default": "gaussian"
      },
      {
        "name": "adaptive",
        "type": "Boolean",
        "description": "true for adaptive distance, false for fixed distance",
        "default": "false"
      }
    ]
  },
  "SpatialStats.SpatialHeterogeneity.GeoRiskDetector": {
    "description": "RiskDetector for geoDetector",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "y_title",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "x_titles",
        "type": "String",
        "description": "independent variable properties"
      }
    ]
  },
  "SpatialStats.SpatialHeterogeneity.GeoFactorDetector": {
    "description": "FactorDetector for geoDetector",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "y_title",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "x_titles",
        "type": "String",
        "description": "independent variable properties"
      }
    ]
  },
  "SpatialStats.SpatialHeterogeneity.GeoInteractionDetector": {
    "description": "InteractionDetector for geoDetector",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "y_title",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "x_titles",
        "type": "String",
        "description": "independent variable properties"
      }
    ]
  },
  "SpatialStats.SpatialHeterogeneity.GeoEcologicalDetector": {
    "description": "EcologicalDetector for geoDetector",
    "returns": "String",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature input"
      },
      {
        "name": "y_title",
        "type": "String",
        "description": "dependent variable property"
      },
      {
        "name": "x_titles",
        "type": "String",
        "description": "independent variable properties"
      }
    ]
  },
  "algorithms.gmrc.geocorrection.GeoCorrection.geometricCorrection": {
    "description": "image geometric correction",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Collections",
        "description": "image to be geometrically corrected"
      }
    ]
  },
  "algorithms.gmrc.mosaic.Mosaic.splitMosaic": {
    "description": "image split mosaic",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Collections",
        "description": "map of image paths to be mosaiced"
      }
    ]
  },
  "Service.getSheet": {
    "description": "Getting resource Sheet data",
    "returns": "Sheet",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "sheetID",
        "type": "String",
        "description": "The id of target csv."
      }
    ]
  },
  "Service.printSheet": {
    "description": "Print the Sheet to console.",
    "returns": "Unit",
    "args": [
      {
        "name": "object",
        "type": "Sheet",
        "description": "The value to print."
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of the value."
      }
    ]
  },
  "Sheet.getcellValue": {
    "description": "get cell value at given position.",
    "returns": "String",
    "args": [
      {
        "name": "sheet",
        "type": "Sheet",
        "description": "The sheet to get cell value."
      },
      {
        "name": "row",
        "type": "Int",
        "description": "The row of the cell."
      },
      {
        "name": "col",
        "type": "Int",
        "description": "The col of the cell."
      }
    ]
  },
  "Sheet.slice": {
    "description": "slice the sheet to a new sheet.",
    "returns": "Sheet",
    "args": [
      {
        "name": "sheet",
        "type": "Sheet",
        "description": "The sheet to slice."
      },
      {
        "name": "sliceRows",
        "type": "Boolean",
        "description": "slice by rows or cols."
      },
      {
        "name": "start",
        "type": "Int",
        "description": "The begin rows/cols of the slice."
      },
      {
        "name": "end",
        "type": "Int",
        "description": "The end rows/cols of the slice."
      }
    ]
  },
  "Sheet.filterByHeader": {
    "description": "select new sheet by header condition.",
    "returns": "Sheet",
    "args": [
      {
        "name": "sheet",
        "type": "Sheet",
        "description": "The sheet to select."
      },
      {
        "name": "condition",
        "type": "String",
        "description": "The name of select header."
      },
      {
        "name": "value",
        "type": "String",
        "description": "The value of select header."
      }
    ]
  },
  "Sheet.toPoint": {
    "description": "convert sheet to point feature.",
    "returns": "Feature",
    "args": [
      {
        "name": "sheet",
        "type": "Sheet",
        "description": "The sheet to convert."
      },
      {
        "name": "lat_column",
        "type": "String",
        "description": "The column to get latitude.",
        "default": "lat",
        "optional": "True"
      },
      {
        "name": "lon_column",
        "type": "String",
        "description": "The column to get longitude.",
        "default": "lon",
        "optional": "True"
      }
    ]
  },
  "Sheet.pointToSheet": {
    "description": "convert point feature to sheet.",
    "returns": "Sheet",
    "args": [
      {
        "name": "point",
        "type": "Feature",
        "description": "The point feature to convert."
      }
    ]
  },
  "algorithms.gmrc.colorbalance.ColorBalance.colorBalance": {
    "description": "image color balance",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "image to be color balance"
      }
    ]
  },
  "algorithms.gmrc.colorbalanceRef.ColorBalanceWithRef.colorBalanceRef": {
    "description": "image color balance with reference",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "Collections",
        "description": "image to be color balance and reference"
      }
    ]
  },
  "Dataset.encoding": {
    "description": "TrainingDML-AI encoding of dataset in oge",
    "returns": "String",
    "args": [
      {
        "name": "datasetName",
        "type": "String",
        "description": "name of dataset for the encoding"
      }
    ]
  },
  "AI.ANNClassification": {
    "description": "Classify image using ANN.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "Coverage to be classified."
      },
      {
        "name": "sampleFiles",
        "type": "List[String]",
        "description": "Sample files to train the model."
      }
    ]
  },
  "AI.SVMClassification": {
    "description": "Classify image using SVM.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "Coverage to be classified."
      },
      {
        "name": "sampleFiles",
        "type": "List[String]",
        "description": "Sample files to train the model."
      }
    ]
  },
  "Coverage.reflectanceReconstruction": {
    "description": "",
    "returns": "Coverage",
    "args": [
      {
        "name": "MOD09A1",
        "type": "Coverage",
        "description": "Coverage1"
      },
      {
        "name": "LAI",
        "type": "Coverage",
        "description": "Coverage2"
      },
      {
        "name": "FAPAR",
        "type": "Coverage",
        "description": "Coverage3"
      },
      {
        "name": "NDVI",
        "type": "Coverage",
        "description": "Coverage4"
      },
      {
        "name": "EVI",
        "type": "Coverage",
        "description": "Coverage5"
      },
      {
        "name": "FVC",
        "type": "Coverage",
        "description": "Coverage6"
      },
      {
        "name": "GPP",
        "type": "Coverage",
        "description": "Coverage7"
      },
      {
        "name": "NPP",
        "type": "Coverage",
        "description": "Coverage8"
      },
      {
        "name": "ALBEDO",
        "type": "Coverage",
        "description": "Coverage9"
      },
      {
        "name": "COPY",
        "type": "Coverage",
        "description": "Coverage10"
      }
    ]
  },
  "Coverage.surfaceAlbedoLocalNoon": {
    "description": "",
    "returns": "Coverage",
    "args": [
      {
        "name": "TOAReflectance",
        "type": "Coverage",
        "description": "Coverage1"
      },
      {
        "name": "solarZenith",
        "type": "Coverage",
        "description": "Coverage2"
      },
      {
        "name": "solarAzimuth",
        "type": "Coverage",
        "description": "Coverage3"
      },
      {
        "name": "sensorZenith",
        "type": "Coverage",
        "description": "Coverage4"
      },
      {
        "name": "sensorAzimuth",
        "type": "Coverage",
        "description": "Coverage5"
      },
      {
        "name": "cloudMask",
        "type": "Coverage",
        "description": "Coverage6"
      },
      {
        "name": "timeStamp",
        "type": "String",
        "description": "timeStamp"
      },
      {
        "name": "localnoonCoefs",
        "type": "String",
        "description": "localnoonCoefs"
      },
      {
        "name": "parameters",
        "type": "String",
        "description": "parameters"
      },
      {
        "name": "bands",
        "type": "Int",
        "description": "bands num"
      }
    ]
  },
  "Coverage.imaginaryConstellations": {
  "description": "",
  "returns": "Coverage",
  "args": [
    {
      "name": "LAI",
      "type": "Coverage",
      "description": "Coverage2"
    },
    {
      "name": "FAPAR",
      "type": "Coverage",
      "description": "Coverage3"
    },
    {
      "name": "NDVI",
      "type": "Coverage",
      "description": "Coverage4"
    },
    {
      "name": "FVC",
      "type": "Coverage",
      "description": "Coverage6"
    },
    {
      "name": "ALBEDO",
      "type": "Coverage",
      "description": "Coverage7"
    }
  ]
},
  "Coverage.RandomForestTrainAndRegress": {
    "description": "",
    "returns": "Coverage",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "featuresCoverage"
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "labelCoverage"
      },
      {
        "name": "predictCoverage",
        "type": "Coverage",
        "description": "predictCoverage"
      },
      {
        "name": "checkpointInterval",
        "type": "Int",
        "description": "checkpointInterval",
        "optional": "True",
        "default": "10"
      },
      {
        "name": "featureSubsetStrategy",
        "type": "String",
        "description": "featureSubsetStrategy",
        "optional": "True",
        "default": "auto"
      },
      {
        "name": "impurity",
        "type": "String",
        "description": "impurity",
        "optional": "True",
        "default": "variance"
      },
      {
        "name": "maxBins",
        "type": "Int",
        "description": "maxBins",
        "optional": "True",
        "default": "32"
      },
      {
        "name": "maxDepth",
        "type": "Int",
        "description": "maxDepth",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "minInfoGain",
        "type": "Double",
        "description": "minInfoGain",
        "optional": "True",
        "default": "0.0"
      },
      {
        "name": "minInstancesPerNode",
        "type": "Int",
        "description": "minInstancesPerNode",
        "optional": "True",
        "default": "1"
      },
      {
        "name": "minWeightFractionPerNode",
        "type": "Double",
        "description": "minWeightFractionPerNode",
        "optional": "True",
        "default": "0.0"
      },
      {
        "name": "numTrees",
        "type": "Int",
        "description": "numTrees",
        "optional": "True",
        "default": "20"
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "seed",
        "optional": "True",
        "default": "123L"
      },
      {
        "name": "subsamplingRate",
        "type": "Double",
        "description": "subsamplingRate",
        "optional": "True",
        "default": "1.0"
      }
    ]
  },
  "Coverage.histogramBin": {
    "description": "",
    "returns": "Map[Int,Long]",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "coverage"
      },
      {
        "name": "min",
        "type": "Int",
        "description": "min"
      },
      {
        "name": "max",
        "type": "Int",
        "description": "max"
      },
      {
        "name": "binSize",
        "type": "Int",
        "description": "binSize"
      },
      {
        "name": "bandIndex",
        "type": "Int",
        "description": "bandIndex",
        "optional": "True",
        "default": "0"
      }
    ]
  },
  "Coverage.reduceRegion": {
    "description": "",
    "returns": "Double",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "coverage"
      },
      {
        "name": "reducer",
        "type": "String",
        "description": "reducer"
      },
      {
        "name": "bandIndex",
        "type": "Int",
        "description": "bandIndex",
        "optional": "True",
        "default": "0"
      }
    ]
  },
  "Coverage.filter": {
    "description": "",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "coverage"
      },
      {
        "name": "min",
        "type": "Double",
        "description": "min"
      },
      {
        "name": "max",
        "type": "Double",
        "description": "max"
      }
    ]
  },
  "MLmodel.randomForestClassifierModel": {
    "description": "randomForestClassifierModel training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "checkpointInterval",
        "type": "Integer",
        "description": "One of the parameters."
      },
      {
        "name":"featureSubsetStrategy",
        "type": "String",
        "description": "One of the parameters.",
        "optional": "True",
        "default": "auto"
      },
      {
        "name": "maxBins",
        "type": "Int",
        "description": "One of the parameters.",
        "optional": "True",
        "default": "32"
      },
      {
        "name": "maxDepth",
        "type": "Int",
        "description": "One of the parameters.",
        "optional": "True",
        "default": "5"
      },
      {
        "name": "minInfoGain",
        "type": "Double",
        "description": "One of the parameters.",
        "optional": "True",
        "default": "0.0"
      },
      {
        "name": "minInstancesPerNode",
        "type": "Int",
        "description": "One of the parameters.",
        "optional": "True",
        "default": "1"
      },
      {
        "name": "minWeightFractionPerNode",
        "type": "Double",
        "description": "One of the parameters.",
        "optional": "True",
        "default": "0.0"
      },
      {
        "name": "numTrees",
        "type": "Int",
        "description": "One of the parameters.",
        "optional": "True",
        "default": "20"
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "One of the parameters.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "subsamplingRate",
        "type": "Double",
        "description": "One of the parameters.",
        "optional": "True",
        "default": "1.0"
      }
    ]
  },
  "MLmodel.logisticRegressionClassifierModel": {
    "description": "logisticRegressionClassifierModel training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations for the optimizer.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "regParam",
        "type": "Double",
        "description": "Regularization parameter for the model.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "elasticNetParam",
        "type": "Double",
        "description": "Elastic net mixing parameter (0: L2 regularization, 1: L1 regularization).",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "family",
        "type": "String",
        "description": "The family of logistic regression (e.g., 'auto', 'binomial', 'multinomial').",
        "optional": "True",
        "default": "auto"
      },
      {
        "name": "fitIntercept",
        "type": "Boolean",
        "description": "Whether to fit an intercept term in the model.",
        "optional": "True",
        "default": true
      },
      {
        "name": "standardization",
        "type": "Boolean",
        "description": "Whether to standardize features before training.",
        "optional": "True",
        "default": true
      },
      {
        "name": "threshold",
        "type": "Double",
        "description": "The threshold for binary classification prediction.",
        "optional": "True",
        "default": 0.5
      },
      {
        "name": "tol",
        "type": "Double",
        "description": "The convergence tolerance for iterative algorithms.",
        "optional": "True",
        "default": 1E-6
      }
    ]
  },
  "MLmodel.decisionTreeClassifierModel": {
    "description": "decisionTreeClassifierModel training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "checkpointInterval",
        "type": "Int",
        "description": "How often to checkpoint the model (in terms of iterations).",
        "optional": "True",
        "default": 10
      },
      {
        "name": "impurity",
        "type": "String",
        "description": "Criterion to measure the quality of a split (e.g., 'gini', 'entropy').",
        "optional": "True",
        "default": "gini"
      },
      {
        "name": "maxBins",
        "type": "Int",
        "description": "Maximum number of bins used when discretizing continuous features.",
        "optional": "True",
        "default": 32
      },
      {
        "name": "maxDepth",
        "type": "Int",
        "description": "The maximum depth of the tree.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "minInstancesPerNode",
        "type": "Int",
        "description": "Minimum number of instances each node must have.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minWeightFractionPerNode",
        "type": "Double",
        "description": "Minimum fraction of the total weight of instances required to be at a node.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Random seed used for deterministic behavior.",
        "optional": "True",
        "default": 0
      }
    ]
  },
  "MLmodel.gbtClassifierClassifierModel": {
    "description": "Gradient Boosted Trees classifier model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations (boosting rounds).",
        "optional": "True",
        "default": 10
      },
      {
        "name": "featureSubsetStrategy",
        "type": "String",
        "description": "The number of features to consider for splits at each tree node.",
        "optional": "True",
        "default": "auto"
      },
      {
        "name": "checkpointInterval",
        "type": "Int",
        "description": "Frequency of checkpointing the model.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "impurity",
        "type": "String",
        "description": "Criterion to measure the quality of a split (e.g., 'variance').",
        "optional": "True",
        "default": "variance"
      },
      {
        "name": "lossType",
        "type": "String",
        "description": "Loss function to be minimized (e.g., 'logistic').",
        "optional": "True",
        "default": "logistic"
      },
      {
        "name": "maxBins",
        "type": "Int",
        "description": "Maximum number of bins used for discretizing continuous features.",
        "optional": "True",
        "default": 32
      },
      {
        "name": "maxDepth",
        "type": "Int",
        "description": "The maximum depth of the tree.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "minInfoGain",
        "type": "Double",
        "description": "Minimum information gain for a split to be considered at a node.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "minInstancesPerNode",
        "type": "Int",
        "description": "Minimum number of instances each node must have.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minWeightFractionPerNode",
        "type": "Double",
        "description": "Minimum fraction of the total weight required at a node.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Random seed for reproducibility.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "stepSize",
        "type": "Double",
        "description": "Step size for each iteration of boosting (learning rate).",
        "optional": "True",
        "default": 0.1
      },
      {
        "name": "subSamplingRate",
        "type": "Double",
        "description": "Fraction of the data to be used for training each tree.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "MLmodel.multilayerPerceptronClassifierModel": {
    "description": "Multilayer Perceptron classifier model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "layers",
        "type": "Array[Int]",
        "description": "The array representing the number of nodes in each layer."
      },
      {
        "name": "blockSize",
        "type": "Int",
        "description": "The number of training examples per block.",
        "optional": "True",
        "default": 128
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Random seed for reproducibility.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "stepSize",
        "type": "Double",
        "description": "Step size for gradient descent.",
        "optional": "True",
        "default": 0.03
      },
      {
        "name": "tol",
        "type": "Double",
        "description": "Tolerance for stopping criteria.",
        "optional": "True",
        "default": 1E-6
      }
    ]
  },
  "MLmodel.linearSVCClassifierModel": {
    "description": "Linear Support Vector Classifier (SVC) model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The RDD of images representing feature data."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The RDD of images representing label data."
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations for training.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "regParam",
        "type": "Double",
        "description": "Regularization parameter to prevent overfitting.",
        "optional": "True",
        "default": 0.1
      }
    ]
  },
  "MLmodel.naiveBayesClassifierModel": {
    "description": "Naive Bayes classifier model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "modelType",
        "type": "String",
        "description": "The type of Naive Bayes model ('multinomial', 'bernoulli').",
        "optional": "True",
        "default": "multinomial"
      },
      {
        "name": "smoothing",
        "type": "Double",
        "description": "Smoothing parameter to avoid zero probabilities.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "MLmodel.fmClassifierModel": {
    "description": "Factorization Machines classifier model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "stepSize",
        "type": "Double",
        "description": "Step size for each iteration.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "factorSize",
        "type": "Int",
        "description": "Dimensionality of the factorization.",
        "optional": "True",
        "default": 8
      },
      {
        "name": "fitIntercept",
        "type": "Boolean",
        "description": "Whether to fit the intercept term.",
        "optional": "True",
        "default": true
      },
      {
        "name": "fitLinear",
        "type": "Boolean",
        "description": "Whether to fit the linear term.",
        "optional": "True",
        "default": true
      },
      {
        "name": "initStd",
        "type": "Double",
        "description": "Initial standard deviation for the factorization.",
        "optional": "True",
        "default": 0.01
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "minBatchFraction",
        "type": "Double",
        "description": "Fraction of data used for mini-batch gradient descent.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "regParam",
        "type": "Double",
        "description": "Regularization parameter.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Random seed for reproducibility.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "solver",
        "type": "String",
        "description": "Optimization solver to use ('adamW', etc.).",
        "optional": "True",
        "default": "adamW"
      },
      {
        "name": "tol",
        "type": "Double",
        "description": "Tolerance for stopping criteria.",
        "optional": "True",
        "default": 1E-6
      }
    ]
  },
  "MLmodel.oneVsRestClassifierModel": {
    "description": "One-vs-Rest (OvR) classifier model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "classifier",
        "type": "String",
        "description": "The base classifier used for each binary classification ('logisticRegression', etc.).",
        "optional": "True",
        "default": "logisticRegression"
      }
    ]
  },
  "MLmodel.modelClassify": {
    "description": "classifying method.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to be predicted."
      },
      {
        "name": "model",
        "type": "MLmodel",
        "description": "The model."
      }
    ]
  },

  "MLmodel.randomForestRegressionModel": {
    "description": "Random Forest regression model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "checkpointInterval",
        "type": "Int",
        "description": "Checkpoint interval for caching intermediate models.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "featureSubsetStrategy",
        "type": "String",
        "description": "Strategy to choose a subset of features ('auto', 'sqrt', etc.).",
        "optional": "True",
        "default": "auto"
      },
      {
        "name": "impurity",
        "type": "String",
        "description": "Criterion used for information gain calculation ('variance').",
        "optional": "True",
        "default": "variance"
      },
      {
        "name": "maxBins",
        "type": "Int",
        "description": "Maximum number of bins used for splitting features.",
        "optional": "True",
        "default": 32
      },
      {
        "name": "maxDepth",
        "type": "Int",
        "description": "Maximum depth of the trees.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "minInfoGain",
        "type": "Double",
        "description": "Minimum information gain required for splitting a node.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "minInstancesPerNode",
        "type": "Int",
        "description": "Minimum number of instances required to split a node.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minWeightFractionPerNode",
        "type": "Double",
        "description": "Minimum fraction of the total weight needed to split a node.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "numTrees",
        "type": "Int",
        "description": "Number of trees in the forest.",
        "optional": "True",
        "default": 20
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Random seed for reproducibility.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "subsamplingRate",
        "type": "Double",
        "description": "Fraction of data used for training each tree.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "MLmodel.linearRegressionModel": {
    "description": "Linear regression model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "regParam",
        "type": "Double",
        "description": "Regularization parameter (lambda).",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "elasticNetParam",
        "type": "Double",
        "description": "Elastic net mixing parameter (0 = L2, 1 = L1).",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "fitIntercept",
        "type": "Boolean",
        "description": "Whether to fit the intercept term.",
        "optional": "True",
        "default": true
      },
      {
        "name": "loss",
        "type": "String",
        "description": "Loss function to minimize ('squaredError').",
        "optional": "True",
        "default": "squaredError"
      },
      {
        "name": "solver",
        "type": "String",
        "description": "Solver algorithm used ('auto').",
        "optional": "True",
        "default": "auto"
      },
      {
        "name": "standardization",
        "type": "Boolean",
        "description": "Whether to standardize features before fitting.",
        "optional": "True",
        "default": true
      },
      {
        "name": "tol",
        "type": "Double",
        "description": "Tolerance for stopping criteria.",
        "optional": "True",
        "default": 1E-6
      }
    ]
  },
  "MLmodel.generalizedLinearRegressionModel": {
    "description": "Generalized linear regression model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "regParam",
        "type": "Double",
        "description": "Regularization parameter (lambda).",
        "optional": "True",
        "default": 0.3
      },
      {
        "name": "family",
        "type": "String",
        "description": "Distribution family ('gaussian', 'binomial', etc.).",
        "optional": "True",
        "default": "gaussian"
      },
      {
        "name": "link",
        "type": "String",
        "description": "Link function ('identity', 'log').",
        "optional": "True",
        "default": "identity"
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "fitIntercept",
        "type": "Boolean",
        "description": "Whether to fit the intercept term.",
        "optional": "True",
        "default": true
      },
      {
        "name": "linkPower",
        "type": "Double",
        "description": "The index for the power link function.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "solver",
        "type": "String",
        "description": "Optimization solver to use ('irls').",
        "optional": "True",
        "default": "irls"
      },
      {
        "name": "tol",
        "type": "Double",
        "description": "Tolerance for stopping criteria.",
        "optional": "True",
        "default": 1E-6
      },
      {
        "name": "variancePower",
        "type": "Double",
        "description": "The power of the variance function.",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "MLmodel.decisionTreeRegressionModel": {
    "description": "Decision tree regression model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "checkpointInterval",
        "type": "Int",
        "description": "Checkpoint interval for caching intermediate models.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "impurity",
        "type": "String",
        "description": "Criterion used for information gain calculation ('variance').",
        "optional": "True",
        "default": "variance"
      },
      {
        "name": "maxBins",
        "type": "Int",
        "description": "Maximum number of bins used for splitting features.",
        "optional": "True",
        "default": 32
      },
      {
        "name": "maxDepth",
        "type": "Int",
        "description": "Maximum depth of the tree.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "minInfoGain",
        "type": "Double",
        "description": "Minimum information gain required for splitting a node.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "minInstancesPerNode",
        "type": "Int",
        "description": "Minimum number of instances required to split a node.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minWeightFractionPerNode",
        "type": "Double",
        "description": "Minimum fraction of the total weight needed to split a node.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Random seed for reproducibility.",
        "optional": "True",
        "default": 0
      }
    ]
  },
  "MLmodel.gbtRegressionModel": {
    "description": "Gradient Boosted Trees (GBT) regression model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "checkpointInterval",
        "type": "Int",
        "description": "Checkpoint interval for caching intermediate models.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "featureSubsetStrategy",
        "type": "String",
        "description": "Strategy to choose a subset of features ('auto').",
        "optional": "True",
        "default": "auto"
      },
      {
        "name": "impurity",
        "type": "String",
        "description": "Criterion used for information gain calculation ('variance').",
        "optional": "True",
        "default": "variance"
      },
      {
        "name": "lossType",
        "type": "String",
        "description": "Type of loss function ('squared').",
        "optional": "True",
        "default": "squared"
      },
      {
        "name": "maxBins",
        "type": "Int",
        "description": "Maximum number of bins used for splitting features.",
        "optional": "True",
        "default": 32
      },
      {
        "name": "maxDepth",
        "type": "Int",
        "description": "Maximum depth of the trees.",
        "optional": "True",
        "default": 5
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "minInfoGain",
        "type": "Double",
        "description": "Minimum information gain required for splitting a node.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "minInstancesPerNode",
        "type": "Int",
        "description": "Minimum number of instances required to split a node.",
        "optional": "True",
        "default": 1
      },
      {
        "name": "minWeightFractionPerNode",
        "type": "Double",
        "description": "Minimum fraction of the total weight needed to split a node.",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Random seed for reproducibility.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "stepSize",
        "type": "Double",
        "description": "Step size (learning rate) for gradient descent.",
        "optional": "True",
        "default": 0.1
      },
      {
        "name": "subsamplingRate",
        "type": "Double",
        "description": "Fraction of data used for training each tree.",
        "optional": "True",
        "default": 1.0
      }
    ]
  },
  "MLmodel.isotonicRegressionModel": {
    "description": "Isotonic regression model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "isotonic",
        "type": "Boolean",
        "description": "If true, fits an isotonic (increasing) regression, otherwise fits an antitonic (decreasing) regression.",
        "optional": "True",
        "default": true
      }
    ]
  },
  "MLmodel.fmRegressionModel": {
    "description": "Factorization Machines (FM) regression model training method.",
    "returns": "MLmodel",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The featuresCoverage."
      },
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The labelCoverage."
      },
      {
        "name": "factorSize",
        "type": "Int",
        "description": "The dimensionality of the factorization.",
        "optional": "True",
        "default": 8
      },
      {
        "name": "fitIntercept",
        "type": "Boolean",
        "description": "Whether to fit an intercept term.",
        "optional": "True",
        "default": true
      },
      {
        "name": "fitLinear",
        "type": "Boolean",
        "description": "Whether to fit linear terms.",
        "optional": "True",
        "default": true
      },
      {
        "name": "initStd",
        "type": "Double",
        "description": "Standard deviation of initial random weights.",
        "optional": "True",
        "default": 0.01
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations.",
        "optional": "True",
        "default": 100
      },
      {
        "name": "minBatchFraction",
        "type": "Double",
        "description": "Fraction of data to use for each mini-batch during stochastic gradient descent.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "regParam",
        "type": "Double",
        "description": "Regularization parameter (lambda).",
        "optional": "True",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Random seed for reproducibility.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "solver",
        "type": "String",
        "description": "Solver to use for optimization ('adamW').",
        "optional": "True",
        "default": "adamW"
      },
      {
        "name": "stepSize",
        "type": "Double",
        "description": "Step size (learning rate) for gradient descent.",
        "optional": "True",
        "default": 1.0
      },
      {
        "name": "tol",
        "type": "Double",
        "description": "Tolerance for stopping criteria.",
        "optional": "True",
        "default": 1E-6
      }
    ]
  },
  "MLmodel.modelRegress": {
    "description": "regression method.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage to be predicted."
      },
      {
        "name": "model",
        "type": "MLmodel",
        "description": "The model."
      }
    ]
  },

  "MLmodel.mlKMeans": {
    "description": "K-means clustering model training method.",
    "returns": "Coverage",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The feature coverage data in RDDImage format."
      },
      {
        "name": "k",
        "type": "Int",
        "description": "Number of clusters.",
        "optional": "True",
        "default": 2
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Seed for random number generation.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "tol",
        "type": "Double",
        "description": "Tolerance for convergence.",
        "optional": "True",
        "default": 1E-6
      }
    ]
  },
  "MLmodel.latentDirichletAllocation": {
    "description": "Latent Dirichlet Allocation (LDA) model training method.",
    "returns": "Coverage",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The feature coverage data in RDDImage format."
      },
      {
        "name": "checkpointInterval",
        "type": "Int",
        "description": "How often to checkpoint the model.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "k",
        "type": "Int",
        "description": "Number of topics.",
        "optional": "True",
        "default": 2
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "optimizer",
        "type": "String",
        "description": "Optimizer to be used ('online' or 'em').",
        "optional": "True",
        "default": "online"
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Seed for random number generation.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "subsamplingRate",
        "type": "Double",
        "description": "Fraction of the data to use for training.",
        "optional": "True",
        "default": 0.05
      },
      {
        "name": "topicConcentration",
        "type": "Double",
        "description": "Concentration parameter for the topics.",
        "optional": "True",
        "default": -1
      }
    ]
  },
  "MLmodel.bisectingKMeans": {
    "description": "Bisecting K-means clustering model training method.",
    "returns": "Coverage",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The feature coverage data in RDDImage format."
      },
      {
        "name": "distanceMeasure",
        "type": "String",
        "description": "Distance measure to be used (e.g., 'euclidean').",
        "optional": "True",
        "default": "euclidean"
      },
      {
        "name": "k",
        "type": "Int",
        "description": "Number of clusters.",
        "optional": "True",
        "default": 4
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Seed for random number generation.",
        "optional": "True",
        "default": 0
      }
    ]
  },
  "MLmodel.gaussianMixture": {
    "description": "Gaussian Mixture Model (GMM) training method.",
    "returns": "Coverage",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The feature coverage data in RDDImage format."
      },
      {
        "name": "k",
        "type": "Int",
        "description": "Number of Gaussian components.",
        "optional": "True",
        "default": 2
      },
      {
        "name": "maxIter",
        "type": "Int",
        "description": "Maximum number of iterations.",
        "optional": "True",
        "default": 10
      },
      {
        "name": "seed",
        "type": "Long",
        "description": "Seed for random number generation.",
        "optional": "True",
        "default": 0
      },
      {
        "name": "tol",
        "type": "Double",
        "description": "Tolerance for convergence.",
        "optional": "True",
        "default": 1E-6
      }
    ]
  },

  "MLmodel.multiclassClassificationEvaluator": {
    "description": "Multiclass classification evaluator method.",
    "returns": "String",
    "args": [
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The ground truth label coverage data."
      },
      {
        "name": "predictionCoverage",
        "type": "Coverage",
        "description": "The prediction coverage data."
      },
      {
        "name": "metricName",
        "type": "List[String]",
        "description": "List of metric names to evaluate.",
        "optional": "True",
        "default": "['f1']"
      },
      {
        "name": "metricLabel",
        "type": "Double",
        "description": "The class label for which the metric will be evaluated.",
        "optional": "True",
        "default": 0.0
      }
    ]
  },
  "MLmodel.clusteringEvaluator": {
    "description": "Clustering evaluator method.",
    "returns": "String",
    "args": [
      {
        "name": "featuresCoverage",
        "type": "Coverage",
        "description": "The feature coverage data."
      },
      {
        "name": "predictionCoverage",
        "type": "Coverage",
        "description": "The prediction coverage data."
      },
      {
        "name": "metricName",
        "type": "String",
        "description": "The metric to evaluate, e.g., 'silhouette'.",
        "optional": "True",
        "default": "silhouette"
      },
      {
        "name": "distanceMeasure",
        "type": "String",
        "description": "Distance measure to use, e.g., 'squaredEuclidean'.",
        "optional": "True",
        "default": "squaredEuclidean"
      }
    ]
  },
  "MLmodel.multilabelClassificationEvaluator": {
    "description": "Multilabel classification evaluator method.",
    "returns": "String",
    "args": [
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The ground truth label coverage data."
      },
      {
        "name": "predictionCoverage",
        "type": "Coverage",
        "description": "The prediction coverage data."
      },
      {
        "name": "metricName",
        "type": "List[String]",
        "description": "List of metric names to evaluate.",
        "optional": "True",
        "default": "['f1Measure']"
      }
    ]
  },
  "MLmodel.binaryClassificationEvaluator": {
    "description": "Binary classification evaluator method.",
    "returns": "String",
    "args": [
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The ground truth label coverage data."
      },
      {
        "name": "predictionCoverage",
        "type": "Coverage",
        "description": "The prediction coverage data."
      },
      {
        "name": "metricName",
        "type": "List[String]",
        "description": "List of metric names to evaluate.",
        "optional": "True",
        "default": "['areaUnderROC']"
      }
    ]
  },
  "MLmodel.regressionEvaluator": {
    "description": "Regression evaluator method.",
    "returns": "String",
    "args": [
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The ground truth label coverage data."
      },
      {
        "name": "predictionCoverage",
        "type": "Coverage",
        "description": "The prediction coverage data."
      },
      {
        "name": "metricName",
        "type": "List[String]",
        "description": "List of metric names to evaluate.",
        "optional": "True",
        "default": "['rmse']"
      }
    ]
  },
  "MLmodel.rankingEvaluator": {
    "description": "Ranking evaluator method.",
    "returns": "String",
    "args": [
      {
        "name": "labelCoverage",
        "type": "Coverage",
        "description": "The ground truth label coverage data."
      },
      {
        "name": "predictionCoverage",
        "type": "Coverage",
        "description": "The prediction coverage data."
      },
      {
        "name": "metricName",
        "type": "List[String]",
        "description": "List of metric names to evaluate.",
        "optional": "True",
        "default": "['meanAveragePrecision']"
      }
    ]
  }

}