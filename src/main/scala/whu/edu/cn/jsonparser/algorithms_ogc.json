{
  "Image.load": {
    "description": "Returns the images by given id",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "productName",
        "type": "String",
        "description": "The name of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "sensorName",
        "type": "String",
        "description": "The sensor of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "measurementName",
        "type": "String",
        "description": "The measurement of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "StartTime",
        "type": "String",
        "description": "The start time of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "EndTime",
        "type": "String",
        "description": "The end time of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "geom",
        "type": "List<Float>",
        "description": "The geom of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "The crs of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "method",
        "type": "String",
        "description": "The method of reslicing.",
        "optional": "True",
        "default": "null"
      }
    ]
  },
  "CoverageCollection.deepLearning": {
    "description": "Get the deep learning results of the input image",
    "returns": "Coverage<unknown bands>",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection<unknown bands>",
        "description": "The image of input."
      },
      {
        "name": "class",
        "type": "String",
        "description": "The class of the deep learning."
      }
    ]
  },
  "Coverage.deepLearning": {
    "description": "Get the deep learning results of the input image",
    "returns": "Coverage<unknown bands>",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage<unknown bands>",
        "description": "The coverage of input."
      },
      {
        "name": "class",
        "type": "String",
        "description": "The class of the deep learning."
      }
    ]
  },
  "Image.add": {
    "description": "Adds the first value to the second for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types. ",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "image1",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "image2",
        "type": "Image<unknown bands>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Image.subtract": {
    "description": "Subtracts the second value from the first for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "image1",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "image2",
        "type": "Image<unknown bands>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Image.multiply": {
    "description": "multiply the second value from the first for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "image1",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "image2",
        "type": "Image<unknown bands>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Image.divide": {
    "description": "Divides the first value by the second, returning 0 for division by 0 for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "Image",
    "args": [
      {
        "name": "image1",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "image2",
        "type": "Image<unknown bands>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Image.normalizedDifference": {
    "description": "Computes the normalized difference between two bands.The normalized difference is computed as (first − second) / (first + second). ",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "input",
        "type": "Image<unknown bands>",
        "description": "The input image"
      },
      {
        "name": "bandNames",
        "type": "List<String>",
        "description": "A list of names specifying the bands to use. If not specified, the first and second bands are used",
        "optional": "True",
        "default": "None"
      }
    ]
  },
  "Image.binaryzation": {
    "description": "Returns 0 iff the first value is smaller than threshold,else return 255",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken"
      },
      {
        "name": "threshold",
        "type": "Int",
        "description": "threshold"
      }
    ]
  },
  "Image.and": {
    "description": "Returns 1 iff both values are non-zero for each matched pair of bands in image1 and image2.if both have only 1 band, the 2 band will match",
    "returns": "Image",
    "args": [
      {
        "name": "image1",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "image2",
        "type": "Image<unknown bands>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Image.or": {
    "description": "Returns 1 iff either values are non-zero for each matched pair of bands in image1 and image2.if both have only 1 band, the 2 band will match",
    "returns": "Image",
    "args": [
      {
        "name": "image1",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "image2",
        "type": "Image<unknown bands>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Image.not": {
    "description": "Returns 0 if the input is non-zero, and 1 otherwise",
    "returns": "Image",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      }
    ]
  },
  "Image.sin": {
    "description": "Computes the sine of the input in radians.",
    "returns": "Image",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      }
    ]
  },
  "Image.cos": {
    "description": "Computes the cosine of the input in radians.",
    "returns": "Image",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      }
    ]
  },
  "Image.sinh": {
    "description": "Computes the hyperbolic sine of the input in radians.",
    "returns": "Image",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      }
    ]
  },
  "Image.cosh": {
    "description": "Computes the hyperbolic cosine of the input in radians.",
    "returns": "Image",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      }
    ]
  },
  "Image.asin": {
    "description": "Computes the arc sine of the input in radians.",
    "returns": "Image",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      }
    ]
  },
  "Image.acos": {
    "description": "Computes the arc cosine of the input in radians.",
    "returns": "Image",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      }
    ]
  },
  "Image.atan": {
    "description": "Computes the atan sine of the input in radians.",
    "returns": "Image",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      }
    ]
  },
  "Image.atan2": {
    "description": "Operation to get the Arc Tangent2 of values. The first raster holds the y-values, and the second holds the x values.The arctan is calculated from y/x.if both have only 1 band, the 2 band will match",
    "returns": "Image",
    "args": [
      {
        "name": "image1",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "image2",
        "type": "Image<unknown bands>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Image.ceil": {
    "description": "Computes the smallest integer greater than or equal to the input.",
    "returns": "Image",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      }
    ]
  },
  "Image.floor": {
    "description": "Computes the largest integer less than or equal to the input.",
    "returns": "Image",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      }
    ]
  },
  "Image.eq": {
    "description": "Returns 1 iff the first value is equal to the second for each matched pair of bands in image1 and image2.if both have only 1 band, the 2 band will match",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "image1",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "image2",
        "type": "Image<unknown bands>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Image.gt": {
    "description": "Returns 1 iff the first value is greater to the second for each matched pair of bands in image1 and image2.if both have only 1 band, the 2 band will match",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "image1",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "image2",
        "type": "Image<unknown bands>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Image.gte": {
    "description": "Returns 1 iff the first value is greater or equal to the second for each matched pair of bands in image1 and image2.if both have only 1 band, the 2 band will match",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "image1",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "image2",
        "type": "Image<unknown bands>",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Image.bandNames": {
    "description": "get all the bands in rdd",
    "returns": "Image",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      }
    ]
  },
  "Image.addBands": {
    "description": "Returns 1 iff the first value is greater or equal to the second for each matched pair of bands in image1 and image2.if both have only 1 band, the 2 band will match",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "image1",
        "type": "Image<unknown bands>",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "image2",
        "type": "Image<unknown bands>",
        "description": "The image from which the right operand bands are taken."
      },
      {
        "name": "names",
        "type": "List[String]",
        "description": "the name of selected bands in image2"
      },
      {
        "name": "overwrite",
        "type": "Boolean",
        "description": "if true, overwrite bands in the first image with the same name in image2"
      }
    ]
  },
  "Image.sampleRegions": {
    "description": "Converts each pixel of an image (at a given scale) that intersects one or more regions to a Feature, returning them as a FeatureCollection.  Each output feature will have one property per band of the input image, as well as any specified properties copied from the input feature.Note that geometries will be snapped to pixel centers.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image to sample"
      },
      {
        "name": "collection",
        "type": "FeatureCollection",
        "description": "The regions to sample over."
      },
      {
        "name": "properties",
        "type": "List<String>",
        "description": "The list of properties to copy from each input feature.  Defaults to all non-system properties.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "scale",
        "type": "Float",
        "description": "A nominal scale in meters of the projection to sample in.  If unspecified,the scale of the image\\'s first band is used.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "projection",
        "type": "Projection",
        "description": "The projection in which to sample. If unspecified, the projection of the image\\'s first band is used. If specified in addition to scale, rescaled to the specified scale.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "titleScale",
        "type": "Float",
        "description": "A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default.",
        "optional": "True",
        "default": "1"
      },
      {
        "name": "geometries",
        "type": "Boolean",
        "description": "If true, the results will include a point geometry per sampled pixel.  Otherwise, geometries will be omitted (saving memory).",
        "optional": "True",
        "default": "False"
      }
    ]
  },
  "Image.visualize": {
    "description": "Produces an RGB or grayscale visualization of an image.  Each of the gain, bias, min, max and gamma arguments can take either a single value, which will be applied to all bands, or a list of values the same length as bands.",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "image",
        "type": "Image",
        "description": "The image to visualize"
      },
      {
        "name": "bands",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "",
        "default": "png",
        "optional": "True"
      },
      {
        "name": "method",
        "type": "String",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "Collection.filter": {
    "description": "Applies a filter to a given collection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "collection",
        "type": "FeatureCollection",
        "description": "The collection to filter"
      },
      {
        "name": "filter",
        "type": "Object",
        "description": "The filter to apply to the collection. "
      }
    ]
  },
  "Filter.gte": {
    "description": "Creates a unary or binary filter that passes unless the left operand is less than the right operand.",
    "returns": "Filter",
    "args": [
      {
        "name": "leftField",
        "type": "String",
        "description": "A selector for the left operand. Should not be specified if leftValue is specified.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "rightValue",
        "type": "Object",
        "description": "The value of the right operand. Should not be specified if rightField is specified.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "rightField",
        "type": "String",
        "description": "A selector for the right operand. Should not be specified if rightValue is specified.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "leftValue",
        "type": "Object",
        "description": "The value of the left operand. Should not be specified if leftField is specified.",
        "optional": "True",
        "default": "None"
      }
    ]
  },
  "Collection.draw": {
    "description": "Paints a vector collection for visualization. Not intended for use as input to other algorithms.",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "collection",
        "type": "FeatureCollection",
        "description": "The collection to draw"
      },
      {
        "name": "color",
        "type": "String",
        "description": "A hex string in the format RRGGBB specifying the color to use for drawing the features."
      },
      {
        "name": "pointRadius",
        "type": "Integer",
        "description": "The radius in pixels of the point markers.",
        "optional": "True",
        "default": "3"
      },
      {
        "name": "strokeWidth",
        "type": "Integer",
        "description": "The width in pixels of lines and polygon borders.",
        "optional": "True",
        "default": "2"
      }
    ]
  },
  "Image.reproject": {
    "description": "Force an image to be computed in a given projection and resolution.",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "image",
        "type": "Image<unknown bands>",
        "description": "The image to reproject"
      },
      {
        "name": "crs",
        "type": "Projection",
        "description": "The CRS to project the image to."
      },
      {
        "name": "crsTransform",
        "type": "List<Float>",
        "description": "The list of CRS transform values.  This is a row-major ordering of the 3x2 transform matrix.  This option is mutually exclusive with the scale option, and replaces any transform already on the projection.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "scale",
        "type": "Float",
        "description": "If scale is specified, then the projection is scaled by dividing the specified scale value by the nominal size of a meter in the specified projection. If scale is not specified, then the scale of the given projection will be used.",
        "optional": "True",
        "default": "None"
      }
    ]
  },
  "Projection": {
    "description": "Returns a Projection with the given base coordinate system and the given transform between projected coordinates and the base. If no transform is specified, the identity transform is assumed.",
    "returns": "Projection",
    "args": [
      {
        "name": "crs",
        "type": "Object",
        "description": "The base coordinate reference system of this Projection, given as a well-known authority code (e.g. \\'EPSG:4326\\') or a WKT string."
      },
      {
        "name": "transform",
        "type": "List<Object>",
        "description": "The transform between projected coordinates and the base coordinate system, specified as a 2x3 affine transform matrix in row-major order: [xScale, xShearing, xTranslation, yShearing, yScale, yTranslation]. May not specify both this and 'transformWkt'.",
        "optional": "True",
        "default": "None"
      },
      {
        "name": "transformWkt",
        "type": "String",
        "description": "The transform between projected coordinates and the base coordinate system, specified as a WKT string. May not specify both this and \\'transform\\'.",
        "optional": "True",
        "default": "None"
      }
    ]
  },
  "ImageCollection.mosaic": {
    "description": "Composites all the images in a collection, using the mask.",
    "returns": "Image",
    "args": [
      {
        "name": "collection",
        "type": "ImageCollection",
        "description": "The collection to mosaic."
      }
    ]
  },
  "Image.select": {
    "description": "Selects bands from an image by name, RE2-compatible regex or index and optionally renames them.",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "input",
        "type": "Image<unknown bands>",
        "description": "The image to select bands from."
      },
      {
        "name": "bandSelectors",
        "type": "List<Object>",
        "description": "A list of names, regexes or numeric indices specifying the bands to select."
      },
      {
        "name": "newNames",
        "type": "List<String>",
        "description": "Optional new names for the output bands.  Must match the number of bands selected.",
        "optional": "True",
        "default": "None"
      }
    ]
  },
  "Cube.load": {
    "description": "Create a cube by some params",
    "returns": "Cube",
    "args": [
      {
        "name": "productIds",
        "type": "List<String>",
        "description": "The product id list for cube creation."
      },
      {
        "name": "StartTime",
        "type": "String",
        "description": "The start time of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "EndTime",
        "type": "String",
        "description": "The end time of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name": "geom",
        "type": "List<Float>",
        "description": "The geom of the product.",
        "optional": "True",
        "default": "null"
      },
      {
        "name":"bands",
        "type": "List<String>",
        "description": "The bands of the product.",
        "optional": "True",
        "default": "null"
      }
    ]
  },
  "Cube.band": {
    "description": "Select a new cube by band name",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to select bands from."
      },
      {
        "name": "bandName",
        "type": "String",
        "description": "The name of band to be selected"
      }
    ]
  },
  "Cube.visualize": {
    "description": "Produces an RGB or grayscale visualization of an Cube.  Each of the gain, bias, min, max and gamma arguments can take either a single value, which will be applied to all bands, or a list of values the same length as bands.",
    "returns": "Cube",
    "args": [
      {
        "name": "cube",
        "type": "Cube",
        "description": "The cube to visualize"
      },
      {
        "name": "products",
        "type": "Object",
        "description": "The products in cube to visualize"
      },
      {
        "name": "bands",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "png",
        "default": "False",
        "optional": "True"
      }
    ]
  },
  "Cube.NDWI": {
    "description": "Compute NDWI of the Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to compute NDWI."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product in cube to compute NDWI"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of NDWI"
      }
    ]
  },
  "Cube.binarization": {
    "description": "Compute binarization of the Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to compute NDWI."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product to compute binarization."
      },
      {
        "name": "threshold",
        "type": "Int",
        "description": "The threshold to binary"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of binary"
      }
    ]
  },
  "Cube.subtract": {
    "description": "Compute binarization of the Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to compute NDWI."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product to compute binarization."
      },
      {
        "name": "timeList",
        "type": "List<String>",
        "description": "The list of time."
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of binary"
      }
    ]
  },
  "Cube.ChangeDetection": {
    "description": "Get the change area of the target Cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to find changed area."
      },
      {
        "name": "product",
        "type": "String",
        "description": "The product in cube to detect the change."
      },
      {
        "name": "certainTimes",
        "type": "List<String>",
        "description": "The time range of two images to get change"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of change detection."
      }
    ]
  },
  "Cube.overlayAnalysis": {
    "description": "Overlay analysis between two cube",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to overlay analysis."
      },
      {
        "name": "raster",
        "type": "String",
        "description": "The raster product in cube to overlay"
      },
      {
        "name": "vector",
        "type": "String",
        "description": "The target vector product in cube to overlay"
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of overlay analysis."
      }
    ]
  },
  "Cube.conjointAnalysis": {
    "description": "Conjoin analysis between raster cube and tabular data",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Cube",
        "description": "The cube to conjoint analysis."
      },
      {
        "name": "vector",
        "type": "String",
        "description": "The vector product in cube to conjoint."
      },
      {
        "name": "tabular",
        "type": "String",
        "description": "The tabular product in cube to conjoint."
      },
      {
        "name": "name",
        "type": "String",
        "description": "The name of result of conjoin analysis."
      }
    ]
  },
  "Service.getCollections": {
    "description": "Getting resource Collections",
    "returns": "Collections",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productIDs",
        "type": "List<String>",
        "description": "The id list of products.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Service.getCollection": {
    "description": "Getting resource Collection of certain id",
    "returns": "Collection",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "collectionId",
        "type": "String",
        "description": "The id of target collection."
      }
    ]
  },
  "Service.getFeatureCollection": {
    "description": "Getting feature collection from resource center",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "collectionId",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "filter",
        "type": "Filter",
        "description": "Filter the properties of feature collection",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Service.getFeature": {
    "description": "Getting resource feature of certain id",
    "returns": "Feature",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "collectionId",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "featureId",
        "type": "String",
        "description": "The id of target feature."
      }
    ]
  },
  "Service.getCoverageCollection": {
    "description": "Getting resource coverage collection of certain id",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "WGS84",
        "optional": "True"
      }
    ]
  },
  "Service.getCoverage": {
    "description": "Getting resource coverage of certain id",
    "returns": "Coverage",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "productID",
        "type": "String",
        "description": "The id of target collection."
      },
      {
        "name": "coverageID",
        "type": "String",
        "description": "The id of target coverage."
      },
      {
        "name": "subset",
        "type": "List<Float>",
        "description": "The subset of target coverage.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "properties",
        "type": "List<String>",
        "description": "Get the bands.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Service.getProcesses": {
    "description": "Getting processes provided by service center",
    "returns": "Processes",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      }
    ]
  },
  "Service.getProcess": {
    "description": "Getting process provided by service center",
    "returns": "Process",
    "args": [
      {
        "name": "baseUrl",
        "type": "String",
        "description": "The base url of service."
      },
      {
        "name": "processId",
        "type": "String",
        "description": "The id of target process."
      }
    ]
  },
  "ProcessResult.visualize": {
    "description": "Visualize the result of process",
    "returns": "ProcessResult",
    "args": [
      {
        "name": "input",
        "type": "ProcessResult",
        "description": "The result of process to be visualized."
      }
    ]
  },
  "Processes.getProcess": {
    "description": "Get the process form the processes.",
    "returns": "Process",
    "args": [
      {
        "name": "processes",
        "type": "Processes",
        "description": "The processes to be selected."
      },
      {
        "name": "processId",
        "type": "String",
        "description": "The id of the certain process."
      }
    ]
  },
  "Collections.getCollection": {
    "description": "Get the collection from collections.",
    "returns": "Collection",
    "args": [
      {
        "name": "input",
        "type": "Collections",
        "description": "The collections as the input data "
      },
      {
        "name": "collectionId",
        "type": "String",
        "description": "The id of the certain collection."
      }
    ]
  },
  "Collections.toCube": {
    "description": "Transform the collections to cube.",
    "returns": "Cube",
    "args": [
      {
        "name": "input",
        "type": "Collections",
        "description": "The collections as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "Cube的空间范围",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "String",
        "description": "Cube的时间范围",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "Cube采用的投影",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bands",
        "type": "List<String>",
        "description": "波段维度",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Collection.getCollectionType": {
    "description": "Get the type of the collection.",
    "returns": "String",
    "args": [
      {
        "name": "collection",
        "type": "Collection",
        "description": "The collection to get type."
      }
    ]
  },
  "Collection.getItem": {
    "description": "Get the item of a collection.",
    "returns": "Item",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      },
      {
        "name": "itemId",
        "type": "String",
        "description": "The id of the target item."
      }
    ]
  },
  "Collection.getNumItems": {
    "description": "Get the number of items in a collection.",
    "returns": "Integer",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      }
    ]
  },
  "Collection.toFeatureCollection": {
    "description": "Transform the collection to featureCollection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      }
    ]
  },
  "Collection.toCoverageCollection": {
    "description": "Transform the collection to featureCollection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      }
    ]
  },
  "Collection.subCollection": {
    "description": "Get part of collection.",
    "returns": "Collection",
    "args": [
      {
        "name": "input",
        "type": "Collection",
        "description": "The collections as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "CoverageCollection.getCollectionType": {
    "description": "Get the type of the coverage collection.",
    "returns": "String",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage collection to get type."
      }
    ]
  },
  "CoverageCollection.getItem": {
    "description": "Get the item of a coverage collection.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "The coverage collection as the input data "
      },
      {
        "name": "itemId",
        "type": "String",
        "description": "The coverage id."
      }
    ]
  },
  "CoverageCollection.getNumItems": {
    "description": "Get the number of items in a coverage collection.",
    "returns": "Integer",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "The coverage collection as the input data "
      }
    ]
  },
  "CoverageCollection.subCollection": {
    "description": "Get part of coverage collection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "The coverage collection as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "filter",
        "type": "Filter",
        "description": "Filter used",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "FeatureCollection.getCollectionType": {
    "description": "Get the type of the feature collection.",
    "returns": "String",
    "args": [
      {
        "name": "featureCollection",
        "type": "FeatureCollection",
        "description": "The feature collection to get type."
      }
    ]
  },
  "FeatureCollection.getItem": {
    "description": "Get the item of a feature collection.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection as the input data "
      },
      {
        "name": "itemId",
        "type": "String",
        "description": "The feature id."
      }
    ]
  },
  "FeatureCollection.getNumItems": {
    "description": "Get the number of items in a feature collection.",
    "returns": "Integer",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection as the input data "
      }
    ]
  },
  "FeatureCollection.subCollection": {
    "description": "Get part of feature collection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection as the input data "
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The range of space used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The range of time used for deleting.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The crs of bbox.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "filter",
        "type": "Filter",
        "description": "The filter to filter the featureCollection.",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Feature.getItemType": {
    "description": "Get type of item.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The feature as the input data "
      }
    ]
  },
  "Coverage.getItemType": {
    "description": "Get type of item.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The feature as the input data "
      }
    ]
  },
  "Coverage.domainSet": {
    "description": "Get the domain set of a coverage.",
    "returns": "Dictionary",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The Coverage as the input data "
      }
    ]
  },
  "Coverage.rangeSet": {
    "description": "Get the range set of a coverage.",
    "returns": "Dictionary",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The Coverage as the input data "
      },
      {
        "name": "subset",
        "type": "Dictionary",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bbox",
        "type": "List<Float>",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "datetime",
        "type": "List<String>",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "properties",
        "type": "List<String>",
        "description": "Select specific data record fields (measured/observed properties) to be returned.",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleFactor",
        "type": "Float",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleAxes",
        "type": "Dictionary",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleSize",
        "type": "Dictionary",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "scaleCrs",
        "type": "String",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "bboxCrs",
        "type": "String",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "The Coverage as the input data ",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Coverage.rangeType": {
    "description": "Get the range type of a coverage.",
    "returns": "Dictionary",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The Coverage as the input data "
      }
    ]
  },
  "Coverage.add": {
    "description": "Adds the first value to the second for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types. ",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.subtract": {
    "description": "Subtracts the second value from the first for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.divide": {
    "description": "Divides the first value by the second, returning 0 for division by 0 for each matched pair of bands in image1 and image2. If either image1 or image2 has only 1 band, then it is used against all the bands in the other image. If the images have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in image1's order. The type of the output pixels is the union of the input types.",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage1",
        "type": "Coverage",
        "description": "The image from which the left operand bands are taken."
      },
      {
        "name": "coverage2",
        "type": "Coverage",
        "description": "The image from which the right operand bands are taken."
      }
    ]
  },
  "Coverage.binarization": {
    "description": "Returns 0 iff the first value is smaller than threshold,else return 255",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverage",
        "type": "Coverage",
        "description": "The coverage from which the left operand bands are taken"
      },
      {
        "name": "threshold",
        "type": "Int",
        "description": "threshold"
      }
    ]
  },
  "CoverageCollection.binarization": {
    "description": "Returns 0 iff the first value is smaller than threshold,else return 255",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      },
      {
        "name": "threshold",
        "type": "Int",
        "description": "threshold"
      }
    ]
  },
  "CoverageCollection.mosaic": {
    "description": "mosaic the coverages",
    "returns": "Coverage",
    "args": [
      {
        "name": "coverageCollection",
        "type": "CoverageCollection",
        "description": "The coverage from which the left operand bands are taken"
      },
      {
        "name": "method",
        "type": "String",
        "description": "the method to mosaic the coverages"
      }
    ]
  },
  "Coverage.addStyles": {
    "description": "Add the styles to the coverage.",
    "returns": "Coverage",
    "args": [
      {
        "name": "input",
        "type": "Coverage",
        "description": "The coverage to be added styles"
      },
      {
        "name": "bands",
        "type": "List<String>",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "",
        "default": "png",
        "optional": "True"
      }
    ]
  },
  "Cube.addStyles": {
    "description": "Add the styles to the coverage.",
    "returns": "Cube",
    "args": [
      {
        "name": "cube",
        "type": "Cube",
        "description": "The cube to visualize"
      },
      {
        "name": "products",
        "type": "Object",
        "description": "The products in cube to visualize"
      },
      {
        "name": "bands",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "png",
        "default": "False",
        "optional": "True"
      }
    ]
  },
  "CoverageCollection.addStyles": {
    "description": "Add the styles to the coverage collection.",
    "returns": "CoverageCollection",
    "args": [
      {
        "name": "input",
        "type": "CoverageCollection",
        "description": "The coverage collection to be added styles"
      },
      {
        "name": "bands",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gain",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "bias",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "min",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "max",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "gamma",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "opacity",
        "type": "Float",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "palette",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      },
      {
        "name": "format",
        "type": "String",
        "description": "png",
        "default": "False",
        "optional": "True"
      },
      {
        "name": "method",
        "type": "String",
        "description": "",
        "default": "null",
        "optional": "True"
      }
    ]
  },
  "Feature.addStyles": {
    "description": "Add the styles to the feature.",
    "returns": "Feature",
    "args": [
      {
        "name": "input",
        "type": "Feature",
        "description": "The coverage collection to be added styles"
      },
      {
        "name": "color",
        "type": "String",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "FeatureCollection.addStyles": {
    "description": "Add the styles to the feature collection.",
    "returns": "FeatureCollection",
    "args": [
      {
        "name": "input",
        "type": "FeatureCollection",
        "description": "The feature collection to be added styles"
      },
      {
        "name": "color",
        "type": "String",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "ProcessResult.addStyles": {
    "description": "Add the styles to the result of process.",
    "returns": "ProcessResult",
    "args": [
      {
        "name": "input",
        "type": "ProcessResult",
        "description": "The feature collection to be added styles"
      },
      {
        "name": "args",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "Item.addStyles": {
    "description": "Add the styles to item.",
    "returns": "Item",
    "args": [
      {
        "name": "input",
        "type": "Item",
        "description": "The item to be added styles"
      },
      {
        "name": "args",
        "type": "Object",
        "description": "",
        "default": "None",
        "optional": "True"
      }
    ]
  },
  "Item.getItemType": {
    "description": "Get type of item.",
    "returns": "String",
    "args": [
      {
        "name": "input",
        "type": "Item",
        "description": "The feature as the input data "
      }
    ]
  },
  "Filter.equals": {
    "description": "Check if filter equals others",
    "returns": "Filter",
    "args": [
      {
        "name": "leftField",
        "type": "String",
        "description": "Field name"
      },
      {
        "name": "rightValue",
        "type": "Object",
        "description": "value"
      }
    ]
  },
  "Filter.and": {
    "description": "Filter and",
    "returns": "Filter",
    "args": [
      {
        "name": "filters",
        "type": "List<String>",
        "description": "Filters"
      }
    ]
  },
  "Feature.load": {
    "description": "load data",
    "returns": "Feature",
    "args": [
      {
        "name": "productName",
        "type": "String",
        "description": "productName"
      },
      {
        "name": "dateTime",
        "type": "String",
        "description": "dataTime",
        "default": "null"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS",
        "default": "EPSG:4326"
      }
    ]
  },
  "Feature.point": {
    "description": "create a Point",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.lineString": {
    "description": "create a LineString",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.linearRing": {
    "description": "create a LinearRing",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.polygon": {
    "description": "create a Polygon",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.multiPoint": {
    "description": "create a multiPoint",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.multiLineString": {
    "description": "create a MultiLineString",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.multiPolygon": {
    "description": "create a MultiPoint",
    "returns": "Feature",
    "args": [
      {
        "name": "coors",
        "type": "String",
        "description": "Coordinates"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.geometry": {
    "description": "create a geometry",
    "returns": "Feature",
    "args": [
      {
        "name": "gjson",
        "type": "String",
        "description": "geojson"
      },
      {
        "name": "properties",
        "type": "String",
        "description": "Properties"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.area": {
    "description": "compute area",
    "returns": "List[Double]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.bounds": {
    "description": "compute area",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "Coordinates"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.featureCollection": {
    "description": "create a featureCollection",
    "returns": "Feature",
    "args": [
      {
        "name": "featureList",
        "type": "List[Feature]",
        "description": "featureList"
      }
    ]
  },
  "Feature.centroid": {
    "description": "compute bounds",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.buffer": {
    "description": "compute buffer",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "distance",
        "type": "Double",
        "description": "distance"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.convexHull": {
    "description": "compute convexHull",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.coordinates": {
    "description": "compute coordinates",
    "returns": "List[Array[Coordinate]]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.reproject": {
    "description": "reproject",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "tarCrsCode",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.isUnbounded": {
    "description": "judge a geometry is unbounded",
    "returns": "List[Boolean]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.getType": {
    "description": "Returns the GeoJSON type of the geometry",
    "returns": "List[String]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.projection": {
    "description": "Returns the projection of the geometry.",
    "returns": "List[Int]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.toGeoJSONString": {
    "description": "Returns a GeoJSON string representation of the geometry.",
    "returns": "List[String]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.length": {
    "description": "compute length",
    "returns": "List[Double]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.dissolve": {
    "description": "Computes the union of all the elements of this geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.contains": {
    "description": "Returns true iff one geometry contains the other.",
    "returns": "Boolean",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.containedIn": {
    "description": "Returns true iff one geometry is contained in the other.",
    "returns": "Boolean",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.disjoint": {
    "description": "Returns true iff the geometries are disjoint.",
    "returns": "Boolean",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.distance": {
    "description": "Returns the minimum distance between two geometries.",
    "returns": "Double",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.difference": {
    "description": "Returns the result of subtracting the 'right' geometry from the 'left' geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.intersection": {
    "description": "Returns the intersection of the two geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.intersects": {
    "description": "Returns true iff the geometries intersect.",
    "returns": "Boolean",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.symmetricDifference": {
    "description": "Returns the symmetric difference between two geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.union": {
    "description": "Returns the union of the two geometries.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.withDistance": {
    "description": "Returns true iff the geometries are within a specified distance.",
    "returns": "Boolean",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "crs",
        "type": "String",
        "description": "CRS"
      }
    ]
  },
  "Feature.copyProperties": {
    "description": "Copies metadata properties from one element to another.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD1",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "featureRDD2",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "properties",
        "type": "List[String]",
        "description": "The properties to copy. If omitted, all properties are copied."
      }
    ]
  },
  "Feature.get": {
    "description": "Extract a property from a feature.",
    "returns": "List[Any]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.getNumber": {
    "description": "Extract a property from a feature.",
    "returns": "List[Double]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.getString": {
    "description": "Extract a property from a feature.",
    "returns": "List[String]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.getArray": {
    "description": "Extract a property from a feature.",
    "returns": "List[Array[String]]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "The property to extract."
      }
    ]
  },
  "Feature.propertyNames": {
    "description": "Returns the names of properties on this element.",
    "returns": "List[List[String]]",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.set": {
    "description": "Overrides one or more metadata properties of an Element.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "property",
        "type": "String",
        "description": "the property to set. it is a json"
      }
    ]
  },
  "Feature.setGeometry": {
    "description": "Returns the feature, with the geometry replaced by the specified geometry.",
    "returns": "Feature",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "geom",
        "type": "Feature",
        "description": "feature"
      }
    ]
  },
  "Feature.inverseDistanceWeighted": {
    "description": "InverseDistanceWeighted Interpolation",
    "returns": "Image<unknown bands>",
    "args": [
      {
        "name": "featureRDD",
        "type": "Feature",
        "description": "feature"
      },
      {
        "name": "propertyName",
        "type": "String",
        "description": "the property to select"
      }
    ]
  }
}