package whu.edu.cn.trajectory.db.query.basic.query;

import whu.edu.cn.trajectory.base.trajectory.Trajectory;
import whu.edu.cn.trajectory.db.coprocessor.STCoprocessorQuery;
import whu.edu.cn.trajectory.db.coprocessor.autogenerated.QueryCondition;
import whu.edu.cn.trajectory.db.database.DataSet;
import whu.edu.cn.trajectory.db.database.meta.IndexMeta;
import whu.edu.cn.trajectory.db.database.table.IndexTable;
import whu.edu.cn.trajectory.db.enums.IndexType;
import whu.edu.cn.trajectory.db.enums.TemporalQueryType;
import whu.edu.cn.trajectory.db.index.RowKeyRange;
import whu.edu.cn.trajectory.db.query.basic.condition.AbstractQueryCondition;
import whu.edu.cn.trajectory.db.query.basic.condition.SpatialQueryCondition;
import whu.edu.cn.trajectory.db.query.basic.condition.SpatialTemporalQueryCondition;
import whu.edu.cn.trajectory.db.query.basic.condition.TemporalQueryCondition;

import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * @author xuqi
 * @date 2023/12/01
 */
public class SpatialTemporalQuery extends AbstractQuery {

  private boolean filterBeforeLookFullRow = true;

  public SpatialTemporalQuery(DataSet dataSet, AbstractQueryCondition abstractQueryCondition)
      throws IOException {
    super(dataSet, abstractQueryCondition);
  }

  public SpatialTemporalQuery(IndexTable indexTable, AbstractQueryCondition abstractQueryCondition)
      throws IOException {
    super(indexTable, abstractQueryCondition);
  }

  public SpatialTemporalQuery(
      IndexTable indexTable,
      AbstractQueryCondition abstractQueryCondition,
      boolean filterBeforeLookFullRow)
      throws IOException {
    super(indexTable, abstractQueryCondition);
    this.filterBeforeLookFullRow = filterBeforeLookFullRow;
  }

  @Override
  public List<RowKeyRange> getIndexRanges() throws IOException {
    setupTargetIndexTable();
    return targetIndexTable.getIndexMeta().getIndexStrategy().getScanRanges(abstractQueryCondition);
  }

  @Override
  public List<Trajectory> executeQuery() throws IOException {
    List<RowKeyRange> rowKeyRanges = getIndexRanges();
    return executeQuery(rowKeyRanges);
  }

  @Override
  public List<Trajectory> executeQuery(List<RowKeyRange> rowKeyRanges) throws IOException {
    List<QueryCondition.Range> ranges = rowKeyRangeToProtoRange(rowKeyRanges);
    SpatialTemporalQueryCondition spatialTemporalQueryCondition =
        (SpatialTemporalQueryCondition) abstractQueryCondition;
    SpatialQueryCondition spatialQueryCondition =
        spatialTemporalQueryCondition.getSpatialQueryCondition();
    TemporalQueryCondition temporalQueryCondition =
        spatialTemporalQueryCondition.getTemporalQueryCondition();
    List<QueryCondition.TemporalQueryWindow> temporalQueryWindows =
        IDTemporalQuery.buildProtoTemporalWindows(temporalQueryCondition);
    QueryCondition.QueryRequest spatialTemporalQueryRequest =
        QueryCondition.QueryRequest.newBuilder()
            .setSpatialQueryType(
                spatialQueryCondition.getQueryType()
                        == SpatialQueryCondition.SpatialQueryType.CONTAIN
                    ? QueryCondition.QueryType.CONTAIN
                    : QueryCondition.QueryType.INTERSECT)
            .setSpatialQueryWindow(
                QueryCondition.SpatialQueryWindow.newBuilder()
                    .setWkt(spatialQueryCondition.getQueryWindowWKT()))
            .setTemporalQueryType(
                temporalQueryCondition.getTemporalQueryType() == TemporalQueryType.CONTAIN
                    ? QueryCondition.QueryType.CONTAIN
                    : QueryCondition.QueryType.INTERSECT)
            .setTemporalQueryWindows(
                QueryCondition.TemporalQueryWindows.newBuilder()
                    .addAllTemporalQueryWindow(temporalQueryWindows)
                    .build())
            .setFilterBeforeLookFullRow(filterBeforeLookFullRow)
            .addAllRange(ranges)
            .build();

    return STCoprocessorQuery.executeQuery(targetIndexTable, spatialTemporalQueryRequest);
  }

  @Override
  public IndexMeta findBestIndex() {
    Map<IndexType, List<IndexMeta>> map = dataSet.getDataSetMeta().getAvailableIndexes();
    // find a st index
    List<IndexMeta> spatialIndexList = null;
    if (map.containsKey(IndexType.TXZ2)) {
      spatialIndexList = map.get(IndexType.TXZ2);
    } else if (map.containsKey(IndexType.XZ2T)) {
      spatialIndexList = map.get(IndexType.XZ2T);
    }
    if (spatialIndexList != null) {
      return IndexMeta.getBestIndexMeta(spatialIndexList);
    }
    // TODO: 直接抛异常，禁止全表扫描
    // no st index so we will do a full table scan, we select a main index.
    return dataSet.getDataSetMeta().getCoreIndexMeta();
  }

  @Override
  public String getQueryInfo() {
    return null;
  }
}
