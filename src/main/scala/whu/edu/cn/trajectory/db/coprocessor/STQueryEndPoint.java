package whu.edu.cn.trajectory.db.coprocessor;

import com.google.protobuf.ByteString;
import com.google.protobuf.RpcCallback;
import com.google.protobuf.RpcController;
import com.google.protobuf.Service;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.Coprocessor;
import org.apache.hadoop.hbase.CoprocessorEnvironment;
import org.apache.hadoop.hbase.client.Get;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.hbase.coprocessor.CoprocessorException;
import org.apache.hadoop.hbase.coprocessor.CoprocessorService;
import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;
import org.apache.hadoop.hbase.filter.MultiRowRangeFilter;
import org.apache.hadoop.hbase.regionserver.InternalScanner;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import whu.edu.cn.trajectory.base.mbr.MinimumBoundingBox;
import whu.edu.cn.trajectory.base.trajectory.Trajectory;
import whu.edu.cn.trajectory.base.util.BasicDateUtils;
import whu.edu.cn.trajectory.db.coprocessor.autogenerated.QueryCondition;
import whu.edu.cn.trajectory.db.database.Database;
import whu.edu.cn.trajectory.db.database.table.IndexTable;
import whu.edu.cn.trajectory.db.datatypes.TimeLine;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import static whu.edu.cn.trajectory.db.constant.DBConstants.*;
import static whu.edu.cn.trajectory.db.database.util.TrajectorySerdeUtils.*;

/**
 * @author xuqi
 * @date 2023/12/04
 */
public class STQueryEndPoint extends QueryCondition.QueryService implements Coprocessor, CoprocessorService {

    private final Logger logger = LoggerFactory.getLogger(STQueryEndPoint.class);
    private RegionCoprocessorEnvironment env;
    private Database instance = null;

    @Override
    public void query(RpcController controller, QueryCondition.QueryRequest request,
                      RpcCallback<QueryCondition.QueryResponse> done) {
        boolean filterBeforeLookFullRow = request.getFilterBeforeLookFullRow();
        List<QueryCondition.Range> rangeList = request.getRangeList();
        List<QueryCondition.TrajectoryResult> trajectoryResults = new ArrayList<>();
        try {
            // 将Range List按照是否需要二次判断分组，并生成两个Scan
            List<MarkedScan> markedScans = getTowScan(rangeList);
            // 扫描, 解析结果
            for (MarkedScan markedScan : markedScans) {
                Scan scan = markedScan.scan;
                InternalScanner scanner = env.getRegion().getScanner(scan);
                List<Cell> cells = new ArrayList<>();
                boolean hasMore = scanner.next(cells) || !cells.isEmpty();
                while (hasMore) {
                    Result result = Result.create(cells);
                    if (!markedScan.needFilter) {
                        if (!isMainIndexed(result)) {
                            result = getMainIndexedResult(result);
                        }
                        trajectoryResults.add(buildTrajectoryResult(result));
                    } else {
                        // 如果当前索引是辅助索引，且不需要在回表查询之前作粗过滤，则先回表查询。
                        if (!isMainIndexed(result) && !filterBeforeLookFullRow) {
                            result = getMainIndexedResult(result);
                        }
                        // 使用pos code, mbr等粗过滤
                        if (coarseFilter(result, request)) {
                            // 如果filterBeforeLookFullRow为真，则此时result仍然是辅助索引
                            // 相当于先通过了初步过滤，现在要回表查询。
                            if (!isMainIndexed(result)) {
                                result = getMainIndexedResult(result);
                            }
                            // 使用point list作精过滤
                            if (fineFilter(result, request)) {
                                trajectoryResults.add(buildTrajectoryResult(result));
                            }
                        }
                    }
                    // 读取下一行
                    cells.clear();
                    hasMore = scanner.next(cells) || !cells.isEmpty();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        QueryCondition.QueryResponse response = QueryCondition.QueryResponse.newBuilder().addAllList(trajectoryResults).build();
        done.run(response);
    }

    /**
     * Get a scan list with at most size 2 to scan ranges that need / don't need server-side column filter
     * respectively.
     *
     * @return The scan object at offset 0 will read all records that <strong>absolutely</strong> meet
     * the query request, the other object at offset 1 will read all records that <strong>may</strong>
     * meet the query request according to the row key coding strategy.
     * @throws IOException
     */
    private List<MarkedScan> getTowScan(List<QueryCondition.Range> rangeList) throws IOException {
        List<MultiRowRangeFilter.RowRange> rowRangeListConfirmed = new ArrayList<>(rangeList.size());
        List<MultiRowRangeFilter.RowRange> rowRangeListSuspected = new ArrayList<>(rangeList.size());
        for (QueryCondition.Range range : rangeList) {
            List<MultiRowRangeFilter.RowRange> listToAdd =
                    range.getContained() ? rowRangeListConfirmed : rowRangeListSuspected;
            listToAdd.add(new MultiRowRangeFilter.RowRange(range.getStart().toByteArray(), true,
                    range.getEnd().toByteArray(), false));
        }
        List<MarkedScan> markedScans = new LinkedList<>();
        if (!rowRangeListConfirmed.isEmpty()) {
            Scan scan0 = buildScan();
            scan0.addColumn(COLUMN_FAMILY, PTR_QUALIFIER);
            scan0.setFilter(new MultiRowRangeFilter(rowRangeListConfirmed));
            markedScans.add(new MarkedScan(scan0, false));
        }
        if (!rowRangeListSuspected.isEmpty()) {
            Scan scan1 = buildScan();
            scan1.addColumn(COLUMN_FAMILY, PTR_QUALIFIER);
            scan1.setFilter(new MultiRowRangeFilter(rowRangeListSuspected));
            markedScans.add(new MarkedScan(scan1, true));
        }
        return markedScans;
    }

    /**
     * 获取含以下列的scan: mbr, start, end, plist, mo_id, traj_id, ptr
     */
    protected Scan buildScan() {
        Scan scan = new Scan();
        scan.addColumn(COLUMN_FAMILY, MBR_QUALIFIER);
        scan.addColumn(COLUMN_FAMILY, START_POINT_QUALIFIER);
        scan.addColumn(COLUMN_FAMILY, END_POINT_QUALIFIER);
        scan.addColumn(COLUMN_FAMILY, TRAJ_POINTS_QUALIFIER);
        scan.addColumn(COLUMN_FAMILY, OBJECT_ID_QUALIFIER);
        scan.addColumn(COLUMN_FAMILY, TRAJECTORY_ID_QUALIFIER);
        scan.addColumn(COLUMN_FAMILY, PTR_QUALIFIER);
        return scan;
    }

    /**
     * 基于辅助索引表的行回表，获取主索引表的行：
     * 先从Instance获取数据集的名称，再找到coreIndex
     */
    private Result getMainIndexedResult(Result result) throws IOException {
        return instance.getDataSet(IndexTable.extractDataSetName(env.getRegionInfo().getTable().getNameAsString()))
                .getCoreIndexTable()
                .get(new Get(result.getValue(COLUMN_FAMILY, PTR_QUALIFIER)));
    }


    /**
     * 基于result内以单独列存储的信息作粗过滤, 例如:mbr, start_time, end_time等.
     *
     * @param result
     * @param queryRequest
     * @return
     */
    protected boolean coarseFilter(Result result, QueryCondition.QueryRequest queryRequest) {
        WKTReader wktReader = new WKTReader();
        boolean spatialValidate = false;
        boolean temporalValidate = false;
        // 利用MBR对QueryRequest中的空间约束作初步判断
        if (queryRequest.hasSpatialQueryWindow()) {
            try {
                Geometry queryGeom = wktReader.read(queryRequest.getSpatialQueryWindow().getWkt());
                MinimumBoundingBox mbr = getTrajectoryMBR(result);
                if (queryRequest.getSpatialQueryType() == QueryCondition.QueryType.CONTAIN) {
                    spatialValidate = queryGeom.contains(mbr.toPolygon(4326));
                } else {
                    spatialValidate = queryGeom.intersects(mbr.toPolygon(4326));
                }
            } catch (ParseException | IOException e) {
                e.printStackTrace();
            }
        } else {
            spatialValidate = true;
        }
        if (queryRequest.hasTemporalQueryWindows()) {
            List<QueryCondition.TemporalQueryWindow> temporalQueryWindowList = queryRequest.getTemporalQueryWindows()
                    .getTemporalQueryWindowList();
            // start and end time of the traj
            TimeLine trajTimeLine = getTrajectoryTimeLine(result);
            for (QueryCondition.TemporalQueryWindow temporalQueryWindow : temporalQueryWindowList) {
                TimeLine queryTimeLine = new TimeLine(BasicDateUtils.timeToZonedTime(temporalQueryWindow.getStartMs()),
                        BasicDateUtils.timeToZonedTime(temporalQueryWindow.getEndMs()));
                if (queryRequest.getTemporalQueryType() == QueryCondition.QueryType.CONTAIN) {
                    temporalValidate = temporalValidate || queryTimeLine.contain(trajTimeLine);
                } else {
                    temporalValidate = temporalValidate || queryTimeLine.intersect(trajTimeLine);
                }
            }
        } else {
            temporalValidate = true;
        }
        return spatialValidate && temporalValidate;
    }

    /**
     * 根据需要配置具体的精过滤条件, 对于最常用的时间\空间条件, 已提供了如下开箱即用的精过滤方法:
     *
     * @see STQueryEndPoint#spatialFineFilter(Result, QueryCondition.QueryRequest)
     */
    protected boolean fineFilter(Result result, QueryCondition.QueryRequest queryRequest) throws IOException {
        boolean validate = true;
        if (queryRequest.hasSpatialQueryWindow()) {
            validate = spatialFineFilter(result, queryRequest);
        }
        return validate;
    }

    /**
     * Fine filter based on trajectory line string.
     *
     * @param result       A main indexed trajectory row.
     * @param queryRequest To get spatial query polygon and spatial query type.
     * @return Whether the result trajectory satisfies queryCondition.
     */
    protected boolean spatialFineFilter(Result result, QueryCondition.QueryRequest queryRequest) throws IOException {
        Trajectory trajectory = mainRowToTrajectory(result);
        WKTReader wktReader = new WKTReader();
        try {
            Geometry queryGeom = wktReader.read(queryRequest.getSpatialQueryWindow().getWkt());
            if (queryRequest.getSpatialQueryType() == QueryCondition.QueryType.CONTAIN) {
                return queryGeom.contains(trajectory.getLineString());
            }
            return queryGeom.intersects(trajectory.getLineString());
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return false;
    }

    @Override
    public void start(CoprocessorEnvironment env) throws IOException {
        if (env instanceof RegionCoprocessorEnvironment) {
            this.env = (RegionCoprocessorEnvironment) env;
            this.instance = Database.getInstance();
        } else {
            throw new CoprocessorException("Failed to init coprocessor env.");
        }
    }

    @Override
    public void stop(CoprocessorEnvironment env) throws IOException {
        logger.warn("STQueryEndPoint is unregistered, running stop() hook!");
    }

    @Override
    public Service getService() {
        return this;
    }

    static class MarkedScan {

        Scan scan;
        boolean needFilter;

        MarkedScan(Scan scan, boolean needFilter) {
            this.scan = scan;
            this.needFilter = needFilter;
        }
    }

    private QueryCondition.TrajectoryResult buildTrajectoryResult(Result result){
        return QueryCondition.TrajectoryResult.newBuilder()
                .setRowkey(ByteString.copyFrom(result.getRow()))
                .setTrajPointList(
                        ByteString.copyFrom(getByteArrayByQualifier(result, TRAJ_POINTS_QUALIFIER)))
                .setObjectId(ByteString.copyFrom(
                        getByteArrayByQualifier(result, OBJECT_ID_QUALIFIER)))
                .setTid(ByteString.copyFrom(
                        getByteArrayByQualifier(result, TRAJECTORY_ID_QUALIFIER)))
                .build();
    }
}
